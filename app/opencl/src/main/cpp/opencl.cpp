#include <stdlib.h>
#include <stdint.h>
#include <dlfcn.h>
#include <cmath>
#include <android/log.h>
#include <cstring>
#include "opencl.h"
#include "CL/cl.h"
#include "opencl.h"
#include "FunctionsOpenCL.h"
#include "DataOpenCL.h"
#include "ClassToString.h"

extern "C" {
JNICALL void Java_com_draico_asvappra_opencl_OpenCL_LoadOpenCL(JNIEnv *env, jobject openCL) {
    void *handle = dlopen("/system/vendor/lib64/libOpenCL.so", RTLD_NOW);
    if (handle == NULL) handle = dlopen("/system/vendor/lib/libOpenCL.so", RTLD_NOW);
    if (handle == NULL) showMessageError(env, "The library OpenCL not found in this dispositive android!");
    else {
        CLGetPlatformIDs = reinterpret_cast<_clGetPlatformIDs>(dlsym(handle, "clGetPlatformIDs"));
        CLGetPlatformInfo = reinterpret_cast<_clGetPlatformInfo>(dlsym(handle, "clGetPlatformInfo"));
        CLGetDeviceIDs = reinterpret_cast<_clGetDeviceIDs>(dlsym(handle, "clGetDeviceIDs"));
        CLGetDeviceInfo = reinterpret_cast<_clGetDeviceInfo>(dlsym(handle, "clGetDeviceInfo"));
        CLGetDeviceAndHostTimer = reinterpret_cast<_clGetDeviceAndHostTimer>(dlsym(handle, "clGetDeviceAndHostTimer"));
        CLGetHostTimer = reinterpret_cast<_clGetHostTimer>(dlsym(handle, "clGetHostTimer"));
        CLCreateSubDevices = reinterpret_cast<_clCreateSubDevices>(dlsym(handle, "clCreateSubDevices"));
        CLRetainDevice = reinterpret_cast<_clRetainDevice>(dlsym(handle, "clRetainDevice"));
        CLReleaseDevice = reinterpret_cast<_clReleaseDevice>(dlsym(handle, "clReleaseDevice"));
        CLCreateContext = reinterpret_cast<_clCreateContext>(dlsym(handle, "clCreateContext"));
        CLCreateContextFromType = reinterpret_cast<_clCreateContextFromType>(dlsym(handle, "clCreateContextFromType"));
        CLRetainContext = reinterpret_cast<_clRetainContext>(dlsym(handle, "clRetainContext"));
        CLReleaseContext = reinterpret_cast<_clReleaseContext>(dlsym(handle, "clReleaseContext"));
        CLGetContextInfo = reinterpret_cast<_clGetContextInfo>(dlsym(handle, "clGetContextInfo"));
        CLCreateCommandQueueWithProperties = reinterpret_cast<_clCreateCommandQueueWithProperties>(dlsym(handle, "clCreateCommandQueueWithProperties"));
        CLSetDefaultDeviceCommandQueue = reinterpret_cast<_clSetDefaultDeviceCommandQueue>(dlsym(handle, "clSetDefaultDeviceCommandQueue"));
        CLRetainCommandQueue = reinterpret_cast<_clRetainCommandQueue>(dlsym(handle, "clRetainCommandQueue"));
        CLReleaseCommandQueue = reinterpret_cast<_clReleaseCommandQueue>(dlsym(handle, "clReleaseCommandQueue"));
        CLFlush = reinterpret_cast<_clFlush>(dlsym(handle, "clFlush"));
        CLFinish = reinterpret_cast<_clFinish>(dlsym(handle, "clFinish"));
        CLGetCommandQueueInfo = reinterpret_cast<_clGetCommandQueueInfo>(dlsym(handle, "clGetCommandQueueInfo"));
        CLCreateBuffer = reinterpret_cast<_clCreateBuffer>(dlsym(handle, "clCreateBuffer"));
        CLCreateSubBuffer = reinterpret_cast<_clCreateSubBuffer>(dlsym(handle, "clCreateSubBuffer"));
        CLEnqueueReadBuffer = reinterpret_cast<_clEnqueueReadBuffer>(dlsym(handle, "clEnqueueReadBuffer"));
        CLEnqueueWriteBuffer = reinterpret_cast<_clEnqueueWriteBuffer>(dlsym(handle, "clEnqueueWriteBuffer"));
        CLEnqueueReadBufferRect = reinterpret_cast<_clEnqueueReadBufferRect>(dlsym(handle, "clEnqueueReadBufferRect"));
        CLEnqueueWriteBufferRect = reinterpret_cast<_clEnqueueWriteBufferRect>(dlsym(handle, "clEnqueueWriteBufferRect"));
        CLEnqueueCopyBuffer = reinterpret_cast<_clEnqueueCopyBuffer>(dlsym(handle,"clEnqueueCopyBuffer"));
        CLEnqueueCopyBufferRect = reinterpret_cast<_clEnqueueCopyBufferRect>(dlsym(handle, "clEnqueueCopyBufferRect"));
        CLEnqueueFillBuffer = reinterpret_cast<_clEnqueueFillBuffer>(dlsym(handle, "clEnqueueFillBuffer"));
        CLEnqueueMapBuffer = reinterpret_cast<_clEnqueueMapBuffer>(dlsym(handle, "clEnqueueMapBuffer"));
        CLReleaseBuffer = reinterpret_cast<_clReleaseBuffer>(dlsym(handle, "clReleaseMemObject"));
        CLCreateUserEvent = reinterpret_cast<_clCreateUserEvent>(dlsym(handle, "clCreateUserEvent"));
        CLSetUserEventStatus = reinterpret_cast<_clSetUserEventStatus>(dlsym(handle, "clSetUserEventStatus"));
        CLWaitForEvents = reinterpret_cast<_clWaitForEvents>(dlsym(handle, "clWaitForEvents"));
        CLGetEventInfo = reinterpret_cast<_clGetEventInfo>(dlsym(handle, "clGetEventInfo"));
        CLSetEventCallback = reinterpret_cast<_clSetEventCallback>(dlsym(handle, "clSetEventCallback"));
        CLRetainEvent = reinterpret_cast<_clRetainEvent>(dlsym(handle, "clRetainEvent"));
        CLReleaseEvent = reinterpret_cast<_clReleaseEvent>(dlsym(handle, "clReleaseEvent"));
        CLEnqueueMarkerWithWaitList = reinterpret_cast<_clEnqueueMarkerWithWaitList>(dlsym(handle, "clEnqueueMarketWithWaitList"));
        CLEnqueueBarrierWithWaitList = reinterpret_cast<_clEnqueueBarrierWithWaitList>(dlsym(handle, "clEnqueueBarrierWithWaitList"));
        CLGetEventProfilingInfo = reinterpret_cast<_clGetEventProfilingInfo>(dlsym(handle, "clGetEventProfilingInfo"));
        CLSVMAlloc = reinterpret_cast<_clSVMAlloc>(dlsym(handle, "clSVMAlloc"));
        CLSVMFree = reinterpret_cast<_clSVMFree>(dlsym(handle, "clSVMFree"));
        CLEnqueueSVMFree = reinterpret_cast<_clEnqueueSVMFree>(dlsym(handle, "clEnqueueSVMFree"));
        CLEnqueueSVMMemcpy = reinterpret_cast<_clEnqueueSVMMemcpy>(dlsym(handle, "clEnqueueSVMMemcpy"));
        CLEnqueueSVMMemFill = reinterpret_cast<_clEnqueueSVMMemFill>(dlsym(handle, "clEnqueueSVMMemFill"));
        CLEnqueueSVMMap = reinterpret_cast<_clEnqueueSVMMap>(dlsym(handle, "clEnqueueSVMMap"));
        CLEnqueueSVMUnmap = reinterpret_cast<_clEnqueueSVMUnmap>(dlsym(handle, "clEnqueueSVMUnmap"));
        CLEnqueueSVMMigrateMem = reinterpret_cast<_clEnqueueSVMMigrateMem>(dlsym(handle, "clEnqueueSVMMirateMem"));
        CLCreateImage = reinterpret_cast<_clCreateImage>(dlsym(handle, "clCreateImage"));
        CLGetSupportedImageFormats = reinterpret_cast<_clGetSupportedImageFormats>(dlsym(handle, "clGetSupportedImageFormats"));
        CLEnqueueReadImage = reinterpret_cast<_clEnqueueReadImage>(dlsym(handle, "clEnqueueReadImage"));
        CLEnqueueWriteImage = reinterpret_cast<_clEnqueueWriteImage>(dlsym(handle, "clEnqueueWriteImage"));
        CLEnqueueCopyImage = reinterpret_cast<_clEnqueueCopyImage>(dlsym(handle, "clEnqueueCopyImage"));
        CLEnqueueFillImage = reinterpret_cast<_clEnqueueFillImage>(dlsym(handle, "clEnqueueFillImage"));
        CLEnqueueCopyImageToBuffer = reinterpret_cast<_clEnqueueCopyImageToBuffer>(dlsym(handle, "clEnqueueCopyImageToBuffer"));
        CLEnqueueCopyBufferToImage = reinterpret_cast<_clEnqueueCopyBufferToImage>(dlsym(handle, "clEnqueueCopyBufferToImage"));
        CLEnqueueMapImage = reinterpret_cast<_clEnqueueMapImage>(dlsym(handle, "clEnqueueMapImage"));
        CLGetImageInfo = reinterpret_cast<_clGetImageInfo>(dlsym(handle, "clGetImageInfo"));
        CLCreatePipe = reinterpret_cast<_clCreatePipe>(dlsym(handle, "clCreatePipe"));
        CLGetPipeInfo = reinterpret_cast<_clGetPipeInfo>(dlsym(handle, "clGetPipeInfo"));
        CLRetainMemObject = reinterpret_cast<_clRetainMemObject>(dlsym(handle, "clRetainMemObject"));
        CLReleaseMemObject = reinterpret_cast<_clReleaseMemObject>(dlsym(handle, "clReleaseMemObject"));
        CLEnqueueUnmapMemObject = reinterpret_cast<_clEnqueueUnmapMemObject>(dlsym(handle, "clEnqueueUnmapMemObject"));
        CLEnqueueMigrateMemObjects = reinterpret_cast<_clEnqueueMigrateMemObjects>(dlsym(handle, "clEnqueueMigrateMemObjects"));
        CLSetMemObjectDestructorCallback = reinterpret_cast<_clSetMemObjectDestructorCallback>(dlsym(handle, "clSetMemObjectDestructorCallback"));
        CLCreateSamplerWithProperties = reinterpret_cast<_clCreateSamplerWithProperties>(dlsym(handle, "clCreateSamplerWithProperties"));
        CLRetainSampler = reinterpret_cast<_clRetainSampler>(dlsym(handle, "clRetainSampler"));
        CLReleaseSampler = reinterpret_cast<_clReleaseSampler>(dlsym(handle, "clReleaseSampler"));
        CLGetSamplerInfo = reinterpret_cast<_clGetSamplerInfo>(dlsym(handle, "clGetSamplerInfo"));
        CLCreateProgramWithSource = reinterpret_cast<_clCreateProgramWithSource>(dlsym(handle, "clCreateProgramWithSource"));
        CLCreateProgramWithIL = reinterpret_cast<_clCreateProgramWithIL>(dlsym(handle, "clCreateProgramWithIL"));
        CLCreateProgramWithBinary = reinterpret_cast<_clCreateProgramWithBinary>(dlsym(handle, "clCreateProgramWithBinary"));
        CLCreateProgramWithBuiltInKernels = reinterpret_cast<_clCreateProgramWithBuiltInKernels>(dlsym(handle, "clCreateProgramWithBuiltInKernels"));
        CLRetainProgram = reinterpret_cast<_clRetainProgram>(dlsym(handle, "clRetainProgram"));
        CLReleaseProgram = reinterpret_cast<_clReleaseProgram>(dlsym(handle, "clReleaseProgram"));
        CLSetProgramReleaseCallback = reinterpret_cast<_clSetProgramReleaseCallback>(dlsym(handle, "clSetProgramReleaseCallback"));
        CLSetProgramSpecializationConstant = reinterpret_cast<_clSetProgramSpecializationConstant>(dlsym(handle, "clSetProgramSpecializationConstant"));
        CLBuildProgram = reinterpret_cast<_clBuildProgram>(dlsym(handle, "clBuildProgram"));
        CLCompileProgram = reinterpret_cast<_clCompileProgram>(dlsym(handle, "clCompileProgram"));
        CLLinkProgram = reinterpret_cast<_clLinkProgram>(dlsym(handle, "clLinkProgram"));
        CLUnloadPlatformCompiler = reinterpret_cast<_clUnloadPlatformCompiler>(dlsym(handle, "clUnloadPlatformCompiler"));
        CLGetProgramInfo = reinterpret_cast<_clGetProgramInfo>(dlsym(handle, "clGetProgramInfo"));
        CLGetProgramBuildInfo = reinterpret_cast<_clGetProgramBuildInfo>(dlsym(handle, "clGetProgramBuildInfo"));
        CLCreateKernel = reinterpret_cast<_clCreateKernel>(dlsym(handle, "clCreateKernel"));
        CLCreateKernelsInProgram = reinterpret_cast<_clCreateKernelsInProgram>(dlsym(handle, "clCreateKernelsInProgram"));
        CLRetainKernel = reinterpret_cast<_clRetainKernel>(dlsym(handle, "clRetainKernel"));
        CLReleaseKernel = reinterpret_cast<_clReleaseKernel>(dlsym(handle, "clReleaseKernel"));
        CLSetKernelArg = reinterpret_cast<_clSetKernelArg>(dlsym(handle, "clSetKernelArg"));
        CLSetKernelArgSVMPointer = reinterpret_cast<_clSetKernelArgSVMPointer>(dlsym(handle, "clSetKernelArgSVMPointer"));
        CLSetKernelExecInfo = reinterpret_cast<_clSetKernelExecInfo>(dlsym(handle, "clSetKernelExecInfo"));
        CLCloneKernel = reinterpret_cast<_clCloneKernel>(dlsym(handle, "clCloneKernel"));
        CLGetKernelInfo = reinterpret_cast<_clGetKernelInfo>(dlsym(handle, "clGetKernelInfo"));
        CLGetKernelWorkGroupInfo = reinterpret_cast<_clGetKernelWorkGroupInfo>(dlsym(handle, "clGetKernelWorkGroupInfo"));
        CLGetKernelSubGroupInfo = reinterpret_cast<_clGetKernelSubGroupInfo>(dlsym(handle, "clGetKernelSubGroupInfo"));
        CLGetKernelArgInfo = reinterpret_cast<_clGetKernelArgInfo>(dlsym(handle, "clGetKernelArgInfo"));
        CLEnqueueNDRangeKernel = reinterpret_cast<_clEnqueueNDRangeKernel>(dlsym(handle, "clEnqueueNDRangeKernel"));
        CLEnqueueNativeKernel = reinterpret_cast<_clEnqueueNativeKernel>(dlsym(handle, "clEnqueueNativeKernel"));
        env->GetJavaVM(&jvm);
    }
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Platform_getPlatforms(JNIEnv *env, jclass platform) {
    jclass Platform = env->FindClass("com/draico/asvappra/opencl/Platform");
    jobjectArray platforms;
    void **Result = GetPlatformsIDs(&numberPlatforms);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentPlatform = env->GetFieldID(Platform, "currentPlatform", "I");
        jmethodID getVersion = env->GetMethodID(Platform, "getVersion", "()Ljava/lang/String;");
        platforms = env->NewObjectArray(numberPlatforms, Platform, NULL);
        jboolean isVersionOpenCLAvailable = JNI_FALSE;
        for (jint position = 0; position < numberPlatforms; position++) {
            jobject platform = env->AllocObject(Platform);
            env->SetIntField(platform, currentPlatform, position);
            env->SetObjectArrayElement(platforms, position, platform);
            if (!isVersionOpenCLAvailable) {
                jstring versionOpenCL = (jstring)env->CallObjectMethod(platform, getVersion);
                setVersionOpenCL(env, versionOpenCL);
                isVersionOpenCLAvailable = JNI_TRUE;
            }
        }
    } else {
        showMessageError(env, (char*)Result[0]);
        platforms = env->NewObjectArray(0, Platform, NULL);
    }
    return platforms;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_getName(JNIEnv *env, jobject platform) {
    return *(jstring*)getPlatformInfo(env, platform, "getName");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_getProfile(JNIEnv *env, jobject platform) {
    return *(jstring*)getPlatformInfo(env, platform, "getProfile");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_getVendor(JNIEnv *env, jobject platform) {
    return *(jstring*)getPlatformInfo(env, platform, "getVendor");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_getVersion(JNIEnv *env, jobject platform) {
    return *(jstring*)getPlatformInfo(env, platform, "getVersion");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_getExtensions(JNIEnv *env, jobject platform) {
    return *(jstring*)getPlatformInfo(env, platform, "getExtensions");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Platform_getHostTimerResolution(JNIEnv *env, jobject platform) {
    return *(jlong*)getPlatformInfo(env, platform, "getHostTimerResolution");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Platform_toString(JNIEnv *env, jobject platform) {
    return platformToString(env, platform);
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Device_getDevices(JNIEnv *env, jclass device, jobject platform, jint deviceType) {
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    if (platform == NULL) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "You cannot obtain the devices using the getDevices method because you set the platform with null value");
        showMessageError(env, message);
        return NULL;
    }
    jint _deviceType = deviceType;
    if ((_deviceType & (1 << 0)) == 1 << 0) _deviceType -= 1 << 0;
    if ((_deviceType & (1 << 1)) == 1 << 1) _deviceType -= 1 << 1;
    if ((_deviceType & (1 << 2)) == 1 << 2) _deviceType -= 1 << 2;
    if ((_deviceType & (1 << 3)) == 1 << 3) _deviceType -= 1 << 3;
    if ((_deviceType & (1 << 4)) == 1 << 4) _deviceType -= 1 << 4;
    if ((_deviceType & 0xFFFFFFFF) == 0xFFFFFFFF) _deviceType -= 0xFFFFFFFF;
    if (_deviceType != 0) {
        char *message = (char*)malloc(sizeof(char) * 380);
        strcpy(message, "There is a problem when requesting the devices present on the platform that you provided, since ");
        strcat(message, "the value of the deviceType variable of the getDevices method has an incorrect value, you can ");
        strcat(message, "only use one of the following values:\nDevice.DEVICE_TYPE_DEFAULT\nDevice.DEVICE_TYPE_CPU\n");
        strcat(message, "Device.DEVICE_TYPE_GPU\nDevice.DEVICE_TYPE_ACCELERATOR\nDevice.DEVICE_TYPE_CUSTOM\n");
        strcat(message, "Device.DEVICE_TYPE_ALL");
        showMessageError(env, message);
        return NULL;
    } else {
        jint numDeviceType = 0;
        if ((deviceType & (1 << 0)) == 1 << 0) numDeviceType++;
        else if ((deviceType & (1 << 1)) == 1 << 1) numDeviceType++;
        else if ((deviceType & (1 << 2)) == 1 << 2) numDeviceType++;
        else if ((deviceType & (1 << 3)) == 1 << 3) numDeviceType++;
        else if ((deviceType & (1 << 4)) == 1 << 4) numDeviceType++;
        else if ((deviceType & 0xFFFFFFFF) == 0xFFFFFFFF) numDeviceType++;
        if (numDeviceType > 1) {
            char *message = (char*)malloc(sizeof(char) * 329);
            strcpy(message, "You cannot obtain the devices present on the platform provided, since the deviceType variable was ");
            strcat(message, "set more than one allowed value, you can only use one of the following values:\n");
            strcat(message, "Device.DEVICE_TYPE_DEFAULT\nDevice.DEVICE_TYPE_CPU\nDevice.DEVICE_TYPE_GPU\n");
            strcat(message, "Device.DEVICE_TYPE_ACCELERATOR\nDevice.DEVICE_TYPE_CUSTOM\nDevice.DEVICE_TYPE_ALL");
            showMessageError(env, message);
            return NULL;
        }
    }
    jclass Platform = env->GetObjectClass(platform);
    jfieldID currentPlatform = env->GetFieldID(Platform, "currentPlatform", "I");
    jint _currentPlatform = env->GetIntField(platform, currentPlatform);
    jobjectArray devices;
    void **Result = GetDeviceID(_currentPlatform, deviceType, &numberDevicesInCurrentPlatform);
    if (*(jint*) Result[1] == CL_SUCCESS) {
        jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
        jfieldID currentPlatform = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
        jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
        devices = env->NewObjectArray(numberDevicesInCurrentPlatform, Device, NULL);
        for (jint position = 0; position < numberDevicesInCurrentPlatform; position++) {
            jobject device = env->AllocObject(Device);
            env->SetIntField(device, currentDevice, position);
            env->SetObjectField(device, currentPlatform, platform);
            env->SetBooleanField(device, isDevicePartition, JNI_FALSE);
            env->SetObjectArrayElement(devices, position, device);
            cl_device_id deviceSelected = *listDevices[positionCurrentDevice];
            CLRetainDevice(deviceSelected);
            positionCurrentDevice++;
        }
    } else {
        devices = NULL;
        showMessageError(env, (char*)Result[0]);
    }
    return devices;
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Device_createPartition(JNIEnv *env, jobject device, jint partitionType, jint affinityType) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It is impossible that the device you are using can be partitioned, because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _partitionType = partitionType;
    if ((_partitionType & 0x1086) == 0x1086) _partitionType -= 0x1086;
    if ((_partitionType & 0x1087) == 0x1087) _partitionType -= 0x1087;
    if ((_partitionType & 0x1088) == 0x1088) _partitionType -= 0x1088;
    if (_partitionType != 0) {
        char *message = (char*)malloc(sizeof(char) * 279);
        strcpy(message, "The type of partition you are using to create a new partition of the current device is invalid, ");
        strcat(message, "you can only use the partition types that are inside the Device class, which are the following:");
        strcat(message, "\nDevice.PARTITION_EQUALLY\nDevice.PARTITION_BY_COUNTS\nDevice.PARTITION_BY_AFFINITY_DOMAIN");
        showMessageError(env, message);
        return NULL;
    } else {
        jint numPartitionType = 0;
        if ((partitionType & 0x1086) == 0x1086) numPartitionType++;
        if ((partitionType & 0x1087) == 0x1087) numPartitionType++;
        if ((partitionType & 0x1088) == 0x1088) numPartitionType++;
        if (numPartitionType > 1) {
            char *message = (char*)malloc(sizeof(char) * 227);
            strcpy(message, "You cannot create a device partition because you are using more than one partitionType value, ");
            strcat(message, "you can only use one of the following values:\nDevice.PARTITION_EQUALLY\n");
            strcat(message, "Device.PARTITION_BY_COUNTS\nDevice.PARTITION_BY_AFFINITY_DOMAIN");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (partitionType == 0x1088) {
        jint _affinityType = affinityType;
        if ((affinityType & (1 << 0)) == 1 << 0) _affinityType -= 1 << 0;
        if ((affinityType & (1 << 1)) == 1 << 1) _affinityType -= 1 << 1;
        if ((affinityType & (1 << 2)) == 1 << 2) _affinityType -= 1 << 2;
        if ((affinityType & (1 << 3)) == 1 << 3) _affinityType -= 1 << 3;
        if ((affinityType & (1 << 4)) == 1 << 4) _affinityType -= 1 << 4;
        if ((affinityType & (1 << 5)) == 1 << 5) _affinityType -= 1 << 5;
        if (_affinityType != 0) {
            char *message = (char*)malloc(sizeof(char) * 383);
            strcpy(message, "The affinityType value that you are using to create a partition of the device you are using is ");
            strcat(message, "invalid, the acceptable values are those within the Device class, which are the following:\n");
            strcat(message, "Device.AFFINITY_DOMAIN_NUMA\nDevice.AFFINITY_DOMAIN_L4_CACHE\nDevice.AFFINITY_DOMAIN_L3_CACHE\n");
            strcat(message, "Device.AFFINITY_DOMAIN_L2_CACHE\nDevice.AFFINITY_DOMAIN_L1_CACHE\n");
            strcat(message, "Device.AFFINITY_DOMAIN_NEXT_PARTITIONABLE");
            showMessageError(env, message);
            return NULL;
        }
        jint numAffinityType = 0;
        jboolean conditions[6];
        jint position;
        for (position = 0; position < 6; position++) conditions[position] = JNI_FALSE;
        for (position = 0; position < 6; position++) {
            if ((affinityType & (1 << 0)) == 1 << 0) numAffinityType++;
            else if ((affinityType & (1 << 1)) == 1 << 1 && !conditions[position]) {
                conditions[position] = JNI_TRUE;
                numAffinityType++;
            } else if ((affinityType & (1 << 2)) == 1 << 2 && !conditions[position]) {
                conditions[position] = JNI_TRUE;
                numAffinityType++;
            } else if ((affinityType & (1 << 3)) == 1 << 3 && !conditions[position]) {
                conditions[position] = JNI_TRUE;
                numAffinityType++;
            } else if ((affinityType & (1 << 4)) == 1 << 4 && !conditions[position]) {
                conditions[position] = JNI_TRUE;
                numAffinityType++;
            } else if ((affinityType & (1 << 5)) == 1 << 5 && !conditions[position]) {
                conditions[position] = JNI_TRUE;
                numAffinityType++;
            }
        }
        if (numAffinityType > 1) {
            char *message = (char*)malloc(sizeof(char) * 340);
            strcpy(message,"You can not create a partition the device because you're using more than one affinityType value, you can ");
            strcat(message, "only use one of the following values:\nDevice.AFFINITY_DOMAIN_NUMA\nDevice.AFFINITY_DOMAIN_L4_CACHE\n");
            strcat(message, "Device.AFFINITY_DOMAIN_L3_CACHE\nDevice.AFFINITY_DOMAIN_L2_CACHE\nDevice.AFFINITY_DOMAIN_L1_CACHE\n");
            strcat(message, "Device.AFFINITY_DOMAIN_NEXT_PARTITIONABLE");
            showMessageError(env, message);
            return NULL;
        }
    }
    jmethodID getMaxComputeUnits = env->GetMethodID(Device, "getMaxComputeUnits", "()I");
    jmethodID getPartitionMaxSubDevices = env->GetMethodID(Device, "getPartitionMaxSubDevices", "()I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID currentPlatform = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jobject platform = env->GetObjectField(device, currentPlatform);
    jint maxComputeUnits = env->CallIntMethod(device, getMaxComputeUnits);
    jint maxSubDevices = env->CallIntMethod(device, getPartitionMaxSubDevices);
    jboolean _isDevicePartition = env->GetBooleanField(device, isDevicePartition);
    cl_device_id deviceSelected;
    if (!_isDevicePartition) deviceSelected = *listDevices[_currentDevice];
    else {
        jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
        jint _currentSubDevice = env->GetIntField(device, currentSubDevice);
        deviceSelected = listDevices[_currentDevice][_currentSubDevice];
    }
    cl_uint numDevices;
    jobjectArray devicePartitions;
    void **Result = GetCreateSubDevices(deviceSelected, partitionType, affinityType, maxSubDevices, maxComputeUnits, &numDevices);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        devicePartitions = env->NewObjectArray(numDevices, Device, NULL);
        for (jint position = 0; position < numDevices; position++) {
            jobject devicePartition = env->AllocObject(Device);
            env->SetIntField(devicePartition, currentDevice, _currentDevice);
            env->SetIntField(devicePartition, currentSubDevice, position);
            env->SetBooleanField(devicePartition, isDevicePartition, JNI_TRUE);
            env->SetObjectField(devicePartition, currentPlatform, platform);
            env->SetObjectArrayElement(devicePartitions, position, devicePartition);
            deviceSelected = listDevices[positionCurrentDevice][position];
            CLRetainDevice(deviceSelected);
        }
        positionCurrentDevice++;
    } else {
        devicePartitions = NULL;
        showMessageError(env, (char*)Result[0]);
    }
    return devicePartitions;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getType(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentField = env->GetIntField(device, currentDevice);
    if (_currentField == -1) {
        char *message = (char*)malloc(sizeof(char) * 85);
        strcpy(message, "It's impossible to use the getType method because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getType");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getVendorId(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 89);
        strcpy(message, "It's impossible to use the getVendorId method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getVendorId");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxComputeUnits(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It's impossible to use the getMaxComputeUnits method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxComputeUnits");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxWorkItemDimensions(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible to use the getMaxWorkItemDimensions method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxWorkItemDimensions");
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Device_getMaxWorkItemSizes(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It's impossible to use the getMaxWorkItemSize method because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jintArray*)getDataDeviceSelected(env, device, "getMaxWorkItemSizes");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxWorkGroupSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 97);
        strcpy(message, "It's impossible to use the getMaxWorkGroupSize method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxWorkGroupSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthChar(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthChar method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthChar");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthShort(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 106);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthShort method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthShort");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthInt(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthInt method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthInt");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthLong(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthLong method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthLong");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthFloat(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 106);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthFloat method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthFloat");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthDouble(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthDouble method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthDouble");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredVectorWidthHalf(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "It's impossible to use the getPreferredVectorWidthHalf method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredVectorWidthHalf");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthChar(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible to use the getNativeVectorWidthChar method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthChar");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthShort(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 103);
        strcpy(message, "It's impossible to use the getNativeVectorWidthShort method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthShort");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthInt(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 101);
        strcpy(message, "It's impossible to use the getNativeVectorWidthInt method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthInt");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthLong(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible to use the getNativeVectorWidthLong method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthLong");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthFloat(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 103);
        strcpy(message, "It's impossible to use the getNativeVectorWidthFloat method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthFloat");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthDouble(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "It's impossible to use the getNativeVectorWidthDouble method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthDouble");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getNativeVectorWidthHalf(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible to use the getNativeVectorWidthHalf method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getNativeVectorWidthHalf");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxClockFrequency(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 103);
        strcpy(message, "It's impossible to get the maximum frequency of the device you are using, because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxClockFrequency");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getAddressBits(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 78);
        strcpy(message, "It's impossible to use the getAddressBits method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getAddressBits");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Device_getMaxMemAllocSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to use the getMaxMemAllocSize method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jlong*)getDataDeviceSelected(env, device, "getMaxMemAllocSize");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getImageSupport(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "It's impossible to use the getImageSupport method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getImageSupport");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxReadImageArgs(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "It's impossible to use the getMaxReadImageArgs method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxReadImageArgs");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxWriteImageArgs(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 84);
        strcpy(message, "It's impossible to use the getMaxWriteImageArgs method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxWriteImageArgs");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxReadWriteImageArgs(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 88);
        strcpy(message, "It's impossible to use the getMaxReadWriteImageArgs method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxReadWriteImageArgs");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getILVersion(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 76);
        strcpy(message, "It's impossible to use the getILVersion method because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getILVersion");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImage2DMaxWidth(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to use the getImage2DMaxWidth method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImage2DMaxWidth");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImage2DMaxHeight(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "It's impossible to use the getImage2DMaxHeight method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImage2DMaxHeight");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImage3DMaxWidth(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to use the getImage3DMaxWidth method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImage3DMaxWidth");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImage3DMaxHeight(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "It's impossible to use the getImage3DMaxHeight method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImage3DMaxHeight");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImage3DMaxDepth(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to use the getImage3DMaxDepth method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImage3DMaxDepth");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImageMaxBufferSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 85);
        strcpy(message, "It's impossible to use the getImageMaxBufferSize method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImageMaxBufferSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImageMaxArraySize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 84);
        strcpy(message, "It's impossible to use the getImageMaxArraySize method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImageMaxArraySize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxSamplers(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 78);
        strcpy(message, "It's impossible to use the getMaxSamplers method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxSamplers");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImagePitchAlignment(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "It's impossible to use the getImagePitchAlignment method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImagePitchAlignment");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getImageBaseAddressAlignment(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "It's impossible to use the getImageBaseAddressAlignment method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getImageBaseAddressAlignment");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxPipeArgs(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 78);
        strcpy(message, "It's impossible to use the getMaxPipeArgs method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxPipeArgs");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPipeMaxActiveReservations(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "It's impossible to use the getPipeMaxActiveReservations method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPipeMaxActiveReservations");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPipeMaxPacketSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "It's impossible to obtain the maximum packet size of the pipe of the device you are using, because the ");
        strcat(message, "device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPipeMaxPacketSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxParameterSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "It's impossible to obtain the maximum size of the parameters that the device you are using can have, ");
        strcat(message, "because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxParameterSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMemBaseAddressAlign(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "It's impossible to use the getMemBaseAddressAlign method because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMemBaseAddressAlign");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getSingleFPConfig(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "It's impossible to use the getSingleFPConfig method because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getSingleFPConfig");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getDoubleFPConfig(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "It's impossible to use the getDoubleFPConfig method because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getDoubleFPConfig");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getGlobalMemCacheType(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 129);
        strcpy(message, "It's impossible to determine the type of global cache memory available to the device, because the device ");
        strcat(message, "you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getGlobalMemCacheType");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getGlobalMemCachelineSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "It's impossible to get the line size of the global cache memory of the device you are using, because the ");
        strcat(message, "device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getGlobalMemCachelineSize");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Device_getGlobalMemCacheSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "It's impossible to get the size of the global cache memory of the device you are using, because the ");
        strcat(message, "device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jlong*)getDataDeviceSelected(env, device, "getGlobalMemCacheSize");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Device_getGlobalMemSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It's impossible to get the size of the global memory because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jlong*)getDataDeviceSelected(env, device, "getGlobalMemSize");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Device_getMaxConstantBufferSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 88);
        strcpy(message, "It's impossible to use the getMaxConstantBufferSize method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jlong*)getDataDeviceSelected(env, device, "getMaxConstantBufferSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxConstantArgs(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to use the getMaxConstantArgs method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxConstantArgs");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxGlobalVariableSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 126);
        strcpy(message, "It's impossible to obtain the maximum size for the global variables of the device you are using, because ");
        strcat(message, "the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 144);
        strcpy(message, "You cannot use the getMaxGlobalVariableSize method because the version of OpenCL that your android device ");
        strcat(message, "has installed is less than version 2.0");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxGlobalVariableSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getGlobalVariablePreferredTotalSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 113);
        strcpy(message, "It's impossible to use the getGlobalVariablePreferredTotalSize method because the device you are using ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getGlobalVariablePreferredTotalSize");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getLocalMemType(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "It's impossible to get the type of local memory of the device you are using because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring *) getDataDeviceSelected(env, device, "getLocalMemType");
}
JNICALL jlong Java_com_draico_asvappra_opencl_Device_getLocalMemSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "It's impossible to get the size of the local memory because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jlong*)getDataDeviceSelected(env, device, "getLocalMemSize");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getErrorCorrectionSupport(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 89);
        strcpy(message, "It's impossible to use the getErrorCorrectionSupport method because the device is invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getErrorCorrectionSupport");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getProfilingTimerResolution(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char *) malloc(sizeof(char) * 91);
        strcpy(message, "It's impossible to use the getProfilingTimerResolution method because the device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getProfilingTimerResolution");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getEndianLittle(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char *) malloc(sizeof(char) * 79);
        strcpy(message, "It's impossible to use the getEndianLittle method because the device is invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getEndianLittle");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getAvailable(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "It's impossible to check if the device is available because this device is invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getAvailable");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getCompilerAvailable(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 113);
        strcpy(message, "It's impossible to check if the compiler is available on the device you are using, because this device is ");
        strcat(message, "invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getCompilerAvailable");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getLinkerAvailable(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 111);
        strcpy(message, "It's impossible to check if the linker is available on the device you are using, because this device is ");
        strcat(message, "invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getLinkerAvailable");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getExecutionCapabilities(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It's impossible for you to use the getExecutionCapabilities method because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getExecutionCapabilities");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getQueueOnHostProperties(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "It's impossible for you to use the getQueueOnHostProperties method because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getQueueOnHostProperties");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getQueueOnDeviceProperties(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "It's impossible that you can use the getQueueOnDeviceProperties method because the device you are using ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getQueueOnDeviceProperties");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getQueueOnDevicePreferredSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 108);
        strcpy(message, "It's impossible to get the recommended size for the CommandQueue because the device you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getQueueOnDevicePreferredSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getQueueOnDeviceMaxSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 108);
        strcpy(message, "It's impossible to get the maximum size of the CommandQueue of the device you are using because it's invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getQueueOnDeviceMaxSize");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxOnDeviceQueues(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 119);
        strcpy(message, "It's impossible to obtain the maximum number of CommandQueue that the device can handle because the device ");
        strcat(message, "it's invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxOnDeviceQueues");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxOnDeviceEvents(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "It's impossible to get the maximum number of events on the device you are using because it's invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxOnDeviceEvents");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getBuildInKernels(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible to use the getBuildInKernels method with the device you are using because it's invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getBuildInKernels");
}
JNICALL jobject Java_com_draico_asvappra_opencl_Device_getPlatform(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The device is invalid");
        showMessageError(env, message);
    }
    jfieldID currentPlatform = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
    return env->GetObjectField(device, currentPlatform);
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getName(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 89);
        strcpy(message, "It's impossible to get the name of the device you are using because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getName");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getVendor(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "It's impossible that you can get the name of the vendor of the device you are using, because the device ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getVendor");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getDriverVersion(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 99);
        strcpy(message, "It's impossible to get the driver version of the device you are using because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getDriverVersion");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getProfile(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "It's impossible to get the profile of the device you are using because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getProfile");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getVersion(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "It's impossible to get the version of the device you are using because the device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getVersion");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getOpenCL_1C_1Version(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 108);
        strcpy(message, "It's impossible that you can use the getOpenCL_C_Version method, because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getOpenCL_C_1Version");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getExtensions(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "It's impossible that you can use the getExtensions method, because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getExtensions");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPrintfBufferSize(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 108);
        strcpy(message, "It's impossible that you can use the getPrintfBufferSize method, because the device you are using ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPrintfBufferSize");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getPreferredInteropUserSync(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 116);
        strcpy(message, "It's impossible that you can use the getPreferredInteropUserSync method, because the device you are ");
        strcat(message, "using is invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getPreferredInteropUserSync");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPartitionMaxSubDevices(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "It's impossible to get the maximum number of partitions of the device you are using, because the ");
        strcat(message, "device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPartitionMaxSubDevices");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getPartitionProperties(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "It's impossible that you can get the partition properties of the device you are using, because the device ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getPartitionProperties");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getPartitionAffinityDomain(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "It's impossible to use the getPartitionAffinityDomain method with the current device, because the ");
        strcat(message, "device is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getPartitionAffinityDomain");
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getPartitionType(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 103);
        strcpy(message, "It's impossible to obtain the partition type of the device, because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getPartitionType");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getReferenceCount(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 99);
        strcpy(message, "It's impossible to obtain the device reference counter, because the device you are using is invalid");
        showMessageError(env, message);
        return -1;
    }
    return _currentDevice;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_getSVMCapabilities(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 106);
        strcpy(message, "It's impossible that you can use the getSVMCapabilities method because the device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return *(jstring*)getDataDeviceSelected(env, device, "getSVMCapabilities");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredPlatformAtomicAlignment(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 123);
        strcpy(message, "It's impossible that you can use the getPreferredPlatformAtomicAlignment method because the device ");
        strcat(message, "you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredPlatformAtomicAlignment");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredGlobalAtomicAlignment(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "It's impossible that you can use the getPreferredGlobalAtomicAlignment method because the device you ");
        strcat(message, "are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredGlobalAtomicAlignment");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getPreferredLocalAtomicAlignment(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "It's impossible that you can use the getPreferredLocalAtomicAlignment method because the device you are ");
        strcat(message, "using is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getPreferredLocalAtomicAlignment");
}
JNICALL jint Java_com_draico_asvappra_opencl_Device_getMaxNumSubGroups(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "It's impossible to obtain the maximum number of subgroups in this device, because this device is invalid");
        showMessageError(env, message);
        return 0;
    }
    return *(jint*)getDataDeviceSelected(env, device, "getMaxNumSubGroups");
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Device_getSubGroupIndependentForwardProgress(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 101);
        strcpy(message, "It's impossible to use the getSubGroupIndependentForwardProgress method because the device is invalid");
        showMessageError(env, message);
        return false;
    }
    return *(jboolean*)getDataDeviceSelected(env, device, "getSubGroupIndependentForwardProgress");
}
JNICALL void Java_com_draico_asvappra_opencl_Device_releaseDevice(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 68);
        strcpy(message, "It's impossible to release the device, because the device is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice = env->GetIntField(device, currentSubDevice);
    jboolean _isDevicePartition = env->GetBooleanField(device, isDevicePartition);
    void **Result = GetReleaseDevice(_currentDevice, _isDevicePartition, _currentSubDevice);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(device, currentDevice, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL jstring Java_com_draico_asvappra_opencl_Device_toString(JNIEnv *env, jobject device) {
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 35);
        strcpy(message, "The device you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return deviceToString(env, device);
}
JNICALL jobject Java_com_draico_asvappra_opencl_DeviceTimer_getDeviceTimer(JNIEnv *env, jclass deviceTimer, jobject device) {
    jclass DeviceTimer = env->FindClass("com/draico/asvappra/opencl/DeviceTimer");
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 147);
        strcpy(message, "You are trying to create a DeviceTimer object with a Device object with null value, use a valid device ");
        strcat(message, "and try again to create a DeviceTimer object");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 84);
        strcpy(message, "The DeviceTimer object cannot be obtained because the device you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID _device = env->GetFieldID(DeviceTimer, "device", "Lcom/draico/asvappra/opencl/Device;");
    jobject _deviceTimer = env->AllocObject(DeviceTimer);
    env->SetObjectField(_deviceTimer, _device, device);
    return _deviceTimer;
}
JNICALL jlongArray Java_com_draico_asvappra_opencl_DeviceTimer_getDeviceAndHostTimestamp(JNIEnv *env, jobject deviceTimer) {
    jclass DeviceTimer = env->GetObjectClass(deviceTimer);
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID device = env->GetFieldID(DeviceTimer, "device", "Lcom/draico/asvappra/opencl/Device;");
    jobject _device = env->GetObjectField(deviceTimer, device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(_device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "The device and host timestamp of the current device cannot be obtained because the DeviceTimer type object ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL >= 2.1) {
        jlongArray timestamp = env->NewLongArray(2);
        jclass Platform = env->FindClass("com/draico/asvappra/opencl/Platform");
        jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
        jfieldID currentPlatform = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
        jmethodID getHostTimerResolution = env->GetMethodID(Platform, "getHostTimerResolution", "()J");
        jboolean _isDevicePartition = env->GetBooleanField(_device, isDevicePartition);
        jobject platform = env->GetObjectField(_device, currentPlatform);
        cl_ulong HostTimerResolution = env->CallLongMethod(platform, getHostTimerResolution);
        cl_ulong DeviceTimeStamp;
        cl_device_id deviceSelected;
        if (_isDevicePartition) {
            jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
            jint _currentSubDevice = env->GetIntField(_device, currentSubDevice);
            deviceSelected = listDevices[_currentDevice][_currentSubDevice];
        } else deviceSelected = *listDevices[_currentDevice];
        void **Result = GetDeviceAndHostTimer(deviceSelected, &DeviceTimeStamp, &HostTimerResolution);
        if (*(jint*)Result == CL_SUCCESS) {
            const jlong dataTimestamp[] = { (jlong)DeviceTimeStamp, (jlong)HostTimerResolution };
            env->SetLongArrayRegion(timestamp, 0, 2, dataTimestamp);
            return timestamp;
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    } else {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "You cannot use the getDeviceAndHostTimeStamp method, because the android device you are using does not have ");
        strcat(message, "an opencl version greater than or equal to version 2.1");
        showMessageError(env, message);
        return NULL;
    }
}
JNICALL jlong Java_com_draico_asvappra_opencl_DeviceTimer_getHostTimestamp(JNIEnv *env, jobject deviceTimer) {
    jclass DeviceTimer = env->GetObjectClass(deviceTimer);
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID device = env->GetFieldID(DeviceTimer, "device", "Lcom/draico/asvappra/opencl/Device;");
    jobject _device = env->GetObjectField(deviceTimer, device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(_device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 106);
        strcpy(message, "The host timestamp of the current device cannot be obtained because the DeviceTimer type object is invalid");
        showMessageError(env, message);
        return 0;
    }
    if (VersionOpenCL >= 2.1) {
        cl_ulong hostTimerResolution;
        jclass Platform = env->FindClass("com/draico/asvappra/opencl/Platform");
        jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
        jfieldID currentPlatform = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
        jobject platform = env->GetObjectField(_device, currentPlatform);
        jmethodID getHostTimerResolution = env->GetMethodID(Platform, "getHostTimerResolution", "()J");
        hostTimerResolution = env->CallLongMethod(platform, getHostTimerResolution);
        jboolean _isDevicePartition = env->GetBooleanField(_device, isDevicePartition);
        cl_device_id deviceId;
        if (_isDevicePartition) {
            jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
            jint _currentSubDevice = env->GetIntField(_device, currentSubDevice);
            deviceId = listDevices[_currentDevice][_currentSubDevice];
        } else deviceId = *listDevices[_currentDevice];
        void **Result = GetHostTimer(deviceId, &hostTimerResolution);
        if (*(jint*)Result[1] != CL_SUCCESS) {
            hostTimerResolution = 0;
            showMessageError(env, (char*)Result[0]);
            return 0;
        } else return hostTimerResolution;
    } else {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot use the getHostTimestamp method because the android device you are using does not have a version ");
        strcat(message, "greater than or equal to opencl 2.1");
        showMessageError(env, message);
        return 0;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_DeviceTimer_toString(JNIEnv *env, jobject deviceTimer) {
    jclass DeviceTimer = env->GetObjectClass(deviceTimer);
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID device = env->GetFieldID(DeviceTimer, "device", "Lcom/draico/asvappra/opencl/Device;");
    jobject _device = env->GetObjectField(deviceTimer, device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(_device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "You cannot use the toString method of the DeviceTimer object you are using because the current device ");
        strcat(message, "using the DeviceTimer object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return deviceTimerToString(env, deviceTimer);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Context_createContext(JNIEnv *env, jclass context, jobjectArray devices,
                                             jobject callbackContext) {
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    if (devices == NULL) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "The context cannot be created because the device array you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint sizeListDevices = env->GetArrayLength(devices);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(devices, position);
        jint _currentDevice = env->GetIntField(device, currentDevice);
        if (_currentDevice == -1) {
            char *message = (char*)malloc(sizeof(char) * 109);
            strcpy(message, "The context cannot be created because at least one of the devices in the device array you provided ");
            strcat(message, "is invalid");
            showMessageError(env, message);
            return NULL;
        }
    }
    jclass Platform = env->FindClass("com/draico/asvappra/opencl/Platform");
    jfieldID currentPlatformDevice = env->GetFieldID(Device, "currentPlatform", "Lcom/draico/asvappra/opencl/Platform;");
    for (jint position1 = 0; position1 < (sizeListDevices - 1); position1++) {
        jobject device1 = env->GetObjectArrayElement(devices, position1);
        for (jint position2 = position1 + 1; position2 < sizeListDevices; position2++) {
            jobject device2 = env->GetObjectArrayElement(devices, position2);
            jint currentDevice1 = env->GetIntField(device1, currentDevice);
            jint currentDevice2 = env->GetIntField(device2, currentDevice);
            if (currentDevice1 == -1 || currentDevice2 == -1) {
                char *message = (char*)malloc(sizeof(char) * 121);
                strcpy(message, "The context cannot be created because in the list of devices you provided, because at least one ");
                strcat(message, "of the devices is invalid");
                showMessageError(env, message);
                return NULL;
            }
            if (env->IsSameObject(device1, device2)) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "The context cannot be created because at least 2 of the devices in the device array you provided ");
                strcat(message, "are the same device");
                showMessageError(env, message);
                return NULL;
            }
            jobject platform1 = env->GetObjectField(device1, currentPlatformDevice);
            jobject platform2 = env->GetObjectField(device2, currentPlatformDevice);
            if (!env->IsSameObject(platform1, platform2)) {
                char *message = (char*)malloc(sizeof(char) * 156);
                strcpy(message, "The context cannot be created because at least 1 device that does not belong to the same platform ");
                strcat(message, "of the other devices in the device array that you provided");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    jfieldID currentPlatform = env->GetFieldID(Platform, "currentPlatform", "I");
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    cl_int *listCurrentDevice = (jint*)malloc(sizeof(cl_int) * sizeListDevices);
    cl_int *listSubDevices = (jint*)malloc(sizeof(cl_int) * sizeListDevices);
    cl_bool *listIsSubDevice = (cl_bool*)malloc(sizeof(cl_bool) * sizeListDevices);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(devices, position);
        listCurrentDevice[position] = env->GetIntField(device, currentDevice);
        listSubDevices[position] = env->GetIntField(device, currentSubDevice);
        listIsSubDevice[position] = env->GetBooleanField(device, isDevicePartition);
    }
    jobject device = env->GetObjectArrayElement(devices, 0);
    jobject platform = env->GetObjectField(device, currentPlatformDevice);
    jint _currentPlatform = env->GetIntField(platform, currentPlatform);
    void **Result;
    Result = GetCreateContext(env, listCurrentDevice, listSubDevices, _currentPlatform, callbackContext, listIsSubDevice, sizeListDevices);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jobject _contextObject = env->AllocObject(Context);
        env->SetIntField(_contextObject, currentContext, positionCurrentContext);
        env->SetObjectField(_contextObject, devicesContext, devices);
        positionCurrentContext++;
        return _contextObject;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Context_createContextFromType(JNIEnv *env, jclass context, jobject platform,
                                                     jobject callbackContext, jlong deviceType) {
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    if (platform == NULL) {
        char *message = (char*)malloc(sizeof(char) * 146);
        strcpy(message, "There was a problem with the createContextFromType method because you have set the platform ");
        strcat(message, "argument to null, place a valid platform and try again");
        showMessageError(env, message);
        return NULL;
    }
    jlong data = deviceType;
    if ((data & (1 << 0)) == 1 << 0) data -= 1 << 0;
    if ((data & (1 << 1)) == 1 << 1) data -= 1 << 1;
    if ((data & (1 << 2)) == 1 << 2) data -= 1 << 2;
    if ((data & (1 << 3)) == 1 << 3) data -= 1 << 3;
    if ((data & (1 << 4)) == 1 << 4) data -= 1 << 4;
    if ((data & 0xFFFFFFFF) == 0xFFFFFFFF) data -= 0xFFFFFFFF;
    if (data != 0) {
        char *message = (char*)malloc(sizeof(char) * 396);
        strcpy(message, "The context cannot be created with the createContextFromType method because you are not using an allowable ");
        strcat(message, "value for the deviceType variable, you can only use the following values:\nDevice.DEVICE_TYPE_DEFAULT\n");
        strcat(message, "Device.DEVICE_TYPE_CPU\nDevice.DEVICE_TYPE_GPU\nDevice.DEVICE_TYPE_ACCELERATOR\nDevice.DEVICE_TYPE_ALL\n");
        strcat(message, "Select only one of the above values and try again using the createContextFromType method");
        showMessageError(env, message);
        return NULL;
    }
    jint numDeviceType = 0;
    if ((deviceType & (1 << 0)) == 1 << 0) numDeviceType++;
    else if ((deviceType & (1 << 1)) == 1 << 1) numDeviceType++;
    else if ((deviceType & (1 << 2)) == 1 << 2) numDeviceType++;
    else if ((deviceType & (1 << 3)) == 1 << 3) numDeviceType++;
    else if ((deviceType & (1 << 4)) == 1 << 4) numDeviceType++;
    else if ((deviceType & 0xFFFFFFFF) == 0xFFFFFFFF) numDeviceType++;
    if (numDeviceType > 1) {
        char *message = (char*)malloc(sizeof(char) * 401);
        strcpy(message, "The context cannot be created with the createContextFromType method because you are using more than one ");
        strcat(message, "allowed value for the deviceType variable, you can only use the following values:\n");
        strcat(message, "Device.DEVICE_TYPE_DEFAULT\nDevice.DEVICE_TYPE_CPU\nDevice.DEVICE_TYPE_GPU\nDevice.DEVICE_TYPE_ACCELERATOR\n");
        strcat(message, "Device.DEVICE_TYPE_ALL\nSelect only one of the above values and try again using the createContextFromType ");
        strcat(message, "method");
        showMessageError(env, message);
        return NULL;
    }
    jclass Platform = env->GetObjectClass(platform);
    jfieldID currentPlatform = env->GetFieldID(Platform, "currentPlatform", "I");
    jint _currentPlatform = env->GetIntField(platform, currentPlatform);
    void **Result = GetCreateContextFromType(env, _currentPlatform, callbackContext, deviceType);
    jint state = *(jint*)Result[1];
    if (state == CL_SUCCESS) {
        jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
        jobject _contextObject = env->AllocObject(Context);
        jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jmethodID getDevices = env->GetStaticMethodID(Device, "getDevices", "(Lcom/draico/asvappra/opencl/Platform;I)[Lcom/draico/asvappra/opencl/Device;");
        jobjectArray devices = (jobjectArray) env->CallStaticObjectMethod(Device, getDevices, platform, (jint)deviceType);
        env->SetObjectField(_contextObject, devicesContext, devices);
        env->SetIntField(_contextObject, currentContext, positionCurrentContext);
        positionCurrentContext++;
        return _contextObject;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Context_getReferenceCount(JNIEnv *env, jobject context) {
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 30);
        strcpy(message, "The current context is invalid");
        showMessageError(env, message);
        return -1;
    }
    return _currentContext;
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Context_getDevices(JNIEnv *env, jobject context) {
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "The devices associated with this context cannot be obtained, because this context is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(context, devices);
    return _devices;
}
JNICALL void Java_com_draico_asvappra_opencl_Context_releaseContext(JNIEnv *env, jobject context) {
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 48);
        strcpy(message, "Unable to release the current context is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseContext(_currentContext);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(context, currentContext, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL jstring Java_com_draico_asvappra_opencl_Context_toString(JNIEnv *env, jobject context) {
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 48);
        strcpy(message, "Unable to release the current context is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return contextToString(env, context);
}
JNICALL jobject Java_com_draico_asvappra_opencl_CommandQueue_getCommandQueueWithProperties(JNIEnv *env, jclass commandQueue,
                                                                        jobject context, jobject device,
                                                                        jobject hashMap) {
    jclass CommandQueue = env->FindClass("com/draico/asvappra/opencl/CommandQueue");
    if (context == NULL || device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 333);
        strcpy(message, "There is a problem with the getCommandQueueWithProperties method because you have entered with a null value ");
        strcat(message, "to the context, or to the device, or to more than one of the objects mentioned above they ");
        strcat(message, "are set to a null value, so you must place a valid context, device and hashMap and retry using the ");
        strcat(message, "getCommandQueueWithProperties method");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "You cannot create the CommandQueue object because the version of OpenCL that is installed on your android ");
        strcat(message, "device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentContext == -1 || _currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 132);
        strcpy(message, "Cannot get CommandQueue object related to the context and device you are providing, because the context ");
        strcat(message, "and/or device may be invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass HashMap = env->FindClass("java/util/HashMap");
    jclass Long = env->FindClass("java/lang/Long");
    jclass Set = env->FindClass("java/util/Set");
    jmethodID sizeHashMap = env->GetMethodID(HashMap, "size", "()I");
    jmethodID getHashMap = env->GetMethodID(HashMap, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jmethodID getQueueOnDevicePreferredSize = env->GetMethodID(Device, "getQueueOnDevicePreferredSize", "()I");
    jmethodID contains = env->GetMethodID(Set, "contains", "(Ljava/lang/Object;)Z");
    jmethodID keySet = env->GetMethodID(HashMap, "keySet", "()Ljava/util/Set;");
    cl_command_queue_properties *properties = NULL;
    jfieldID QUEUE_PROPERTIES = env->GetStaticFieldID(CommandQueue, "QUEUE_PROPERTIES", "Ljava/lang/String;");
    jstring _QUEUE_PROPERTIES = (jstring) env->GetStaticObjectField(CommandQueue, QUEUE_PROPERTIES);
    jfieldID QUEUE_SIZE = env->GetStaticFieldID(CommandQueue, "QUEUE_SIZE", "Ljava/lang/String;");
    jstring _QUEUE_SIZE = (jstring) env->GetStaticObjectField(CommandQueue, QUEUE_SIZE);
    jlong queueProperties = 0;
    jlong sizeCommandQueue = env->CallIntMethod(device, getQueueOnDevicePreferredSize);
    jsize _sizeHashMap;
    if (hashMap != NULL) {
        _sizeHashMap = env->CallIntMethod(hashMap, sizeHashMap);
        if (_sizeHashMap > 0) {
            jobject _keySet = env->CallObjectMethod(hashMap, keySet);
            jboolean isKeyQueuePropertiesAvailable = env->CallBooleanMethod(_keySet, contains, _QUEUE_PROPERTIES);
            jboolean isKeyQueueSizeAvailable = env->CallBooleanMethod(_keySet, contains, _QUEUE_SIZE);
            if (isKeyQueuePropertiesAvailable) {
                jobject queue_properties = env->CallObjectMethod(hashMap, getHashMap, _QUEUE_PROPERTIES);
                queueProperties = env->CallLongMethod(queue_properties, longValue);
                if (_sizeHashMap == 1) {
                    if (VersionOpenCL >= 2.0) {
                        jlong value = queueProperties;
                        if (value == 0) {
                            char *message = (char*)malloc(sizeof(char) * 208);
                            strcpy(message, "You can only enter the following values to the hashmap together with the ");
                            strcat(message, "CommandQueue.QUEUE_PROPERTIES key:\nCommandQueue.QUEUE_ON_DEVICE\n");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT\nCommandQueue.QUEUE_PROFILING_ENABLE\n");
                            showMessageError(env, message);
                            return NULL;
                        }
                        if ((value & (1 << 0)) == 1 << 0) value -= 1 << 0;
                        if ((value & (1 << 1)) == 1 << 1) value -= 1 << 1;
                        if ((value & (1 << 2)) == 1 << 2) value -= 1 << 2;
                        if ((value & (1 << 3)) == 1 << 3) value -= 1 << 3;
                        if (value != 0) {
                            char *message = (char*)malloc(sizeof(char) * 208);
                            strcpy(message, "You can only enter the following values to the hashmap together with the ");
                            strcat(message, "CommandQueue.QUEUE_PROPERTIES key:\nCommandQueue.QUEUE_ON_DEVICE\n");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT\nCommandQueue.QUEUE_PROFILING_ENABLE\n");
                            showMessageError(env, message);
                            return NULL;
                        }
                        if (((queueProperties & (1 << 2) == 1 << 2 && (queueProperties & (1 << 3)) == 1 << 3)) ||
                            (queueProperties & (1 << 2)) == 1 << 2) {
                            if (((queueProperties & (1 << 0)) == 1 << 0 && (queueProperties & (1 << 1)) == 1 << 1) ||
                                (queueProperties & (1 << 0)) == 1 << 0) {
                                properties = (cl_command_queue_properties*)malloc(sizeof(cl_command_queue_properties) * 5);
                                properties[0] = CL_QUEUE_PROPERTIES;
                                properties[1] = (cl_command_queue_properties) queueProperties;
                                properties[2] = CL_QUEUE_SIZE;
                                properties[3] = (cl_command_queue_properties) sizeCommandQueue;
                                properties[4] = 0;
                            } else {
                                char *message = (char*)malloc(sizeof(char) * 433);
                                strcpy(message, "There is a problem when creating the CommandQueue type object, because you are ");
                                strcat(message, "using the CommandQueue.QUEUE_ON_DEVICE and/or CommandQueue.QUEUE_ON_DEVICE_DEFAULT ");
                                strcat(message, "values, but you are not using the CommandQueue.QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE ");
                                strcat(message, "value\nAnother possible problem could be caused because you are using a different ");
                                strcat(message, "value to CommandQueue.QUEUE_PROFILING_ENABLE, this last value needs to be combined ");
                                strcat(message, "with the previous values");
                                showMessageError(env, message);
                                return NULL;
                            }
                        } else {
                            char *message = (char*)malloc(sizeof(char) * 340);
                            strcpy(message, "There is a problem when creating the CommandQueue type object, because you are not ");
                            strcat(message, "using the CommandQueue.QUEUE_ON_DEVICE value, if you intend to use the ");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT value, you must necessarily use the ");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE value and combine it with the ");
                            strcat(message, "CommandQueue.QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE value");
                            showMessageError(env, message);
                            return NULL;
                        }
                    } else {
                        char *message = (char*)malloc(sizeof(char) * 470);
                        strcpy(message, "There was a problem trying to create a CommandQueue object using the values ");
                        strcat(message, "CommandQueue.QUEUE_ON_DEVICE and/or CommandQueue.QUEUE_ON_DEVICE_DEFAULT, because the ");
                        strcat(message, "opencl version available to your android device is lower than version 2.0, so therefore ");
                        strcat(message, "you will not be able to use the hashmap To try to create the CommandQueue object, it is ");
                        strcat(message, "best to adjust the hashmap with a null value and thus the opencl system itself will ");
                        strcat(message, "create a CommandQueue object with default values");
                        showMessageError(env, message);
                        return NULL;
                    }
                } else if (_sizeHashMap == 2) {
                    jsize sizeQueue;
                    if (isKeyQueueSizeAvailable) {
                        jobject queue_size = env->CallObjectMethod(hashMap, getHashMap, _QUEUE_SIZE);
                        sizeQueue = env->CallLongMethod(queue_size, longValue);
                        if (sizeQueue < sizeCommandQueue / 4 || sizeQueue > sizeCommandQueue) {
                            char *message = (char*)malloc(sizeof(char) * 370);
                            strcpy(message, "There is a problem with the CommandQueue type object that you are trying to create, ");
                            strcat(message, "since the size in bytes you have provided is less than a quarter or larger than the ");
                            strcat(message, "recommended size for the CommandQueue object you are trying to create, to know the ");
                            strcat(message, "recommended size use the method getQueueOnDevicePreferredSize, the above method can ");
                            strcat(message, "be found on the device you provided");
                            showMessageError(env, message);
                            return NULL;
                        }
                    }
                    if (VersionOpenCL >= 2.0) {
                        jlong value = queueProperties;
                        if (value == 0) {
                            char *message = (char*)malloc(sizeof(char) * 208);
                            strcpy(message, "You can only enter the following values to the hashmap together with the ");
                            strcat(message, "CommandQueue.QUEUE_PROPERTIESkey:\nCommandQueue.QUEUE_ON_DEVICE\n");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT\nCommandQueue.QUEUE_PROFILING_ENABLE\n");
                            showMessageError(env, message);
                            return NULL;
                        }
                        if ((value & (1 << 0)) == 1 << 0) value -= 1 << 0;
                        if ((value & (1 << 1)) == 1 << 1) value -= 1 << 1;
                        if ((value & (1 << 2)) == 1 << 2) value -= 1 << 2;
                        if ((value & (1 << 3)) == 1 << 3) value -= 1 << 3;
                        if (value != 0) {
                            char *message = (char*)malloc(sizeof(char) * 251);
                            strcpy(message, "You can only enter the following values to the hashmap together with the ");
                            strcat(message, "CommandQueue.QUEUE_PROPERTIESkey:\nCommandQueue.QUEUE_ON_DEVICE\n");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT\nCommandQueue.QUEUE_PROFILING_ENABLE\n");
                            strcat(message, "CommandQueue.QUEUE_EQU_ECORD_OUT_OVER_OFF");
                            showMessageError(env, message);
                            return NULL;
                        }
                        if (((queueProperties & (1 << 2) == 1 << 2 && (queueProperties & (1 << 3)) == 1 << 3)) ||
                            (queueProperties & (1 << 2)) == 1 << 2) {
                            if (((queueProperties & (1 << 0)) == 1 << 0 && (queueProperties & (1 << 1)) == 1 << 1) ||
                                (queueProperties & (1 << 0)) == 1 << 0) {
                                properties = (cl_command_queue_properties*)malloc(sizeof(cl_command_queue_properties) * 5);
                                properties[0] = CL_QUEUE_PROPERTIES;
                                properties[1] = (cl_command_queue_properties)queueProperties;
                                properties[2] = CL_QUEUE_SIZE;
                                properties[3] = (cl_command_queue_properties)sizeQueue;
                                properties[4] = 0;
                            } else {
                                char *message = (char*)malloc(sizeof(char) * 433);
                                strcpy(message, "There is a problem when creating the CommandQueue type object, because you are ");
                                strcat(message, "using the CommandQueue.QUEUE_ON_DEVICE and/or CommandQueue.QUEUE_ON_DEVICE_DEFAULT ");
                                strcat(message, "values, but you are not using the CommandQueue.QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE ");
                                strcat(message, "value\nAnother possible problem could be caused because you are using a different ");
                                strcat(message, "value to CommandQueue.QUEUE_PROFILING_ENABLE, this last value needs to be combined ");
                                strcat(message, "with the previous values");
                                showMessageError(env, message);
                                return NULL;
                            }
                        } else {
                            char *message = (char*)malloc(sizeof(char) * 340);
                            strcpy(message, "There is a problem when creating the CommandQueue type object, because you are not ");
                            strcat(message, "using the CommandQueue.QUEUE_ON_DEVICE value, if you intend to use the ");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE_DEFAULT value, you must necessarily use the ");
                            strcat(message, "CommandQueue.QUEUE_ON_DEVICE value and combine it with the ");
                            strcat(message, "CommandQueue.QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE value");
                            showMessageError(env, message);
                            return NULL;
                        }
                    } else {
                        char *message = (char*)malloc(sizeof(char) * 470);
                        strcpy(message, "There was a problem trying to create a CommandQueue object using the values ");
                        strcat(message, "CommandQueue.QUEUE_ON_DEVICE and/or CommandQueue.QUEUE_ON_DEVICE_DEFAULT, because the ");
                        strcat(message, "opencl version available to your android device is lower than version 2.0, so therefore ");
                        strcat(message, "you will not be able to use the hashmap To try to create the CommandQueue object, it is ");
                        strcat(message, "best to adjust the hashmap with a null value and thus the opencl system itself will create ");
                        strcat(message, "a CommandQueue object with default values");
                        showMessageError(env, message);
                        return NULL;
                    }
                } else if (_sizeHashMap > 2) {
                    char *message = (char*)malloc(sizeof(char) * 718);
                    strcpy(message, "The hashmap you have provided has 3 or more pairs of values, you can only use a hashmap with ");
                    strcat(message, "1 or 2 pairs of data, if you use the hashmap of 1 data pair you only need to use the following ");
                    strcat(message, "values correctly:\nCommandQueue.QUEUE_ON_DEVICE\nCommandQueue. QUEUE_ON_DEVICE_DEFAULT\n");
                    strcat(message, "CommandQueue.QUEUE_PROFILING_ENABLE\nCommandQueue.QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\nIf ");
                    strcat(message, "you use a 2-pair hashmap does the same as in the hashmap of 1 pair of data, but also includes ");
                    strcat(message, "the size in bytes of the object CommandQueue that you want to create\nWhich you can also ");
                    strcat(message, "leave. with a size of 0 the hashmap or adjust it with a null value so that the opencl system ");
                    strcat(message, "assigns a default configuration to the CommandQueue object that you want to create");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice = env->GetIntField(device, currentSubDevice);
    jboolean _isDevicePartition = env->GetBooleanField(device, isDevicePartition);
    void **Result = GetCreateCommandQueueWithProperties(_currentContext, _currentDevice, _currentSubDevice, _isDevicePartition, properties);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jobject commandQueue = env->AllocObject(CommandQueue);
        jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
        jfieldID currentContextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID currentDeviceCommandQueue = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
        jfieldID propertiesCommandQueue = env->GetFieldID(CommandQueue, "properties", "Ljava/util/HashMap;");
        jfieldID isSetDeviceDefault = env->GetFieldID(CommandQueue, "isSetDeviceDefault", "Z");
        jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
        env->SetIntField(commandQueue, currentCommandQueue, positionCurrentCommandQueue);
        env->SetObjectField(commandQueue, currentContextCommandQueue, context);
        env->SetObjectField(commandQueue, currentDeviceCommandQueue, device);
        env->SetLongField(commandQueue, propertiesSet, queueProperties);
        if (hashMap != NULL && _sizeHashMap > 0) env->SetObjectField(commandQueue, propertiesCommandQueue, hashMap);
        env->SetBooleanField(commandQueue, isSetDeviceDefault, JNI_FALSE);
        positionCurrentCommandQueue++;
        return commandQueue;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_CommandQueue_setDefaultDeviceCommandQueue(JNIEnv *env, jobject commandQueue, jobject context,
                                                       jobject device) {
    if (context == NULL || device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 245);
        strcpy(message, "There is a problem with the setDefaultDeviceCommandQueue method because you set a context or device ");
        strcat(message, "or both with a null value, so you must use a context or device or both valid objects, and try using ");
        strcat(message, "the setDefaultDeviceCommandQueue method again");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 151);
        strcpy(message, "You cannot use the setDefaultDeviceCommandQueue method because the version of OpenCL that is installed on ");
        strcat(message, "your android device is lower than version 2.1");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 136);
        strcpy(message, "The device you are providing cannot be set as the default device for the CommandQueue object, because the ");
        strcat(message, "CommandQueue object is invalid");
        showMessageError(env, message);
        return;
    }
    jclass HashMap = env->FindClass("java/util/HashMap");
    jclass Long = env->FindClass("java/lang/Long");
    jfieldID properties = env->GetFieldID(CommandQueue, "properties", "Ljava/util/HashMap;");
    jfieldID Queue_Properties = env->GetStaticFieldID(CommandQueue, "QUEUE_PROPERTIES", "Ljava/lang/String;");
    jmethodID getHashMap = env->GetMethodID(HashMap, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jobject _properties = env->GetObjectField(commandQueue, properties);
    jstring _Queue_Properties = (jstring) env->GetStaticObjectField(CommandQueue, Queue_Properties);
    jobject valueProperties = env->CallObjectMethod(_properties, getHashMap, _Queue_Properties);
    jlong _valueProperties = env->CallLongMethod(valueProperties, longValue);
    if ((_valueProperties & (1 << 3)) != 1 << 3) {
        char *message = (char*)malloc(sizeof(char) * 197);
        strcpy(message, "The device you are providing cannot be set as the default device for the CommandQueue object, because the ");
        strcat(message, "CommandQueue object was not created using the CommandQueue.QUEUE_ON_DEVICE_DEFAULT property");
        showMessageError(env, message);
        return;
    }
    jclass Device = env->GetObjectClass(device);
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentContext == -1 || _currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 144);
        strcpy(message, "The new device cannot be set as the default device in the CommandQueue object because the context and/or the ");
        strcat(message, "device you are providing is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID currentDeviceCommandQueue = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
    jobject _currentDeviceCommandQueue = env->GetObjectField(commandQueue, currentDeviceCommandQueue);
    if (env->IsSameObject(_currentDeviceCommandQueue, device)) {
        char *message = (char*)malloc(sizeof(char) * 144);
        strcpy(message, "You cannot assign the device as default, since it is the same device with which you created the ");
        strcat(message, "CommandQueue object that you are currently using");
        showMessageError(env, message);
        return;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice = env->GetIntField(device, currentSubDevice);
    jboolean _isDevicePartition = env->GetBooleanField(device, isDevicePartition);
    void **Result = setDefaultDeviceCommandQueue(_currentContext, _currentDevice, _currentSubDevice, _currentCommandQueue,
                                                 _isDevicePartition);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentContextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID isSetDeviceDefault = env->GetFieldID(CommandQueue, "isSetDeviceDefault", "Z");
        env->SetObjectField(commandQueue, currentContextCommandQueue, context);
        env->SetObjectField(commandQueue, currentDeviceCommandQueue, device);
        env->SetBooleanField(commandQueue, isSetDeviceDefault, JNI_TRUE);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_CommandQueue_releaseCommandQueue(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "It's impossible to release the CommandQueue object because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseCommandQueue(_currentCommandQueue);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(commandQueue, currentCommandQueue, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_CommandQueue_flush(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "You cannot use the flush method to execute the operation that is queued on the CommandQueue object ");
        strcat(message, "because it is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetFlushCommandQueue(_currentCommandQueue);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_CommandQueue_finish(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot use the finish method to execute the operation that is queued on the CommandQueue object ");
        strcat(message, "because it is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetFinishCommandQueue(_currentCommandQueue);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL jobject Java_com_draico_asvappra_opencl_CommandQueue_getContext(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentContext = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 48);
        strcpy(message, "The CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobject context = env->GetObjectField(commandQueue, currentContext);
    return context;
}
JNICALL jobject Java_com_draico_asvappra_opencl_CommandQueue_getDevice(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentDevice = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 48);
        strcpy(message, "The CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobject device = env->GetObjectField(commandQueue, currentDevice);
    return device;
}
JNICALL jint Java_com_draico_asvappra_opencl_CommandQueue_getReferenceCount(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 48);
        strcpy(message, "The CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return -1;
    }
    return _currentCommandQueue;
}
JNICALL jobject Java_com_draico_asvappra_opencl_CommandQueue_getDeviceDefault(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "Unable to get the default device of the CommandQueue object because that CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetDeviceDefault = env->GetFieldID(CommandQueue, "isSetDeviceDefault", "Z");
    jboolean _isSetDeviceDefault = env->GetBooleanField(commandQueue, isSetDeviceDefault);
    if (_isSetDeviceDefault) {
        jfieldID currentDevice = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
        jobject _currentDevice = env->GetObjectField(commandQueue, currentDevice);
        return _currentDevice;
    } else {
        char *message = (char*)malloc(sizeof(char) * 61);
        strcpy(message, "The CommandQueue object has not yet been set a default device");
        showMessageError(env, message);
        return NULL;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_CommandQueue_toString(JNIEnv *env, jobject commandQueue) {
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 78);
        strcpy(message, "The CommandQueue object you are using to invoke the toString method is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return commandQueueToString(env, commandQueue);
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_createBuffer(JNIEnv *env, jclass buffer, jobject context, jobject memory,
                                          jint flagsBuffer) {
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    if (context == NULL || memory == NULL) {
        char *message = (char*)malloc(sizeof(char) * 142);
        strcpy(message, "There is a problem with the createBuffer method because the context or memory was set to a null value, or ");
        strcat(message, "both objects are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentContext == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 97);
        strcpy(message, "The buffer cannot be created because you are using an invalid context or an invalid memory block");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsTemp = flagsBuffer;
    if ((flagsTemp & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsTemp & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsTemp & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if ((flagsTemp & (1 << 3)) == 1 << 3) flagsTemp -= 1 << 3;
    if ((flagsTemp & (1 << 5)) == 1 << 5) flagsTemp -= 1 << 5;
    if ((flagsTemp & (1 << 7)) == 1 << 7) flagsTemp -= 1 << 7;
    if ((flagsTemp & (1 << 8)) == 1 << 8) flagsTemp -= 1 << 8;
    if ((flagsTemp & (1 << 9)) == 1 << 9) flagsTemp -= 1 << 9;
    if (flagsTemp != 0) {
    char *message = (char*)malloc(sizeof(char) * 367);
        strcpy(message, "The flag(s) you are using is incorrect, use only the values that are inside the Buffer class, the flags ");
        strcat(message, "needed to create the buffer are the following:\nBuffer.BUFFER_READ_WRITE\nBuffer.BUFFER_WRITE_ONLY\n");
        strcat(message, "Buffer.BUFFER_READ_ONLY\nBuffer.BUFFER_USE_HOST_PTR\nBuffer.BUFFER_COPY_HOST_PTR\n");
        strcat(message, "Buffer.BUFFER_HOST_WRITE_ONLY\nBuffer.BUFFER_HOST_READ_ONLY\nBuffer.BUFFER_HOST_NO_ACCESS");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 3)) != 1 << 3 && ((flagsBuffer & (1 << 5)) != 1 << 5)) {
        char *message = (char*)malloc(sizeof(char) * 248);
        strcpy(message, "The buffer cannot be created because it has not used the Buffer.BUFFER_USE_HOST_PTR or ");
        strcat(message, "Buffer.BUFFER_COPY_HOST_PTR flag and this flag has to be combined with the type of action the buffer will ");
        strcat(message, "perform such as read, write, copy, read and write, etc.");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 0)) == 1 << 0 && (((flagsBuffer & (1 << 1)) == 1 << 1) || ((flagsBuffer & (1 << 2)) == 1 << 2))) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_READ_WRITE flag together with the ");
        strcat(message, "Buffer.BUFFER_WRITE_ONLY flag or Buffer.BUFFER_READ_ONLY flag");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 1)) == 1 << 1 && (flagsBuffer & (1 << 2)) == 1 << 2) {
        char *message = (char*)malloc(sizeof(char) * 191);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_WRITE_ONLY and Buffer.BUFFER_READ_ONLY ");
        strcat(message, "flags, you can only use one of the 2 flags and combine them with other buffer flags");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 7)) == 1 << 7 && (flagsBuffer & (1 << 8)) == 1 << 8) {
        char *message = (char*)malloc(sizeof(char) * 167);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_HOST_WRITE_ONLY flag and the ");
        strcat(message, "Buffer.BUFFER_HOST_READ_ONLY flag you can only use one of the 2 flags");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 9)) == 1 << 9 && (((flagsBuffer & (1 << 7)) == 1 << 7) || ((flagsBuffer & (1 << 8)) == 1 << 8))) {
        char *message = (char*)malloc(sizeof(char) * 192);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_HOST_NO_ACCESS flag and you ");
        strcat(message, "cannot use the Buffer.BUFFER_HOST_WRITE_ONLY flag and/or the  Buffer.BUFFER_HOST_READ_ONLY flag");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    void **Result = GetCreateBuffer(_currentContext, _sizeBlockMemory, _currentMemory, flagsBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
        jfieldID currentContext = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
        jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
        jstring typeData = env->NewStringUTF("M");
        jobject newBuffer = env->AllocObject(Buffer);
        env->SetIntField(newBuffer, currentBuffer, positionCurrentBuffer);
        env->SetObjectField(newBuffer, currentContext, context);
        env->SetObjectField(newBuffer, bufferData, memory);
        env->SetObjectField(newBuffer, typeDataBuffer, typeData);
        env->SetBooleanField(newBuffer, isSubBuffer, JNI_FALSE);
        positionCurrentBuffer++;
        return newBuffer;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_createBufferWithPrimitiveArray(JNIEnv *env, jclass Buffer, jobject context, jobject data,
                                                            jint flagsBuffer) {
    if (context == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 116);
        strcpy(message, "You cannot create the Buffer object because the Context object and/or the data object you provided are set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot create the Buffer object because the Context object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsTemp = flagsBuffer;
    if ((flagsTemp & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsTemp & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsTemp & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if ((flagsTemp & (1 << 3)) == 1 << 3) flagsTemp -= 1 << 3;
    if ((flagsTemp & (1 << 5)) == 1 << 5) flagsTemp -= 1 << 5;
    if ((flagsTemp & (1 << 7)) == 1 << 7) flagsTemp -= 1 << 7;
    if ((flagsTemp & (1 << 8)) == 1 << 8) flagsTemp -= 1 << 8;
    if ((flagsTemp & (1 << 9)) == 1 << 9) flagsTemp -= 1 << 9;
    if (flagsTemp != 0) {
        char *message = (char*)malloc(sizeof(char) * 367);
        strcpy(message, "The flag(s) you are using is incorrect, use only the values that are inside the Buffer class, the flags ");
        strcat(message, "needed to create the buffer are the following:\nBuffer.BUFFER_READ_WRITE\nBuffer.BUFFER_WRITE_ONLY\n");
        strcat(message, "Buffer.BUFFER_READ_ONLY\nBuffer.BUFFER_USE_HOST_PTR\nBuffer.BUFFER_COPY_HOST_PTR\n");
        strcat(message, "Buffer.BUFFER_HOST_WRITE_ONLY\nBuffer.BUFFER_HOST_READ_ONLY\nBuffer.BUFFER_HOST_NO_ACCESS");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 3)) != 1 << 3 && ((flagsBuffer & (1 << 5)) != 1 << 5)) {
        char *message = (char*)malloc(sizeof(char) * 248);
        strcpy(message, "The buffer cannot be created because it has not used the Buffer.BUFFER_USE_HOST_PTR or ");
        strcat(message, "Buffer.BUFFER_COPY_HOST_PTR flag and this flag has to be combined with the type of action the buffer will ");
        strcat(message, "perform such as read, write, copy, read and write, etc.");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 0)) == 1 << 0 && (((flagsBuffer & (1 << 1)) == 1 << 1) || ((flagsBuffer & (1 << 2)) == 1 << 2))) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_READ_WRITE flag together with the ");
        strcat(message, "Buffer.BUFFER_WRITE_ONLY flag or Buffer.BUFFER_READ_ONLY flag");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 1)) == 1 << 1 && (flagsBuffer & (1 << 2)) == 1 << 2) {
        char *message = (char*)malloc(sizeof(char) * 191);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_WRITE_ONLY and Buffer.BUFFER_READ_ONLY ");
        strcat(message, "flags, you can only use one of the 2 flags and combine them with other buffer flags");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 7)) == 1 << 7 && (flagsBuffer & (1 << 8)) == 1 << 8) {
        char *message = (char*)malloc(sizeof(char) * 167);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_HOST_WRITE_ONLY flag and the ");
        strcat(message, "Buffer.BUFFER_HOST_READ_ONLY flag you can only use one of the 2 flags");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 9)) == 1 << 9 && (((flagsBuffer & (1 << 7)) == 1 << 7) || ((flagsBuffer & (1 << 8)) == 1 << 8))) {
        char *message = (char*)malloc(sizeof(char) * 192);
        strcpy(message, "The buffer cannot be created because you are using the Buffer.BUFFER_HOST_NO_ACCESS flag and you ");
        strcat(message, "cannot use the Buffer.BUFFER_HOST_WRITE_ONLY flag and/or the  Buffer.BUFFER_HOST_READ_ONLY flag");
        showMessageError(env, message);
        return NULL;
    }
    jclass Object = env->FindClass("java/lang/Object");
    jclass Class = env->FindClass("java/lang/Class");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jobject objectClass = env->CallObjectMethod(data, getClass);
    if (!env->CallBooleanMethod(objectClass, isArray)) {
        char *message = (char*)malloc(sizeof(char) * 271);
        strcpy(message, "You cannot create the Buffer object because the data object you provided is not a data array, and you can ");
        strcat(message, "only use primitive data arrays such as int, short, long, float, char, and byte, as well as arrays of the ");
        strcat(message, "Integer, Short object type , Long, Float, Character and Byte");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray _data = (jobjectArray)data;
    jsize sizeArray = env->GetArrayLength(_data);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 90);
        strcpy(message, "You cannot create the Buffer object because the data object you provided is an empty array");
        showMessageError(env, message);
        return NULL;
    }
    jstring nameClass = (jstring)env->CallObjectMethod(objectClass, getName);
    const char *_nameClass = env->GetStringUTFChars(nameClass, NULL);
    jstring typeData;
    void **Result;
    if (strcmp(_nameClass, "[I") == 0) {
        typeData = env->NewStringUTF("[I");
        jint *dataInt = env->GetIntArrayElements((jintArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataInt, flagsBuffer);
    } else if (strcmp(_nameClass, "[S") == 0) {
        typeData = env->NewStringUTF("[S");
        jshort *dataShort = env->GetShortArrayElements((jshortArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataShort, flagsBuffer);
    } else if (strcmp(_nameClass, "[J") == 0) {
        typeData = env->NewStringUTF("[J");
        jlong *dataLong = env->GetLongArrayElements((jlongArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataLong, flagsBuffer);
    } else if (strcmp(_nameClass, "[F") == 0) {
        typeData = env->NewStringUTF("[F");
        jfloat *dataFloat = env->GetFloatArrayElements((jfloatArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataFloat, flagsBuffer);
    } else if (strcmp(_nameClass, "[C") == 0) {
        typeData = env->NewStringUTF("[C");
        jbyte *dataChar = (jbyte*)env->GetCharArrayElements((jcharArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataChar, flagsBuffer);
    } else if (strcmp(_nameClass, "[B") == 0) {
        typeData = env->NewStringUTF("[B");
        jbyte *dataByte = env->GetByteArrayElements((jbyteArray)_data, NULL);
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataByte, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Integer;") == 0) {
        jclass Integer = env->FindClass("java/lang/Integer");
        jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
        jint *dataInt = (jint*)malloc(sizeof(jint) * sizeArray);
        typeData = env->NewStringUTF("[I");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataInt[position] = env->CallIntMethod(number, intValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataInt, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Short;") == 0) {
        jclass Short = env->FindClass("java/lang/Short");
        jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
        jshort *dataShort = (jshort*)malloc(sizeof(jshort) * sizeArray);
        typeData = env->NewStringUTF("[S");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataShort[position] = env->CallShortMethod(number, shortValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataShort, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Long;") == 0) {
        jclass Long = env->FindClass("java/lang/Long");
        jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
        jlong *dataLong = (jlong*)malloc(sizeof(jlong) * sizeArray);
        typeData = env->NewStringUTF("[J");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataLong[position] = env->CallLongMethod(number, longValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataLong, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Float;") == 0) {
        jclass Float = env->FindClass("java/lang/Float");
        jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
        jfloat *dataFloat = (jfloat*)malloc(sizeof(jfloat) * sizeArray);
        typeData = env->NewStringUTF("[F");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataFloat[position] = env->CallFloatMethod(number, floatValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataFloat, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Character;") == 0) {
        jclass Character = env->FindClass("java/lang/Character");
        jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
        jbyte *dataChar = (jbyte*)malloc(sizeof(jbyte) * sizeArray);
        typeData = env->NewStringUTF("[C");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataChar[position] = (jbyte)env->CallCharMethod(number, charValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataChar, flagsBuffer);
    } else if (strcmp(_nameClass, "[Ljava.lang.Byte") == 0) {
        jclass Byte = env->FindClass("java/lang/Byte");
        jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
        jbyte *dataByte = (jbyte*)malloc(sizeof(jbyte) * sizeArray);
        typeData = env->NewStringUTF("[B");
        for (jint position = 0; position < sizeArray; position++) {
            jobject number = env->GetObjectArrayElement(_data, position);
            dataByte[position] = env->CallByteMethod(number, byteValue);
        }
        Result = GetCreateBufferWithArrayPrimitive(_currentContext, sizeArray, dataByte, flagsBuffer);
    } else {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot create the Buffer object because the data object you provided is not a data array, and you can ");
        strcat(message, "only use primitive data arrays such as int, short, long, float, char, and byte, as well as arrays of the ");
        strcat(message, "Integer, Short object type , Long, Float, Character and Byte");
        showMessageError(env, message);
        return NULL;
    }
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
        jfieldID currentContext = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
        jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
        jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
        jobject buffer = env->AllocObject(Buffer);
        jobject _bufferData = NULL;
        env->SetIntField(buffer, currentBuffer, positionCurrentBuffer);
        env->SetBooleanField(buffer, isSubBuffer, JNI_FALSE);
        env->SetObjectField(buffer, bufferData, _bufferData);
        env->SetObjectField(buffer, typeDataBuffer, typeData);
        env->SetObjectField(buffer, currentContext, context);
        positionCurrentBuffer++;
        return buffer;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_createSubBuffer(JNIEnv *env, jobject buffer, jint flagsBuffer, jint sizeBlockMemory) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer was ");
        strcat(message, "released");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    if (_isSubBuffer) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot create a subBuffer, because you want to create the subBuffer from another subBuffer, and ");
        strcat(message, "subBuffer can only be created from a buffer");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsBuffer & (1 << 3)) == 1 << 3) {
        char *message = (char*)malloc(sizeof(char) * 148);
        strcpy(message, "The subBuffer cannot be created because it is not allowed to use the Buffer.BUFFER_USE_HOST_PTR flag ");
        strcat(message, "because it inherits it from the original buffer");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsTemp = flagsBuffer;
    if ((flagsTemp & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsTemp & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsTemp & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if ((flagsTemp & (1 << 7)) == 1 << 7) flagsTemp -= 1 << 7;
    if ((flagsTemp & (1 << 8)) == 1 << 8) flagsTemp -= 1 << 8;
    if ((flagsTemp & (1 << 9)) == 1 << 9) flagsTemp -= 1 << 9;
    if (flagsTemp != 0) {
        char *message = (char*)malloc(sizeof(char) * 312);
        strcpy(message, "The flag(s) you are using is incorrect, use only the values that are inside the Buffer class, the flags ");
        strcat(message, "needed to create the buffer are the following:\nBuffer.BUFFER_READ_WRITE\nBuffer.BUFFER_WRITE_ONLY\n");
        strcat(message, "Buffer.BUFFER_READ_ONLY\nBuffer.BUFFER_HOST_WRITE_ONLY\nBuffer.BUFFER_HOST_READ_ONLY\n");
        strcat(message, "Buffer.BUFFER_HOST_NO_ACCESS");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMem = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMem = env->GetIntField(_bufferData, sizeBlockMem);
    if (sizeBlockMemory > _sizeBlockMem) {
        char *message = (char*)malloc(sizeof(char) * 376);
        strcpy(message, "The subBuffer cannot be created because the size of the memory block that you specified for this subBuffer ");
        strcat(message, "is larger than the size of the memory block of the buffer you are using to create it, also check if the ");
        strcat(message, "combination of the offset and the size of the memory block of the subBuffer are not larger than the size ");
        strcat(message, "of the memory block of the buffer you are using to create it");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeBlockMemory % 2 != 0) {
        char *message = (char*)malloc(sizeof(char) * 109);
        strcpy(message, "The subBuffer cannot be created because the size of the memory block for this subBuffer is not multiples of 2");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCreateSubBuffer(_currentBuffer, flagsBuffer, CL_BUFFER_CREATE_TYPE_REGION, sizeBlockMemory);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
        jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
        jfieldID currentContext = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
        jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
        jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
        jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
        jobject _bufferDataSrcBuffer = env->GetObjectField(buffer, bufferData);
        jobject _currentContext = env->GetObjectField(buffer, currentContext);
        jstring typeData = env->NewStringUTF("M");
        jobject subBuffer = env->AllocObject(Buffer);
        env->SetIntField(subBuffer, currentBuffer, positionCurrentBuffer);
        env->SetIntField(subBuffer, currentBufferRegion, positionCurrentBufferRegion);
        env->SetIntField(subBuffer, sizeBlockMemorySubBuffer, (jint)listSubBuffersRegion[positionCurrentBufferRegion]->size);
        env->SetBooleanField(subBuffer, isSubBuffer, JNI_TRUE);
        env->SetObjectField(subBuffer, bufferData, _bufferDataSrcBuffer);
        env->SetObjectField(subBuffer, currentContext, _currentContext);
        env->SetObjectField(subBuffer, typeDataBuffer, typeData);
        positionCurrentBuffer++;
        positionCurrentBufferRegion++;
        return subBuffer;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_readBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jboolean isBlockingRead,
    jint offsetRead, jint sizeBlock) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer was ");
        strcat(message, "released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 174);
        strcpy(message, "The buffer cannot be read because the CommandQueue object was set to a null value, place a valid ");
        strcat(message, "CommandQueue object in the readBuffer method and try to read the buffer again");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "Cannot read the buffer because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (offsetRead < 0 || sizeBlock <= 0) {
        char *message = (char*)malloc(sizeof(char) * 167);
        strcpy(message, "The buffer cannot be read because it provided a negative value for the offset of the reading or provided a ");
        strcat(message, "negative value or 0 for the block size of the buffer reading");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jint _sizeBlockMemory;
    if (!_isSubBuffer) _sizeBlockMemory = env->GetIntField(_bufferData, sizeBlockMemory);
    else _sizeBlockMemory = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    if (sizeBlock > _sizeBlockMemory || (offsetRead + sizeBlock) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 285);
        strcpy(message, "The size of the reading block of the current buffer exceeds the size of the memory block of the buffer, ");
        strcat(message, "also check if the offset applied to the reading of the memory block of the buffer added with the size ");
        strcat(message, "of the reading block does not exceed the size of the memory block of the buffer");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    void **Result = GetEnqueueReadBuffer(_currentCommandQueue, _currentBuffer, _currentMemory, isBlockingRead, offsetRead, sizeBlock);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = _sizeBlockMemory / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_memory_buffer_Buffer_getIntArray(JNIEnv *env, jobject buffer, jobject commandQueue, jint sizeArray ) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 112);
        strcpy(message, "You cannot use the getIntArray method of the buffer you are using because the CommandQueue object is set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentBuffer == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 128);
        strcpy(message, "You cannot use the readIntArray method of the buffer you are using because the CommandQueue object and the ");
        strcat(message, "buffer may be invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeArray <= 0) {
        char *message = (char*)malloc(sizeof(char) * 185);
        strcpy(message, "You cannot use the getIntArray method of the buffer you are using because the size you provided for the ");
        strcat(message, "size of the array to return the contents of the buffer is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jint *_data = (jint*)malloc(sizeof(jint) * sizeArray);
    readBuffer(_currentCommandQueue, *listBuffers[_currentBuffer], _data, sizeArray);
    jintArray array = env->NewIntArray(sizeArray);
    env->SetIntArrayRegion(array, 0, sizeArray, _data);
    return array;
}
JNICALL jshortArray Java_com_draico_asvappra_opencl_memory_buffer_Buffer_getShortArray(JNIEnv *env, jobject buffer, jobject commandQueue, jint sizeArray) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 127);
        strcpy(message, "You cannot use the getShortArray method of the buffer you are using because the CommandQueue object you ");
        strcat(message, "provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentBuffer == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 156);
        strcpy(message, "You cannot use the getShortArray method of the buffer you are using because the buffer you are using and/or ");
        strcat(message, "the CommandQueue ");
        strcat(message, "object you provided are invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeArray <= 0) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot use the getShortArray method of the buffer you are using because the value you provided in the ");
        strcat(message, "sizeArray variable is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jshort *data = (jshort*)malloc(sizeof(jshort) * sizeArray);
    readBuffer(_currentCommandQueue, *listBuffers[_currentBuffer], data, sizeArray);
    jshortArray _data = env->NewShortArray(sizeArray);
    env->SetShortArrayRegion(_data, 0, sizeArray, data);
    return _data;
}
JNICALL jlongArray Java_com_draico_asvappra_opencl_memory_buffer_Buffer_getLongArray(JNIEnv *env, jobject buffer, jobject commandQueue, jint sizeArray) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 126);
        strcpy(message, "You cannot use the getLongArray method of the buffer you are using because the CommandQueue object you ");
        strcat(message, "provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1 || _currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot use the getLongArray method of the buffer you are using because the CommandQueue object and/or ");
        strcat(message, "the buffer you are using are invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeArray <= 0) {
        char *message = (char*)malloc(sizeof(char) * 137);
        strcpy(message, "You cannot use the getLongArray method of the buffer you are using because the value of the sizeArray ");
        strcat(message, "variable is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jlong *data = (jlong*)malloc(sizeof(jlong) * sizeArray);
    readBuffer(_currentCommandQueue, *listBuffers[_currentBuffer], data, sizeArray);
    jlongArray _data = env->NewLongArray(sizeArray);
    env->SetLongArrayRegion(_data, 0, sizeArray, data);
    return _data;
}
JNICALL jfloatArray Java_com_draico_asvappra_opencl_memory_buffer_Buffer_getFloatArray(JNIEnv *env, jobject buffer, jobject commandQueue, jint sizeArray) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot use the getFloatArray method of the buffer you are using because the CommandQueue object is set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentBuffer == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot use the getFloatArray method of the buffer you are using because the CommandQueue object and/or ");
        strcat(message, "the buffer you are using are invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeArray <= 0) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "You cannot use the getFloatArray method of the buffer you are using because the value of the sizeArray ");
        strcat(message, "variable is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jfloat *data = (jfloat*)malloc(sizeof(jfloat) * sizeArray);
    readBuffer(_currentCommandQueue, *listBuffers[_currentBuffer], data, sizeArray);
    jfloatArray _data = env->NewFloatArray(sizeArray);
    env->SetFloatArrayRegion(_data, 0, sizeArray, data);
    return _data;
}
JNICALL jbyteArray Java_com_draico_asvappra_opencl_memory_buffer_Buffer_getByteArray(JNIEnv *env, jobject buffer, jobject commandQueue, jint sizeArray) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "You cannot use the getByteArray method of the Buffer class because the CommandQueue object you provided ");
        strcat(message, "has a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentBuffer == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 163);
        strcpy(message, "You cannot use the getByteArray method of the Buffer object you are using because the CommandQueue object ");
        strcat(message, "and/or the Buffer object you are using have been released");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeArray <= 0) {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "You cannot use the getByteArray method of the Buffer type object you are using because the value of the ");
        strcat(message, "sizeArray variable you provided is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jbyte *data = (jbyte*)malloc(sizeof(jbyte) * sizeArray);
    readBuffer(_currentCommandQueue, *listBuffers[_currentBuffer], data, sizeArray);
    jbyteArray _data = env->NewByteArray(sizeArray);
    env->SetByteArrayRegion(_data, 0, sizeArray, data);
    return _data;
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jboolean isBlockingWrite,
                                         jint offsetWrite, jint sizeBlock) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 179);
        strcpy(message, "Buffer writing cannot be performed because the CommandQueue object you provided was set to a null ");
        strcat(message, "value, use a valid CommandQueue object and try again using the writeBuffer method");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "Cannot write the buffer because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (offsetWrite < 0 || sizeBlock <= 0) {
        char *message = (char*)malloc(sizeof(char) * 219);
        strcpy(message, "The write of the buffer cannot be performed, because you provided a negative value for the offset for ");
        strcat(message, "the write, although you may also have provided a value of 0 or negative for the size of the write ");
        strcat(message, "block of the buffer");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jint _sizeBlockMemory;
    if (!_isSubBuffer) _sizeBlockMemory = env->GetIntField(_bufferData, sizeBlockMemory);
    else _sizeBlockMemory = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    if (sizeBlock > _sizeBlockMemory || (offsetWrite + sizeBlock) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 256);
        strcpy(message, "The size of the writing block is greater than the block of memory that was assigned to the buffer, ");
        strcat(message, "another possible problem is that the sum of the writing offset added to the writing block is ");
        strcat(message, "greater than the block of memory that was assigned to the buffer");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetEnqueueWriteBuffer(_currentCommandQueue, _currentBuffer, _currentMemory, isBlockingWrite, offsetWrite, sizeBlock);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
        jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
        jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = _sizeBlockMemory / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    }
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeIntArray(JNIEnv *env, jobject buffer, jobject commandQueue, jintArray data) {
    if (commandQueue == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 101);
        strcpy(message, "You cannot use the writeIntArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the data array you provided are set to null");
        showMessageError(env, message);
        return;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jsize sizeArray = env->GetArrayLength(data);
    if (_currentBuffer == -1 || _currentCommandQueue == -1 || sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 221);
        strcpy(message, "You cannot use the writeIntArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid, also another possible problem is that the data array that provided ");
        strcat(message, "this is empty");
        showMessageError(env, message);
        return;
    }
    jint *_data = env->GetIntArrayElements(data, NULL);
    writeBuffer(_currentCommandQueue, listBuffers[_currentBuffer], _data, sizeArray);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeShortArray(JNIEnv *env, jobject buffer, jobject commandQueue, jshortArray data) {
    if (commandQueue == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot use the writeShortArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the data array you provided are set to null");
        showMessageError(env, message);
        return;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jsize sizeArray = env->GetArrayLength(data);
    if (_currentBuffer == -1 || _currentCommandQueue == -1 || sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 205);
        strcpy(message, "You cannot use the writeShortArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid, also the problem may be caused because the data array is empty");
        showMessageError(env, message);
        return;
    }
    jshort *_data = env->GetShortArrayElements(data, NULL);
    writeBuffer(_currentCommandQueue, listBuffers[_currentBuffer], _data, sizeArray);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeLongArray(JNIEnv *env, jobject buffer, jobject commandQueue, jlongArray data) {
    if (commandQueue == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 148);
        strcpy(message, "You cannot use the writeLongArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the data array are set to null");
        showMessageError(env, message);
        return;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jsize sizeArray = env->GetArrayLength(data);
    if (_currentBuffer == -1 || _currentCommandQueue == -1 || sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 217);
        strcpy(message, "You cannot use the writeLongArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid, also another possible cause of the error is because the data array ");
        strcat(message, "is empty");
        showMessageError(env, message);
        return;
    }
    jlong *_data = env->GetLongArrayElements(data, NULL);
    writeBuffer(_currentCommandQueue, listBuffers[_currentBuffer], _data, sizeArray);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeFloatArray(JNIEnv *env, jobject buffer, jobject commandQueue, jfloatArray data) {
    if (commandQueue == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 149);
        strcpy(message, "You cannot use the writeFloatArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the data array are set to null");
        showMessageError(env, message);
        return;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jsize sizeArray = env->GetArrayLength(data);
    if (_currentBuffer == -1 || _currentCommandQueue == -1 || sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot use the writeFloatArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid, also another possible cause of the error is because the data array ");
        strcat(message, "is empty");
        showMessageError(env, message);
        return;
    }
    jfloat *_data = env->GetFloatArrayElements(data, NULL);
    writeBuffer(_currentCommandQueue, listBuffers[_currentBuffer], _data, sizeArray);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeByteArray(JNIEnv *env, jobject buffer, jobject commandQueue, jbyteArray data) {
    if (commandQueue == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 147);
        strcpy(message, "You cannot use the writeByteArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the data array is set to null");
        showMessageError(env, message);
        return;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jsize sizeArray = env->GetArrayLength(data);
    if (_currentBuffer == -1 || _currentCommandQueue == -1 || sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 206);
        strcpy(message, "You cannot use the writeByteArray method of the buffer you are currently using because the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid, also the problem could be caused because the data array is empty");
        showMessageError(env, message);
        return;
    }
    jbyte *_data = env->GetByteArrayElements(data, NULL);
    writeBuffer(_currentCommandQueue, listBuffers[_currentBuffer], _data, sizeArray);
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_readBufferRect(JNIEnv *env, jobject buffer, jobject commandQueue, jobject dataBlock,
                                            jboolean isBlockingRead, jintArray offsetXYZDataBlock, jintArray offsetXYZBuffer,
                                            jintArray regionRead, jint lengthColumnsPerRowInDataBlock, jint sizeAreaDataBlock,
                                            jint lengthColumnsPerRowInBuffer, jint sizeAreaBuffer) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || dataBlock == NULL || offsetXYZDataBlock == NULL || offsetXYZBuffer == NULL || regionRead == NULL) {
        char *message = (char*)malloc(sizeof(char) * 385);
        strcpy(message, "The buffer cannot be read using the readBufferRect method because you have any of the following problems:\n");
        strcat(message, "1.- You have entered a null value or the CommandQueue object you provided is set to a null value\n2.- The ");
        strcat(message, "block of memory you have provided is invalid\n3.- Any of the following arrangements are set to null:\n");
        strcat(message, "  - offsetXYZDatablock\n - offsetXYZBuffer\n - regionRead");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "Cannot read the buffer with the readBufferRect method because the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint currentDataBlock = env->GetIntField(dataBlock, currentMemory);
    if (currentDataBlock == -1) {
        char *message = (char*)malloc(sizeof(char) * 123);
        strcpy(message, "The content of the buffer cannot be read because the memory block you have provided in the readBufferRect ");
        strcat(message, "method is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (env->IsSameObject(_bufferData, dataBlock)) {
        char *message = (char*)malloc(sizeof(char) * 161);
        strcpy(message, "The memory block that you have provided for the readBufferRect method, is the same memory block of ");
        strcat(message, "the buffer that you are using to use the readBufferRect method");
        showMessageError(env, message);
        return NULL;
    }
    jint lengthOffsetXYZSrcBuffer = env->GetArrayLength(offsetXYZDataBlock);
    jint lengthOffsetXYZDstBuffer = env->GetArrayLength(offsetXYZBuffer);
    jint lengthRegion = env->GetArrayLength(regionRead);
    if (lengthOffsetXYZSrcBuffer != 3 || lengthOffsetXYZDstBuffer != 3 || lengthRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 855);
        strcpy(message, "The buffer reading cannot be done because the length of the offsetXYZDataBlock, offsetXYZBuffer and region ");
        strcat(message, "arrays must be 3, the offsetXYZDataBlock and offsetXYZBuffer arrays can be used to specify a 2D or 3D ");
        strcat(message, "offset, when you want to specify a 2D offset. third data of both arrangements must be at 0, and the third ");
        strcat(message, "data from the regionRead array must be at 1, the data from the regionRead array are as follows: the first data ");
        strcat(message, "specifies the width of the reading, the second specifies the height and the third the number of layers of ");
        strcat(message, "the reading, if in the offsetXYZDataBlock and offsetXYZ arrays you are going to work in 2D then this ");
        strcat(message, "third data must have a value of 1, since you are going to work only with one layer, when you go to work ");
        strcat(message, "with an offset in 3D in this last data of the regionRead array you must specify the number of layers that ");
        strcat(message, "will be read");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jint dataBlockSize = env->GetIntField(dataBlock, sizeBlockMemory);
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jint bufferDataSize;
    if (!_isSubBuffer) bufferDataSize = env->GetIntField(_bufferData, sizeBlockMemory);
    else bufferDataSize = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    jint *_offsetXYZDataBlock = env->GetIntArrayElements(offsetXYZDataBlock, NULL);
    jint *_offsetXYZBuffer = env->GetIntArrayElements(offsetXYZBuffer, NULL);
    jint *_region = env->GetIntArrayElements(regionRead, NULL);
    jint XDataBlock = _offsetXYZDataBlock[0];
    jint YDataBlock = _offsetXYZDataBlock[1];
    jint ZDataBlock = _offsetXYZDataBlock[2];
    jint XBuffer = _offsetXYZBuffer[0];
    jint YBuffer = _offsetXYZBuffer[1];
    jint ZBuffer = _offsetXYZBuffer[2];
    jint widthRegion = _region[0];
    jint rowsRegion = _region[1];
    jint layersRegion = _region[2];
    if (XDataBlock < 0 || YDataBlock < 0 || ZDataBlock < 0 || XBuffer < 0 || YBuffer < 0 || ZBuffer < 0 || widthRegion <= 0 ||
        rowsRegion <= 0 || layersRegion <= 0 || lengthColumnsPerRowInDataBlock <= 0 || sizeAreaDataBlock <= 0 ||
        lengthColumnsPerRowInBuffer <= 0 || sizeAreaBuffer <= 0) {
        char *message = (char*)malloc(sizeof(char) * 983);
        strcpy(message, "The data that you entered to the offsetXYZDataBlock array or to the offsetXYZBuffer array or to the ");
        strcat(message, "regionRead array, at least one of the data is less than 0, in the previous 3 arrangements the first ");
        strcat(message, "2 positions must be numbers greater or equal than 0, the third data for the offsetXYZDataBlock and ");
        strcat(message, "offsetXYZBuffer array is 0 if you plan to work with a 2D region, if you plan to work with a 3D ");
        strcat(message, "region this third data is to specify the number of layers that these 2 arrays will work with, and ");
        strcat(message, "the third data of the regionRead array must be 1 if you plan to work with a 2D region with the ");
        strcat(message, "offsetXYZDataBlock and offsetXYZBuffer arrays or specify the number of layers you will work with if ");
        strcat(message, "you will use a 3D region with the offsetXYZDataBlock and offsetXYZBuffer arrays. The problem can ");
        strcat(message, "also be caused by the variables lengthColumnsPerRowInDataBlock, sizeAreaDataBlock, ");
        strcat(message, "lengthColumnsPerRowInBuffer and sizeAreaBuffer, the value of these variables should never be less ");
        strcat(message, "than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    if (((sizeAreaDataBlock < (rowsRegion * lengthColumnsPerRowInDataBlock)) || ((sizeAreaDataBlock % lengthColumnsPerRowInDataBlock) != 0))
        || ((sizeAreaBuffer < (rowsRegion * lengthColumnsPerRowInBuffer)) || ((sizeAreaBuffer % lengthColumnsPerRowInBuffer) != 0))) {
        char *message = (char*)malloc(sizeof(char) * 413);
        strcpy(message, "There is a problem with the readBufferRect method because the sizeAreaDataBlock variable is less than the ");
        strcat(message, "multiplication of the second position of the regionRead array and of the lengthColumnsPerRowInDataBlock ");
        strcat(message, "variable or the sizeAreaDataBlock variable may not be multiple of lengthColumnsPerRowInBlock, the 2 possible ");
        strcat(message, "previous problems also occur with the lengthColumnsPerRowInBuffer and sizeAreaBuffer variables");
        showMessageError(env, message);
        return NULL;
    }
    if (lengthColumnsPerRowInBuffer < widthRegion || lengthColumnsPerRowInDataBlock < widthRegion) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The number of bytes that are in a row of the area that will be read from either the memory block or the ");
        strcat(message, "buffer is less than the number you indicated in the first position of the regionRead array, this first ");
        strcat(message, "position is to indicate the number of bytes it will have the area to read horizontally");
        showMessageError(env, message);
        return NULL;
    }
    jint offsetXDB = XDataBlock;
    jint offsetYDB = YDataBlock * lengthColumnsPerRowInDataBlock;
    jint offsetZDB = ZDataBlock * sizeAreaDataBlock;
    jint offsetXB = XBuffer;
    jint offsetYB = YBuffer * lengthColumnsPerRowInBuffer;
    jint offsetZB = ZBuffer * sizeAreaBuffer;
    if (((offsetXDB + offsetYDB + offsetZDB) + (widthRegion * rowsRegion * layersRegion)) > dataBlockSize ||
        ((offsetXB + offsetYB + offsetZB) + (widthRegion * rowsRegion * layersRegion)) > bufferDataSize) {
        char *message = (char*)malloc(sizeof(char) * 1236);
        strcpy(message, "The offset for the offsetXYZDataBlock array and/or the offsetXYZBuffer array that you entered exceeds ");
        strcat(message, "the size of the dataBlock memory block and the buffer, since the data you enter to the offsetXYZDataBlock ");
        strcat(message, "array will be multiplied with the data of the variables lengthColumnsPerRowInDataBlock and ");
        strcat(message, "sizeAreaDatablock of the following way: the second position of the offsetXYZDataBlock array that ");
        strcat(message, "represents the Y of the array is multiplied with the variable lengthColumnsPerRowInDataBlock, the third ");
        strcat(message, "position of the same array that represents Z, is multiplied with the variable sizeAreaDataBlock and these ");
        strcat(message, "2 multiplications are added with the X position of the array to then be added with the multiplication of ");
        strcat(message, "all the positions of the regionRead array, this array determines the area to be read (if the reading will ");
        strcat(message, "be in 2D it will be determined by the 3rd position of the region array whose value will be 1, or a volume ");
        strcat(message, "in 3D if the third value of the regionRead array you must provide the number of layers with of layers ");
        strcat(message, "with which you will work in the 3D) and then be compared with the size of the dataBlock memory block. ");
        strcat(message, "The same operation applies to the offsetXYZBuffer array but with the variables lengthColumnsPerRowInBuffer");
        strcat(message, " and sizeAreaBuffer");
        showMessageError(env, message);
        return NULL;
    }
    size_t __offsetXYZDataBlock[] = { (size_t)_offsetXYZDataBlock[0], (size_t)_offsetXYZDataBlock[1], (size_t)_offsetXYZDataBlock[2] };
    size_t __offsetXYZBuffer[] = { (size_t)_offsetXYZBuffer[0], (size_t)_offsetXYZBuffer[1], (size_t)_offsetXYZBuffer[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    void **Result = GetEnqueueReadBufferRect(_currentCommandQueue, _currentBuffer, _currentMemory, isBlockingRead, __offsetXYZDataBlock,
                                             __offsetXYZBuffer, __region, lengthColumnsPerRowInDataBlock, sizeAreaDataBlock,
                                             lengthColumnsPerRowInBuffer, sizeAreaBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
        jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jint _flagsBlockMemory = env->GetIntField(dataBlock, flagsBlockMemory);
        jint _flagsMapMemory = env->GetIntField(dataBlock, flagsMapMemory);
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, currentDataBlock, dataBlockSize, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(dataBlock, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = dataBlockSize / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(dataBlockSize);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, dataBlockSize, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(dataBlock, dataMemory, _dataMemory);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_writeBufferRect(JNIEnv *env, jobject buffer, jobject commandQueue, jobject dataBlock,
                                             jboolean isBlockingWrite, jintArray offsetXYZDataBlock, jintArray offsetXYZBuffer,
                                             jintArray regionWrite, jint lengthColumnsPerRowInDataBlock, jint sizeAreaDataBlock,
                                             jint lengthColumnsPerRowInBuffer, jint sizeAreaBuffer) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData","Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || dataBlock == NULL || offsetXYZDataBlock == NULL || offsetXYZBuffer == NULL || regionWrite == NULL) {
        char *message = (char*)malloc(sizeof(char) * 199);
        strcpy(message, "You are trying to use a CommandQueue object, and/or the memory block, and/or the offsetXYZDataBlock ");
        strcat(message, "array, and/or the offsetXYZBuffer array, and/or the regionWrite array is or are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 98);
        strcpy(message, "Cannot write the buffer with the writeBufferRect method because the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint currentDataBlock = env->GetIntField(dataBlock, currentMemory);
    if (currentDataBlock == -1) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "The buffer content cannot be written because the memory block that you provided in the writeBufferRect ");
        strcat(message, "method is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (env->IsSameObject(_bufferData, dataBlock)) {
        char *message = (char*)malloc(sizeof(char) * 163);
        strcpy(message, "The memory block that you have provided for the writeBufferRect method, is the same memory block of ");
        strcat(message, "the buffer that you are using to use the writeBufferRect method");
        showMessageError(env, message);
        return NULL;
    }
    jint lengthOffsetXYZSrcBuffer = env->GetArrayLength(offsetXYZDataBlock);
    jint lengthOffsetXYZDstBuffer = env->GetArrayLength(offsetXYZBuffer);
    jint lengthRegion = env->GetArrayLength(regionWrite);
    if (lengthOffsetXYZSrcBuffer != 3 || lengthOffsetXYZDstBuffer != 3 || lengthRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 842);
        strcpy(message, "The length of the offsetXYZDataBlock, offsetXYZBuffer and region arrays must be 3, which means that ");
        strcat(message, "they must contain 3 data, for the offsetXYZDataBlock and offsetXYZBuffer arrays the 3 data will be ");
        strcat(message, "specified in bytes and will indicate the offset of the region to be read from buffer to write it ");
        strcat(message, "in the dataBlock with their respective offset, if the region of the offset is to be specified in a 2D ");
        strcat(message, "region instead of 3D, it is enough that the last data of these 2 arrays is set to 0, the data for ");
        strcat(message, "the regionWrite array, the first data specifies the width in bytes, the second the height in rows and ");
        strcat(message, "the third the depth in layers, when you decide to work with a 2D region in the offsetXYZDataBlock ");
        strcat(message, "and offsetXYZBuffer arrays the third data in the regionWrite array must be adjusted with a 1, since you ");
        strcat(message, "would only be working with a single layer");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jint dataBlockSize = env->GetIntField(dataBlock, sizeBlockMemory);
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jint bufferDataSize;
    if (!_isSubBuffer) bufferDataSize = env->GetIntField(_bufferData, sizeBlockMemory);
    else bufferDataSize = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    jint *_offsetXYZDataBlock = env->GetIntArrayElements(offsetXYZDataBlock, JNI_FALSE);
    jint *_offsetXYZBuffer = env->GetIntArrayElements(offsetXYZBuffer, JNI_FALSE);
    jint *_region = env->GetIntArrayElements(regionWrite, JNI_FALSE);
    jint XDataBlock = _offsetXYZDataBlock[0];
    jint YDataBlock = _offsetXYZDataBlock[1];
    jint ZDataBlock = _offsetXYZDataBlock[2];
    jint XBuffer = _offsetXYZBuffer[0];
    jint YBuffer = _offsetXYZBuffer[1];
    jint ZBuffer = _offsetXYZBuffer[2];
    jint widthRegion = _region[0];
    jint rowsRegion = _region[1];
    jint layersRegion = _region[2];
    if (XDataBlock < 0 || YDataBlock < 0 || ZDataBlock < 0 || XBuffer < 0 || YBuffer < 0 || ZBuffer < 0 || widthRegion <= 0 ||
        rowsRegion <= 0 || layersRegion <= 0 || lengthColumnsPerRowInDataBlock <= 0 || sizeAreaDataBlock <= 0 ||
        lengthColumnsPerRowInBuffer <= 0 || sizeAreaBuffer <= 0) {
        char *message = (char*)malloc(sizeof(char) * 998);
        strcpy(message, "The data that you entered to the offsetXYZDataBlock array or to the offsetXYZBuffer array or to the ");
        strcat(message, "regionWrite array, at least one of the data is equal to or less than 0, in the previous 3 arrangements ");
        strcat(message, "the first 2 positions must be numbers greater or equal than 0, the third data for the offsetXYZDataBlock ");
        strcat(message, "and offsetXYZBuffer array is 0 if you plan to work with a 2D region, if you plan to work with a 3D ");
        strcat(message, "region this third data is to specify the number of layers that these 2 arrays will work with, and the ");
        strcat(message, "third data of the regionWrite array must be 1 if you plan to work with a 2D region with the ");
        strcat(message, "offsetXYZDataBlock and offsetXYZBuffer arrays or specify the number of layers you will work with if you ");
        strcat(message, "will use a 3D region with the offsetXYZDataBlock and offsetXYZBuffer arrays. The problem can also be ");
        strcat(message, "caused by the variables lengthColumnsPerRowInDataBlock, sizeAreaDataBlock,lengthColumnsPerRowsInBuffer ");
        strcat(message, "and sizeAreaBuffer, the value of these variables should neve be less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    if (((sizeAreaDataBlock < (rowsRegion * lengthColumnsPerRowInDataBlock)) || ((sizeAreaDataBlock % lengthColumnsPerRowInDataBlock) != 0))
        || ((sizeAreaBuffer < (rowsRegion * lengthColumnsPerRowInBuffer)) || ((sizeAreaBuffer % lengthColumnsPerRowInBuffer) != 0))) {
        char *message = (char*)malloc(sizeof(char) * 414);
        strcpy(message, "There is a problem with the writeBufferRect method because the sizeAreaDataBlock variable is less than the ");
        strcat(message, "multiplication of the second position of the regionRead array and of the lengthColumnsPerRowInDataBlock ");
        strcat(message, "variable or the sizeAreaDataBlock variable may not be multiple of lengthColumnsPerRowInBlock, the 2 possible ");
        strcat(message, "previous problems also occur with the lengthColumnsPerRowInBuffer and sizeAreaBuffer variables");
        showMessageError(env, message);
        return NULL;
    }
    if (lengthColumnsPerRowInBuffer < widthRegion || lengthColumnsPerRowInDataBlock < widthRegion) {
        char *message = (char*)malloc(sizeof(char) * 298);
        strcpy(message, "The number of bytes that are in a row of the area that will be written either from the memory block or ");
        strcat(message, "the buffer is less than the number you indicated in the first position of the regionWrite array, this ");
        strcat(message, "first position is to indicate the number of bytes it will have the area to write horizontally");
        showMessageError(env, message);
        return NULL;
    }
    jint offsetXDB = XDataBlock;
    jint offsetYDB = YDataBlock * lengthColumnsPerRowInDataBlock;
    jint offsetZDB = ZDataBlock * sizeAreaDataBlock;
    jint offsetXB = XBuffer;
    jint offsetYB = YBuffer * lengthColumnsPerRowInBuffer;
    jint offsetZB = ZBuffer * sizeAreaBuffer;
    if (((offsetXDB + offsetYDB + offsetZDB) + (widthRegion * rowsRegion * layersRegion)) > dataBlockSize ||
        ((offsetXB + offsetYB + offsetZB) + (widthRegion * rowsRegion * layersRegion)) > bufferDataSize) {
        char *message = (char*)malloc(sizeof(char) * 1164);
        strcpy(message, "The offset for the offsetXYZDataBlock array and/or the offsetXYZBuffer array that you entered exceeds ");
        strcat(message, "the size of the dataBlock memory block and the buffer, since the data you enter to the offsetXYZDataBlock ");
        strcat(message, "array will be multiplied with the data of the variables bytesPerDataInDataBlock and sizeAreaDataBlock of ");
        strcat(message, "the following way: the second position of the offsetXYZDataBlock array that represents the Y of the array ");
        strcat(message, "is multiplied with the variable bytesPerDataInDataBlock, the third position of the same array that ");
        strcat(message, "represents Z, is multiplied with the variable sizeAreaDataBlock and these 2 multiplications are added ");
        strcat(message, "with the X position of the array to then be added with the multiplication of all the positions of the ");
        strcat(message, "regionWrite array, the region arrays determines the area to be read (if the reading will be in 2D it ");
        strcat(message, "will be determined by the 3rd position of the region array whose value will be 1, or a volume in 3D ");
        strcat(message, "if the third value of the region array is greater than 1) and then be compared with the size of the ");
        strcat(message, "dataBlock memory block. The same operation applies to the offsetXYZBuffer array but with the variables ");
        strcat(message, "bytesPerDataInBuffer and sizeAreaBuffer");
        showMessageError(env, message);
        return NULL;
    }
    size_t __offsetXYZDataBlock[] = { (size_t)_offsetXYZDataBlock[0], (size_t)_offsetXYZDataBlock[1], (size_t)_offsetXYZDataBlock[2] };
    size_t __offsetXYZBuffer[] = { (size_t)_offsetXYZBuffer[0], (size_t)_offsetXYZBuffer[1], (size_t)_offsetXYZBuffer[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    void **Result = GetEnqueueWriteBufferRect(_currentCommandQueue, _currentBuffer, _currentMemory, isBlockingWrite, __offsetXYZBuffer,
    __offsetXYZDataBlock, __region, lengthColumnsPerRowInBuffer, sizeAreaBuffer,
    lengthColumnsPerRowInDataBlock, sizeAreaDataBlock);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
        jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
        jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("flotArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, bufferDataSize, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = bufferDataSize / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(bufferDataSize);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, bufferDataSize, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_copyBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jobject srcBuffer,
                                        jint offsetSrcBuffer, jint offsetDstBuffer, jint sizeCopy) {
    if (commandQueue == NULL || srcBuffer == NULL) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "There is a problem with the copyBuffer method, since the CommandQueue type object or the ");
        strcat(message, "srcBuffer or both are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentSrcBuffer = env->GetIntField(srcBuffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jobject _srcBufferData = env->GetObjectField(srcBuffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    jint _currentSrcMemory = env->GetIntField(_srcBufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1 || _currentSrcBuffer == -1 || _currentSrcMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 178);
        strcpy(message, "You cannot copy the contents of the srcBuffer to the destination buffer that you are using to call the copyBuffer ");
        strcat(message, "method, because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (env->IsSameObject(buffer, srcBuffer)) {
        char *message = (char*)malloc(sizeof(char) * 189);
        strcpy(message, "The srcBuffer and the destination buffer (with which you are currently working and calling the ");
        strcat(message, "copyBuffer method) are the same buffer and therefore the copyBuffer method cannot be completed");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jobject memorySrcBuffer = env->GetObjectField(srcBuffer, bufferData);
    jobject memoryDstBuffer = env->GetObjectField(buffer, bufferData);
    jboolean _isSubBuffer_SrcBuffer = env->GetBooleanField(srcBuffer, isSubBuffer);
    jboolean _isSubBuffer_DstBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jsize sizeBlockMemorySrcBuffer;
    jsize sizeBlockMemoryDstBuffer;
    if (!_isSubBuffer_DstBuffer) sizeBlockMemoryDstBuffer = env->GetIntField(memoryDstBuffer, sizeBlockMemory);
    else sizeBlockMemoryDstBuffer = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    if (!_isSubBuffer_SrcBuffer) sizeBlockMemorySrcBuffer = env->GetIntField(memorySrcBuffer, sizeBlockMemory);
    else sizeBlockMemorySrcBuffer = env->GetIntField(srcBuffer, sizeBlockMemorySubBuffer);
    if (sizeCopy > sizeBlockMemorySrcBuffer || (offsetSrcBuffer + sizeCopy) > sizeBlockMemorySrcBuffer ||
        sizeCopy > sizeBlockMemoryDstBuffer || (offsetDstBuffer + sizeCopy) > sizeBlockMemoryDstBuffer || offsetSrcBuffer < 0 ||
        offsetDstBuffer < 0 || sizeCopy < 0) {
        char *message = (char*)malloc(sizeof(char) * 532);
        strcpy(message, "The offset and/or size of the copy block that you are using in the copyBuffer method exceeds the memory ");
        strcat(message, "block size of the srcBuffer buffer and/or the destination buffer, the destination buffer is the ");
        strcat(message, "buffer you are using to access the copyBuffer method, so you should check if the size of the memory ");
        strcat(message, "block has not been exceeded in any of the 2 buffers in the process of copying the memory block, ");
        strcat(message, "there may also be a problem because some or all of the offsetSrcBuffer, offsetDstBuffer and sizeCopy ");
        strcat(message, "variables can have a negative value");
        showMessageError(env, message);
        return NULL;
    }
    jint _currentDstBuffer = env->GetIntField(buffer, currentBuffer);
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, sizeBlockMemoryDstBuffer, _flagsBlockMemory, _flagsMapMemory, -1);
    void **Result = GetEnqueueCopyBuffer(_currentCommandQueue, _currentSrcBuffer, _currentDstBuffer, offsetSrcBuffer, offsetDstBuffer,
                                         sizeCopy);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, sizeBlockMemoryDstBuffer, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = sizeBlockMemoryDstBuffer / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(sizeBlockMemoryDstBuffer);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, sizeBlockMemoryDstBuffer, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_copyBufferRect(JNIEnv *env, jobject buffer, jobject commandQueue, jobject srcBuffer,
                                            jintArray offsetXYZSrcBuffer, jintArray offsetXYZDstBuffer, jintArray regionCopy,
                                            jint lengthColumnsPerRowInSrcBuffer, jint sizeAreaSrcBuffer,
                                            jint lengthColumnsPerRowInDstBuffer, jint sizeAreaDstBuffer) {
    if (commandQueue == NULL || srcBuffer == NULL || offsetXYZSrcBuffer == NULL || offsetXYZDstBuffer == NULL || regionCopy == NULL) {
        char *message = (char*)malloc(sizeof(char) * 220);
        strcpy(message, "There is a problem with the copyBufferRect method because the CommandQueue object and/or the srcBuffer ");
        strcat(message, "and/or the offset array XYZSrcBuffer and/or the offset array XYZDstBuffer and/or the regionCopy array are ");
        strcat(message, "set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jint _currentSrcBuffer = env->GetIntField(srcBuffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jobject _srcBufferData = env->GetObjectField(srcBuffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    jint _currentSrcMemory = env->GetIntField(_srcBufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1 || _currentSrcBuffer == -1 || _currentSrcMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 182);
        strcpy(message, "You cannot copy the contents of the srcBuffer to the destination buffer that you are using to call the ");
        strcat(message, "copyBufferRect method, because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (env->IsSameObject(buffer, srcBuffer)) {
        char *message = (char*)malloc(sizeof(char) * 197);
        strcpy(message, "The srcBuffer and the destination buffer (with which you are currently working and calling the ");
        strcat(message, "copyBufferRect method) are the same buffer and therefore the copyBufferRect method cannot be completed");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOffsetXYZSrcBuffer = env->GetArrayLength(offsetXYZSrcBuffer);
    jsize sizeOffsetXYZDstBuffer = env->GetArrayLength(offsetXYZDstBuffer);
    jsize sizeRegion = env->GetArrayLength(regionCopy);
    if (sizeOffsetXYZSrcBuffer != 3 || sizeOffsetXYZDstBuffer != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 719);
        strcpy(message, "The length of the offsetXYZSrcBuffer, offsetXYZDstBuffer and regionCopy arrays must be 3, when you want to ");
        strcat(message, "make a 2D offset the third data of both arrays must be 0, to make a 3D offset here you must specify ");
        strcat(message, "the offset of the layer in which both the data block of the srcBuffer and the dstBuffer will be moved, ");
        strcat(message, "the 3 data of the region array are the following: the first data defines the width in bytes, the ");
        strcat(message, "second the height in rows and the third is the number of layers. The 3 data of the offsetXYZSrcBuffer ");
        strcat(message, "and offsetXYZDstBuffer arrays the numbers that are entered are in bytes, when in these 2 arrays you ");
        strcat(message, "decide to work in 2D the third data of the region array must be 1, because you are working with a ");
        strcat(message, "single layer");
        showMessageError(env, message);
        return NULL;
    }
    jint *_offsetXYZSrcBuffer = env->GetIntArrayElements(offsetXYZSrcBuffer, JNI_FALSE);
    jint *_offsetXYZDstBuffer = env->GetIntArrayElements(offsetXYZDstBuffer, JNI_FALSE);
    jint *_region = env->GetIntArrayElements(regionCopy, JNI_FALSE);
    jint XSrcBuffer = _offsetXYZSrcBuffer[0];
    jint YSrcBuffer = _offsetXYZSrcBuffer[1];
    jint ZSrcBuffer = _offsetXYZSrcBuffer[2];
    jint XDstBuffer = _offsetXYZDstBuffer[0];
    jint YDstBuffer = _offsetXYZDstBuffer[1];
    jint ZDstBuffer = _offsetXYZDstBuffer[2];
    jint widthRegion = _region[0];
    jint rowsRegion = _region[1];
    jint layersRegion = _region[2];
    if (XSrcBuffer < 0 || YSrcBuffer < 0 || ZSrcBuffer < 0 || XDstBuffer < 0 || YDstBuffer < 0 || ZDstBuffer < 0 || widthRegion <= 0 ||
        rowsRegion <= 0 || layersRegion <= 0 || lengthColumnsPerRowInSrcBuffer <= 0 || sizeAreaDstBuffer <= 0 ||
        lengthColumnsPerRowInSrcBuffer <= 0 || sizeAreaDstBuffer <= 0) {
        char *message = (char*)malloc(sizeof(char) * 983);
        strcpy(message, "The values for offsetXYZSrcBuffer and offsetXYZDstBuffer arrays cannot be negative numbers, the third value ");
        strcat(message, "can be 0 if you plan to work in a 2D region of both buffers, in the regionCopy array the first value will ");
        strcat(message, "be used to express the width of the lines in bytes, the second value is the height in lines and third value ");
        strcat(message, "is the number of layers of the region in which you will work, this last value of the regionCopy array will ");
        strcat(message, "be 1 if you decide to work in 2D with the offsetXYZSrcBuffer and offsetXYZDstBuffer arrays, if you decide ");
        strcat(message, "to work in 3D with the offsetXYZSrcBuffer and offsetXYZDstBuffer arrays the the last value of the ");
        strcat(message, "regionCopy array will be used to determine the number of layers of the 3D region array will be used to ");
        strcat(message, "determine the number of layers of the 3D reading. The problem can also be caused because the variables ");
        strcat(message, "lengthColumnsPerRowSrcBuffer, sizeAreaSrcBuffer, lengthColumnsPerRowDstBuffer and sizeAreaDstBuffer have a ");
        strcat(message, "value that is less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    if (((sizeAreaSrcBuffer < (rowsRegion * lengthColumnsPerRowInSrcBuffer)) || ((sizeAreaSrcBuffer % lengthColumnsPerRowInSrcBuffer) != 0)) ||
        ((sizeAreaDstBuffer < (rowsRegion * lengthColumnsPerRowInDstBuffer)) || ((sizeAreaDstBuffer % lengthColumnsPerRowInDstBuffer) != 0))) {
        char *message = (char*)malloc(sizeof(char) * 423);
        strcpy(message, "There is a problem with the copyBufferRect method because the sizeAreaSrcBuffer variable is less than the ");
        strcat(message, "multiplication of the second position of the regionCopy array and of the lengthColumnsPerRowInSrcBuffer ");
        strcat(message, "variable or the sizeAreaSrcBuffer variable may not be multiple of lengthColumnsPerRowInSrcBuffer, the 2 ");
        strcat(message, "possible previous problem also occur with the lengthColumnsPerRowInDstBuffer and sizeAreaDstBuffer ");
        strcat(message, "variables");
        showMessageError(env, message);
        return NULL;
    }
    if (lengthColumnsPerRowInDstBuffer < widthRegion || lengthColumnsPerRowInSrcBuffer < widthRegion) {
        char *message = (char*)malloc(sizeof(char) * 276);
        strcpy(message, "The number of bytes in each row of the area that will be copied from srcBuffer to dstBuffer is less than the ");
        strcat(message, "number you indicated in the first position of the regionCopy array, this first position is to indicate the ");
        strcat(message, "number of bytes that the area to copy will have horizontally");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jobject srcBufferData = env->GetObjectField(srcBuffer, bufferData);
    jobject dstBufferData = env->GetObjectField(buffer, bufferData);
    jboolean _isSubBuffer_srcBuffer = env->GetBooleanField(srcBuffer, isSubBuffer);
    jboolean _isSubBuffer_dstBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jsize sizeBlockMemorySrcBuffer;
    jsize sizeBlockMemoryDstBuffer;
    if (!_isSubBuffer_srcBuffer) sizeBlockMemorySrcBuffer = env->GetIntField(srcBufferData, sizeBlockMemory);
    else sizeBlockMemorySrcBuffer = env->GetIntField(srcBuffer, sizeBlockMemorySubBuffer);
    if (!_isSubBuffer_dstBuffer) sizeBlockMemoryDstBuffer = env->GetIntField(dstBufferData, sizeBlockMemory);
    else sizeBlockMemoryDstBuffer = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    jint offsetXSrcBuffer = XSrcBuffer;
    jint offsetYSrcBuffer = YSrcBuffer * lengthColumnsPerRowInSrcBuffer;
    jint offsetZSrcBuffer = ZSrcBuffer * sizeAreaSrcBuffer;
    jint offsetXDstBuffer = XDstBuffer;
    jint offsetYDstBuffer = YDstBuffer * lengthColumnsPerRowInDstBuffer;
    jint offsetZDstBuffer = ZDstBuffer * sizeAreaDstBuffer;
    if (((offsetXSrcBuffer + offsetYSrcBuffer + offsetZSrcBuffer) + (widthRegion * rowsRegion * layersRegion)) > sizeBlockMemorySrcBuffer ||
    ((offsetXDstBuffer + offsetYDstBuffer + offsetZDstBuffer) + (widthRegion * rowsRegion * layersRegion)) > sizeBlockMemoryDstBuffer) {
        char *message = (char*)malloc(sizeof(char) * 1081);
        strcpy(message, "There is a problem with the offset of the offsetXYZSrcBuffer array or with the offset of the ");
        strcat(message, "offsetXYZDstBuffer array, since the size of the offset combined with the area to be copied from the memory ");
        strcat(message, "block exceeds the size of the srcBuffer and/or buffer memory block destination, to determine if the size ");
        strcat(message, "of the memory block of the srcBuffer or the target buffer was exceeded, the following equations that are ");
        strcat(message, "the same for both offsets: the 2nd position of the offset array offsetXYZSrcBuffer is multiplied with ");
        strcat(message, "the variable lengthColumnsPerRowInSrcBuffer, the 3rd position of the same array it is multiplied with ");
        strcat(message, "the variable sizeAreaSrcBuffer, the result of these 2multiplications are added together with the 1st ");
        strcat(message, "position of the same array, and finally they are added with the multiplication of the values of the 3 ");
        strcat(message, "positions of the region array, the result should not be greater than the block of memory that has the ");
        strcat(message, "buffer srcBuffer, for the other offset arrays the same procedure above is performed, but using the ");
        strcat(message, "variables lengthColumnsPerRowInDstBuffer and sizeAreaDstBuffer");
        showMessageError(env, message);
        return NULL;
    }
    jint _currentDstBuffer = env->GetIntField(buffer, currentBuffer);
    size_t __offsetXYZSrcBuffer[] = { (size_t)_offsetXYZSrcBuffer[0], (size_t)_offsetXYZSrcBuffer[1], (size_t)_offsetXYZSrcBuffer[2] };
    size_t __offsetXYZDstBuffer[] = { (size_t)_offsetXYZDstBuffer[0], (size_t)_offsetXYZDstBuffer[1], (size_t)_offsetXYZDstBuffer[2] };
    size_t __region[] = {(size_t) _region[0], (size_t) _region[1], (size_t) _region[2]};
    void **Result = GetEnqueueCopyBufferRect(_currentCommandQueue, _currentSrcBuffer, _currentDstBuffer, __offsetXYZSrcBuffer,
                                             __offsetXYZDstBuffer, __region, lengthColumnsPerRowInSrcBuffer, sizeAreaSrcBuffer,
                                             lengthColumnsPerRowInDstBuffer, sizeAreaDstBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
        jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
        jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, sizeBlockMemoryDstBuffer, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = sizeBlockMemoryDstBuffer / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(sizeBlockMemoryDstBuffer);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, sizeBlockMemoryDstBuffer, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_fillBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jobject patternFill,
                                        jint sizeFillPattern) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer was ");
        strcat(message, "released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || patternFill == NULL) {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "The fillBuffer method has a problem because the CommandQueue type object or the buffer fill pattern ");
        strcat(message, "were set to null, check if one or both objects are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message,"The buffer cannot be filled with the fill pattern because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeFillPattern <= 0) {
        char *message = (char*)malloc(sizeof(char) * 129);
        strcpy(message, "The filling of the buffer with the filling pattern cannot be done because the sizeFillPattern variable is ");
        strcat(message, "less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jsize _sizeBlockMemory;
    if (!_isSubBuffer) _sizeBlockMemory = env->GetIntField(_bufferData, sizeBlockMemory);
    else _sizeBlockMemory = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    if (sizeFillPattern != 1 && sizeFillPattern != 2 && sizeFillPattern != 4 && sizeFillPattern != 8 && sizeFillPattern != 16 &&
        sizeFillPattern != 32 && sizeFillPattern != 64 && sizeFillPattern != 128) {
        char *message = (char*)malloc(sizeof(char) * 204);
        strcpy(message, "The filling of the buffer with the filling pattern cannot be performed, because the size you provided for ");
        strcat(message, "the size of the filling pattern is not one of the following numbers 1, 2, 4, 8, 16, 32, 64 and 128");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeFillPattern > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 178);
        strcpy(message, "The filling of the buffer with the design pattern that you provided cannot be done, because the size of the ");
        strcat(message, "fill pattern is larger than the size of the memory block of the buffer");
        showMessageError(env, message);
        return NULL;
    }
    if ((_sizeBlockMemory % sizeFillPattern) != 0) {
        char *message = (char*)malloc(sizeof(char) * 205);
        strcpy(message, "The filling of the buffer with the filling pattern cannot be done, because the size of the filling pattern ");
        strcat(message, "that you provided is not multiple of the size of the memory block that was allocated to the buffer");
        showMessageError(env, message);
        return NULL;
    }
    jclass String = env->FindClass("java/lang/String");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Long = env->FindClass("java/lang/Long");
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass Character = env->FindClass("java/lang/Character");
    jclass Object = env->FindClass("java/lang/Object");
    jclass Class = env->FindClass("java/lang/Class");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
    jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
    jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
    jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jobject objectClass = env->CallObjectMethod(patternFill, getClass);
    jboolean _isArray = env->CallBooleanMethod(objectClass, isArray);
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(_bufferData, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(_bufferData, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    void **Result;
    if (!_isArray) {
        if (env->IsInstanceOf(patternFill, String)) {
            cl_char *string = (cl_char*)env->GetStringUTFChars((jstring)patternFill, JNI_FALSE);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, string, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Integer)) {
            cl_int value = env->CallIntMethod((jobject)patternFill, intValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Short)) {
            cl_short value = env->CallShortMethod((jobject)patternFill, shortValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Long)) {
            cl_long value = env->CallLongMethod((jobject)patternFill, longValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Float)) {
            cl_float value = env->CallFloatMethod((jobject)patternFill, floatValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Double)) {
            cl_double value = env->CallDoubleMethod((jobject)patternFill, doubleValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf(patternFill, Byte)) {
            cl_uchar value = env->CallByteMethod((jobject)patternFill, byteValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf((jobject)patternFill, Character)) {
            cl_char value = env->CallCharMethod((jobject)patternFill, charValue);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (env->IsInstanceOf((jobject)patternFill, String)) {
            cl_char *value = (cl_char*)env->GetStringUTFChars((jstring)patternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, &value, sizeFillPattern, NULL, _sizeBlockMemory);
        } else {
            char *message = (char*)malloc(sizeof(char) * 485);
            strcpy(message, "The buffer cannot be filled with the fill pattern because the data you provided as a fill pattern is ");
            strcat(message, "incorrect, it can only provide data of the primitive types such as int, short, float, double, long, ");
            strcat(message, "byte, and char, in addition to You can also provide data of type Integer, Short, Float, Double, ");
            strcat(message, "Long, Byte, Character and String, in addition you can also provide arrays of the types of data ");
            strcat(message, "mentioned above, any other type of data will not be accepted as a fill pattern for the buffer");
            showMessageError(env, message);
            return NULL;
        }
    } else {
        jarray arrayPatternFill = (jarray) patternFill;
        jstring nameClass = (jstring) env->CallObjectMethod(objectClass, getName);
        jsize sizeArray = env->GetArrayLength(arrayPatternFill);
        if (sizeArray > 16) {
            char *message = (char*)malloc(sizeof(char) * 179);
            strcpy(message, "The length of the array you are providing to be used as the buffer filling pattern exceeds the ");
            strcat(message, "recommended size, the length of this array must be a minimum of 1 to a maximum of 16");
            showMessageError(env, message);
            return NULL;
        }
        const char *_nameClass = env->GetStringUTFChars(nameClass, NULL);
        if (strcmp(_nameClass, "[I") == 0) {
            cl_int *valueInt = env->GetIntArrayElements((jintArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueInt, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[S") == 0) {
            cl_short *valueShort = env->GetShortArrayElements((jshortArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueShort, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[F") == 0) {
            cl_float *valueFloat = env->GetFloatArrayElements((jfloatArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueFloat, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[D") == 0) {
            cl_double *valueDouble = env->GetDoubleArrayElements((jdoubleArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueDouble, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[J") == 0) {
            cl_long *valueLong = env->GetLongArrayElements((jlongArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueLong, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[B") == 0) {
            cl_uchar *valueByte = (cl_uchar *) env->GetByteArrayElements((jbyteArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueByte, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[C") == 0) {
            cl_char *valueChar = (cl_char *) env->GetCharArrayElements((jcharArray)arrayPatternFill, NULL);
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueChar, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Integer;") == 0) {
            jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
            cl_int valueInt[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray) arrayPatternFill, position);
                valueInt[position] = env->CallIntMethod(object, intValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueInt, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Short;") == 0) {
            jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
            cl_short valueShort[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray)arrayPatternFill, position);
                valueShort[position] = env->CallShortMethod(object, shortValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueShort, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Long;") == 0) {
            jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
            cl_long valueLong[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray)arrayPatternFill, position);
                valueLong[position] = env->CallLongMethod(object, longValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueLong, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Float;") == 0) {
            jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
            cl_float valueFloat[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray)arrayPatternFill, position);
                valueFloat[position] = env->CallFloatMethod(object, floatValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueFloat, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Double;") == 0) {
            jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
            cl_double valueDouble[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray)arrayPatternFill, position);
                valueDouble[position] = env->CallDoubleMethod(object, doubleValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueDouble, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Byte;") == 0) {
            jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
            cl_uchar valueByte[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray)arrayPatternFill, position);
                valueByte[position] = (cl_uchar) env->CallByteMethod(object, byteValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueByte, sizeFillPattern, NULL, _sizeBlockMemory);
        } else if (strcmp(_nameClass, "[Ljava.lang.Character;") == 0) {
            jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
            cl_char valueChar[sizeArray];
            for (jint position = 0; position < sizeArray; position++) {
                jobject object = env->GetObjectArrayElement((jobjectArray) arrayPatternFill, position);
                valueChar[position] = (cl_char) env->CallCharMethod(object, charValue);
            }
            Result = GetEnqueueFillBuffer(_currentCommandQueue, _currentBuffer, valueChar, sizeFillPattern, NULL, _sizeBlockMemory);
        } else {
            char *message = (char*)malloc(sizeof(char) * 389);
            strcpy(message, "Buffer filling with the design pattern you provided cannot be done, because the type of array you provided ");
            strcat(message, "as a fill pattern is not of a supported data type, the only data type you can use to generate an array for ");
            strcat(message, "the pattern of filled are data type primitive as int, short, long, float, double, byte, char and of the ");
            strcat(message, "object type are Integer, Short, Long, Float, Double, Byte and Character");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = _sizeBlockMemory / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_mapBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jboolean isBlockingMap,
                                       jlong flagsMapBuffer, jint offsetMap, jint sizeMap) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer ");
        strcat(message, "was released");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 81);
        strcpy(message, "The mapBuffer method has a problem because the CommandQueue object is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "The buffer cannot be mapped because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jlong flagsTemp = flagsMapBuffer;
    if ((flagsMapBuffer & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsMapBuffer & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsMapBuffer & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if (flagsTemp != 0) {
    char *message = (char*)malloc(sizeof(char) * 177);
        strcpy(message, "The flag value for the mapBuffer method is incorrect, you can only use the following values:\n");
        strcat(message, "Buffer.MAP_BUFFER_READ\nBuffer.MAP_BUFFER_WRITE\nBuffer.MAP_WRITE_INVALIDATE_REGION");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsMapBuffer & (1 << 2)) == 1 << 2 && (((flagsMapBuffer & (1 << 0)) == 1 << 0) || ((flagsMapBuffer & (1 << 1)) == 1 << 1))) {
        char *message = (char*)malloc(sizeof(char) * 295);
        strcpy(message, "Buffer mapping cannot be done because you are using the Buffer.MAP_WRITE_INVALIDATE_REGION flag with any ");
        strcat(message, "of the Buffer.MAP_BUFFER_READ and Buffer.MAP_BUFFER_WRITE flags or both, and this is causing a conflict ");
        strcat(message, "because the Buffer.MAP_WRITE_INVALIDATE_REGION flag is incompatible with other 2 flags");
        showMessageError(env, message);
        return NULL;
    }
    if (offsetMap < 0 || sizeMap <= 0) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "The offsetMap variable cannot have a negative value and the sizeMap variable cannot have a value ");
        strcat(message, "less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jsize _sizeBlockMemory;
    if (!_isSubBuffer) _sizeBlockMemory = env->GetIntField(_bufferData, sizeBlockMemory);
    else _sizeBlockMemory = env->GetIntField(buffer, sizeBlockMemorySubBuffer);
    if (sizeMap > _sizeBlockMemory || (offsetMap + sizeMap) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 192);
        strcpy(message, "The value of the sizeMap variable is larger than the size of the buffer memory block, the sum of ");
        strcat(message, "the offsetMap and sizeMap variables may also be larger than the size of the buffer memory block");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetEnqueueMapBuffer(_currentCommandQueue, _currentBuffer, isBlockingMap, flagsMapBuffer, offsetMap, sizeMap);
    if (*(jint*)Result[1] == CL_SUCCESS){
        jfieldID _flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
        env->SetLongField(buffer, _flagMapBuffer, flagsMapBuffer);
        return newEvent(env, buffer, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_unmapBuffer(JNIEnv *env, jobject buffer, jobject commandQueue) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 93);
        strcpy(message, "You cannot use the unmapBuffer method because the CommandQueue object was set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 81);
        strcpy(message, "You cannot use the unmapBuffer method because the buffer you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot use the unmapBuffer method because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
    jlong _flagMapBuffer = env->GetLongField(buffer, flagMapBuffer);
    if ((_flagMapBuffer & (1 << 0)) == 1 << 0 || (_flagMapBuffer & (1 << 1)) == 1 << 1 || (_flagMapBuffer & (1 << 2)) == 1 << 2) {
        jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
        jobject _contextBuffer = env->GetObjectField(buffer, contextBuffer);
        if (env->IsSameObject(_contextBuffer, _contextCommandQueue)) {
            void **Result = GetEnqueueUnmapBuffer(_currentCommandQueue, _currentBuffer);
            if (*(jint*)Result[1] == CL_SUCCESS) {
                env->SetLongField(buffer, flagMapBuffer, (jlong)0);
                return newEvent(env, buffer, commandQueue);
            } else {
                showMessageError(env, (char*)Result[0]);
                return NULL;
            }
        } else {
            char *message = (char*)malloc(sizeof(char) * 154);
            strcpy(message, "You cannot use the unmapBuffer method because the context in which the buffer was created and the ");
            strcat(message, "CommandQueue object were not created in the same context");
            showMessageError(env, message);
            return NULL;
        }
    } else {
        char *message = (char*)malloc(sizeof(char) * 76);
        strcpy(message, "You cannot use the unmapBuffer method because the buffer has not been mapped");
        showMessageError(env, message);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_buffer_Buffer_migrateBuffer(JNIEnv *env, jobject buffer, jobject commandQueue, jobjectArray buffers,
                                           jint flagsMigrateBuffers) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 87);
        strcpy(message, "Cannot perform buffer migration because the CommandQueue object was set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 73);
        strcpy(message, "You cannot migrate the buffer because the buffer you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot migrate the buffer because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsMigrate = flagsMigrateBuffers;
    if ((flagsMigrate & (1 << 0)) == 1 << 0) flagsMigrate -= 1 << 0;
    if ((flagsMigrate & (1 << 1)) == 1 << 1) flagsMigrate -= 1 << 1;
    if (flagsMigrate != 0) {
        char *message = (char*)malloc(sizeof(char) * 244);
        strcpy(message, "You cannot perform the buffer migration because the flag you are using to perform the migration is ");
        strcat(message, "incorrect, you can only use one or both of the following values:\nBuffer.MIGRATE_BUFFER_OBJECT_HOST\n");
        strcat(message, "Buffer.MIGRATE_BUFFER_OBJECT_CONTENT_UNDEFINED");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jobjectArray _buffers;
    jint sizeListBuffers;
    if (buffers == NULL) _buffers = env->NewObjectArray(1, Buffer, buffer);
    else {
        jsize sizeList = env->GetArrayLength(buffers);
        _buffers = env->NewObjectArray(sizeList + 1, Buffer, NULL);
        jint position = 0;
        for ( ; position < sizeList; position++) {
            jobject _buffer = env->GetObjectArrayElement(buffers, position);
            _currentBuffer = env->GetIntField(_buffer, currentBuffer);
            if (_currentBuffer == -1) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot migrate the current buffer and the list of buffers you have provided, since at least one ");
                strcat(message, "of the buffers in the list of buffers is invalid");
                showMessageError(env, message);
                return NULL;
            }
            env->SetObjectArrayElement(_buffers, position, _buffer);
        }
        env->SetObjectArrayElement(_buffers, position, buffer);
        for (jint position1 = 0; position1 < sizeList; position1++) {
            jobject buffer1 = env->GetObjectArrayElement(_buffers, position1);
            jobject _contextBuffer1 = env->GetObjectField(buffer1, contextBuffer);
            for (jint position2 = position1 + 1; position2 <= sizeList; position2++) {
                jobject buffer2 = env->GetObjectArrayElement(_buffers, position2);
                if (env->IsSameObject(buffer1, buffer2)) {
                    char *message = (char*)malloc(sizeof(char) * 195);
                    strcpy(message, "You cannot migrate the current buffer and the list of buffers you provided, because at least ");
                    strcat(message, "two buffers are the same, or one of them is equal to the buffer you are using to perform the ");
                    strcat(message, "migration");
                    showMessageError(env, message);
                    return NULL;
                }
                jobject _contextBuffer2 = env->GetObjectField(buffer2, contextBuffer);
                if (!env->IsSameObject(_contextBuffer1, _contextCommandQueue) || !env->IsSameObject(_contextBuffer2, _contextCommandQueue)) {
                    char *message = (char*)malloc(sizeof(char) * 275);
                    strcpy(message, "You cannot migrate the current buffer and the list of buffers you provided, because at least ");
                    strcat(message, "one of the buffers in the buffers list or the buffer you are using to perform the migration, ");
                    strcat(message, "it's were not created in the same context in which it was created the CommandQueue object");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
    }
    sizeListBuffers = env->GetArrayLength(_buffers);
    jint listPositionBuffers[sizeListBuffers];
    for (jint position = 0; position < sizeListBuffers; position++) {
        jobject _buffer = env->GetObjectArrayElement(_buffers, position);
        listPositionBuffers[position] = env->GetIntField(_buffer, currentBuffer);
    }
    sizeListBuffers++;
    void **Result = GetEnqueueMigrationBuffer(_currentCommandQueue, listPositionBuffers, sizeListBuffers, flagsMigrateBuffers);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_setReleaseCallback(JNIEnv *env, jobject buffer, jobject callbackBuffer) {
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 88);
        strcpy(message, "You cannot use the setReleaseCallback method because the buffer you are using is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = SetBufferDestructorCallback(env, _currentBuffer, callbackBuffer, buffer);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_buffer_Buffer_releaseBuffer(JNIEnv *env, jobject buffer) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer was ");
        strcat(message, "released");
        showMessageError(env, message);
        return;
    }
    jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
    jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
    jboolean _isSubBuffer = env->GetBooleanField(buffer, isSubBuffer);
    jint _currentBufferRegion = env->GetIntField(buffer, currentBufferRegion);
    void **Result = GetReleaseBuffer(_currentBuffer, _isSubBuffer, _currentBufferRegion);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jobject _dataMemory = env->GetObjectField(_bufferData, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        env->SetObjectField(_bufferData, dataMemory, _dataMemory);
        env->SetObjectField(buffer, bufferData, _bufferData);
        env->SetIntField(buffer, currentBuffer, -1);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL jstring Java_com_draico_asvappra_opencl_memory_buffer_Buffer_toString(JNIEnv *env, jobject buffer) {
    jclass Buffer = env->GetObjectClass(buffer);
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentBuffer == -1 || _currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "The buffer you are using is invalid because this buffer was released or the memory block of the buffer was ");
        strcat(message, "released");
        showMessageError(env, message);
        return NULL;
    }
    return bufferToString(env, buffer);
}
JNICALL jobject Java_com_draico_asvappra_opencl_listeners_Event_createEvent(JNIEnv *env, jclass event, jobject context, jobject commandQueue) {
    if (context == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 140);
        strcpy(message, "There was a problem with the createEvent method, because the context object or the commandQueue ");
        strcat(message, "object or both objects are set to null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentContext == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "The event cannot be created because the context and/or the CommandQueue object is or are invalid");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCreateEvent(_currentContext);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID isEventCreatedManually = env->GetFieldID(event, "isEventCreatedManually", "Z");
        jobject _event = newEvent(env, context, commandQueue);
        env->SetBooleanField(_event, isEventCreatedManually, JNI_TRUE);
        return _event;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_listeners_Event_setEventStatus(JNIEnv *env, jobject event, jint executionStatus) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The event you are trying to use is invalid, as it was released with the release method or the operation to ");
        strcat(message, "which this event was related ended");
        showMessageError(env, message);
        return;
    }
    jmethodID getExecutionStatus = env->GetMethodID(Event, "getExecutionStatus", "()I");
    jint _executionStatus = env->CallIntMethod(event, getExecutionStatus);
    if (_executionStatus == 0 || _executionStatus <= -1) {
        char *message = (char*)malloc(sizeof(char) * 499);
        strcpy(message, "You cannot change the status of the current event because the event the operation that is linked to the ");
        strcat(message, "event has already ended, or there may also have been a problem during the operation linked to the event, ");
        strcat(message, "you can check if there was a problem with the getExecutionStatus method and check if returns a negative ");
        strcat(message, "number, if the previous method returns a negative value then you must use the CheckStatusEvents class ");
        strcat(message, "to detect and correct the problemand restart the operation of the conflicting event");
        showMessageError(env, message);
        return;
    }
    jint data = executionStatus;
    if ((executionStatus & (1 << 0)) == 1 << 0) data -= 1 << 0;
    if ((executionStatus & (1 << 1)) == 1 << 1) data -= 1 << 1;
    if ((executionStatus & (1 << 2)) == 1 << 2) data -= 1 << 2;
    if ((executionStatus & (1 << 3)) == 1 << 3) data -= 1 << 3;
    if (data != 0) {
        char *message = (char*)malloc(sizeof(char) * 385);
        strcpy(message, "In the method setEventStatus can only use the following values for executionStatus variable:\n");
        strcat(message, "Event.COMMAND_EXECUTION_STATUS_COMPLETE\nEvent.COMMAND_EXECUTION_STATUS_RUNNING\n");
        strcat(message, "Event.COMMAND_EXECUTION_STATUS_SUBMITTED\nEvent.COMMAND_EXECUTION_STATUS_QUEUED\n");
        strcat(message, "The last Event.COMMAND_EXECUTION_STATUS_WAIT value is used to find potential problems with the ");
        strcat(message, "aid of the class CheckStatusEvents");
        showMessageError(env, message);
        return;
    }
    void **Result = SetEventStatus(_currentEvent, executionStatus);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID isSetStatusEvent = env->GetFieldID(Event, "isSetStatusEvent", "Z");
        env->SetBooleanField(event, isSetStatusEvent, JNI_TRUE);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_listeners_Event_waitForEvents(JNIEnv *env, jobject event, jobjectArray listEvents) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which this ");
        strcat(message, "event was related was completed");
        showMessageError(env, message);
        return;
    }
    jmethodID getExecutionStatus = env->GetMethodID(Event, "getExecutionStatus", "()I");
    jint executionStatus = env->CallIntMethod(event, getExecutionStatus);
    if (executionStatus == 0 || executionStatus == -1) {
        char *message = (char*)malloc(sizeof(char) * 370);
        strcpy(message, "You cannot use the waitForEvents method because the current event you are using has a problem or has ");
        strcat(message, "completed the operation to which it is linked, if the event has a problem you can check it with the ");
        strcat(message, "getExecutionStatus method, if the return value is a negative number then use the CheckStatusEvents ");
        strcat(message, "class to check the error and correct the operation linked to the event");
        showMessageError(env, message);
        return;
    }
    jsize sizeListEvents;
    if (listEvents == NULL) {
        char *message = (char*)malloc(sizeof(char) * 156);
        strcpy(message, "The waitForEvents method cannot be executed because the event list was set to a null value, so there are no ");
        strcat(message, "events to which its execution has to be expected");
        showMessageError(env, message);
        return;
    } else sizeListEvents = env->GetArrayLength(listEvents);
    if (sizeListEvents == 0) {
        char *message = (char*)malloc(sizeof(char) * 75);
        strcpy(message, "The waitForEvents method cannot be executed because the event list is empty");
        showMessageError(env, message);
        return;
    }
    jfieldID contextEvent = env->GetFieldID(Event, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextEvent = env->GetObjectField(event, contextEvent);
    for (jint position = 0; position < sizeListEvents; position++) {
        jobject _event = env->GetObjectArrayElement(listEvents, position);
        jobject contextListEvent = env->GetObjectField(_event, contextEvent);
        if (!env->IsSameObject(_contextEvent, contextListEvent)) {
            char *message = (char*)malloc(sizeof(char) * 411);
            strcpy(message, "There is a problem with the event list that you provided in the waitForEvents method, because at ");
            strcat(message, "least one of the events in the event list was not created in the same context of the event you ");
            strcat(message, "are using to call the waitForEvents method, so that the current event wait for the operations ");
            strcat(message, "linked to that list of events to conclude and then conclude the operation that is linked to the ");
            strcat(message, "event you are currently using");
            showMessageError(env, message);
            return;
        }
        jint executionStatus = env->CallIntMethod(_event, getExecutionStatus);
        if (executionStatus == 0 || executionStatus <= -1) {
            char *message = (char*)malloc(sizeof(char) * 165);
            strcpy(message, "You cannot use the waitForEvents method because any of the events in the event list you provided ");
            strcat(message, "have a problem or have completed the operation to which it is linked");
            showMessageError(env, message);
            return;
        }
    }
    jint *positionListEvents = (jint *) malloc(sizeof(jint) * sizeListEvents);
    for (jint position = 0; position < sizeListEvents; position++) {
    positionListEvents[position] = env->GetIntField(event, currentEvent);
    }
    void **Result = GetWaitForEvents(sizeListEvents, positionListEvents);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_listeners_Event_setEventCallback(JNIEnv *env, jobject event, jint executionStatus, jobject callbackEvent) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which this ");
        strcat(message, "event was related was completed");
        showMessageError(env, message);
        return;
    }
    jmethodID getExecutionStatus = env->GetMethodID(Event, "getExecutionStatus", "()I");
    jint _executionStatus = env->CallIntMethod(event, getExecutionStatus);
    if (_executionStatus <= -1 || _executionStatus == 3) {
        char *message = (char*)malloc(sizeof(char) * 289);
        strcpy(message, "You cannot use the setEventCallback method with the event you are using, because this event is queue or has ");
        strcat(message, "a problem with the operations to which this event is linked, use the CheckStatusEvents class to check the ");
        strcat(message, "type of error to correct the operation problem to which the event is linked");
        showMessageError(env, message);
        return;
    }
    jint data = executionStatus;
    if ((data & (1 << 0)) == 1 << 0) data -= 1 << 0;
    if ((data & (1 << 1)) == 1 << 1) data -= 1 << 1;
    if ((data & (1 << 2)) == 1 << 2) data -= 1 << 2;
    if (data != 0) {
        char *message = (char*)malloc(sizeof(char) * 328);
        strcpy(message, "The CallbackEvent event cannot be adjusted, because the value you provided for the executionStatus ");
        strcat(message, "variable is not allowed or you are entering 2 or more allowed data, you can only use one of the following ");
        strcat(message, "values:\nEvent.COMMAND_EXECUTION_STATUS_COMPLETE\nEvent.COMMAND_EXECUTION_STATUS_RUNNING\n");
        strcat(message, "Event. EXECUTION_STATUS_SUBMITTED");
        showMessageError(env, message);
        return;
    }
    void **Result = SetEventCallback(env, event, executionStatus, callbackEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL jobject Java_com_draico_asvappra_opencl_listeners_Event_markerWithWaitListEvent(JNIEnv *env, jobject event, jobject commandQueue,
    jobjectArray waitListEvent) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which this ");
        strcat(message, "event was related was completed");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getExecutionStatus = env->GetMethodID(Event, "getExecutionStatus", "()I");
    jint executionStatus = env->CallIntMethod(event, getExecutionStatus);
    if (executionStatus == 0 || executionStatus <= -1) {
        char *message = (char*)malloc(sizeof(char) * 263);
        strcpy(message, "You cannot use the markerWithWaitListEvent method because the event you are using has already completed the ");
        strcat(message, "process to which it is related, so you must use another event that has not completed the process to which ");
        strcat(message, "that event is related, or the event have a problem");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || waitListEvent == NULL) {
        char *message = (char*)malloc(sizeof(char) * 146);
        strcpy(message, "The markerWithWaitList method has a problem, because the object of type CommandQueue or the list of ");
        strcat(message, "events or both objects are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jsize lengthListEvent = env->GetArrayLength(waitListEvent);
    if (lengthListEvent == 0) {
        char *message = (char*)malloc(sizeof(char) * 134);
        strcpy(message, "The length of the waitListEvent list that you provided to the markerWithWaitListEvent method is 0, ");
        strcat(message, "at least it must have a valid event");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextEvent = env->GetFieldID(Event, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 97);
        strcpy(message, "The markerWithWaitListEvents method cannot be executed because the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    for (jint position = 0; position < lengthListEvent; position++) {
        jobject _event = env->GetObjectArrayElement(waitListEvent, position);
        if (env->IsSameObject(event, _event)) {
            char *message = (char*)malloc(sizeof(char) * 304);
            strcpy(message, "The marketWithWaitListEvent method cannot be executed because some of the events in the event ");
            strcat(message, "list that you provided is the event you are using to call the marketWithWaitListEvent method, ");
            strcat(message, "you can only include other events in the list that you want to finish executing before the current ");
            strcat(message, "event be executed");
            showMessageError(env, message);
            return NULL;
        }
        _currentEvent = env->GetIntField(_event, currentEvent);
        if (_currentEvent == -1) {
            char *message = (char*)malloc(sizeof(char) * 146);
            strcpy(message, "You cannot use the marketWitWaitListEvent method because some of the events in the event list you ");
            strcat(message, "provided have at least one event that is invalid");
            showMessageError(env, message);
            return NULL;
        }
        executionStatus = env->CallIntMethod(_event, getExecutionStatus);
        if (executionStatus == 0 || executionStatus == -1) {
            char *message = (char*)malloc(sizeof(char) * 362);
            strcpy(message, "You cannot use the marketWithWaitListEvent method because some of the events in the event list that ");
            strcat(message, "you provided to the marketWithWaitListEvent method have terminated the operation or there is a ");
            strcat(message, "problem with the operation to which the event is linked, if there was a problem then you should use ");
            strcat(message, "the CheckStatusEvents class to determine the problem and correct it");
            showMessageError(env, message);
            return NULL;
        }
        jobject _contextEvent = env->GetObjectField(_event, contextEvent);
        if (!env->IsSameObject(_contextCommandQueue, _contextEvent)) {
            char *message = (char*)malloc(sizeof(char) * 213);
            strcpy(message, "The marketWithWaitListEvent method cannot be executed because some of the events or all the events ");
            strcat(message, "in the event list that you provided do not belong to the same context in which the CommandQueue ");
            strcat(message, "object was created");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint *positionListEvent = (jint *) malloc(sizeof(jint) * lengthListEvent);
    for (jint position = 0; position < lengthListEvent; position++) {
        jobject event = env->GetObjectArrayElement(waitListEvent, position);
        positionListEvent[position] = env->GetIntField(event, currentEvent);
    }
    void **Result = GetEnqueueMarkerWithWaitList(_currentCommandQueue, positionListEvent, lengthListEvent);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, event, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_listeners_Event_barrierWithWaitListEvent(JNIEnv *env, jobject event, jobject commandQueue,
                                                     jobjectArray waitListEvent) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which this ");
        strcat(message, "event was related was completed");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getExecutionStatus = env->GetMethodID(Event, "getExecutionStatus", "()I");
    jint executionStatus = env->CallIntMethod(event, getExecutionStatus);
    if (executionStatus == 0 || executionStatus <= -1) {
        char *message = (char*)malloc(sizeof(char) * 216);
        strcpy(message, "The barrierWithWaitListEvent method cannot be executed, because the operation associated with the event ");
        strcat(message, "(which you are using to call the barrierWithWaitListEvent method) has been completed or the event have ");
        strcat(message, "a problem");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || waitListEvent == NULL) {
        char *message = (char*)malloc(sizeof(char) * 197);
        strcpy(message, "The barrierWithWaitListEvent method has a problem, because the CommandQueue type object or the event ");
        strcat(message, "list is set to a null value, although it could also be that both objects are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeListEvent = env->GetArrayLength(waitListEvent);
    if (sizeListEvent == 0) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "The length of the waitListEvent list that I provided to the barrierWithWaitListEvent method is 0, ");
        strcat(message, "at least it must have a valid event");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextEvent = env->GetFieldID(Event, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "The barrierWaitListEvent method cannot be executed, because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    for (jint position = 0; position < sizeListEvent; position++) {
        jobject _event = env->GetObjectArrayElement(waitListEvent, position);
        if (env->IsSameObject(event, _event)) {
            char *message = (char*)malloc(sizeof(char) * 179);
            strcpy(message, "The barrierWithWaitListEvent method cannot be executed, because the list of events you provided cannot ");
            strcat(message, "include the event you are using to call the barrarierWithWaitListEvent event");
            showMessageError(env, message);
            return NULL;
        }
        _currentEvent = env->GetIntField(_event, currentEvent);
        if (_currentEvent == -1) {
            char *message = (char*)malloc(sizeof(char) * 127);
            strcpy(message, "You cannot use the barrierWithWaitListEvent method because at least one of the events in the event ");
            strcat(message, "list you provided is invalid");
            showMessageError(env, message);
            return NULL;
        }
        executionStatus = env->CallIntMethod(_event, getExecutionStatus);
        if (executionStatus == 0) {
            char *message = (char*)malloc(sizeof(char) * 321);
            strcpy(message, "The barrierWithWaitListEvent method cannot be executed, because one or more of the events in the list ");
            strcat(message, "of events you provided has completed the process or have a problem to which they are related, you can ");
            strcat(message, "only include events to the list of events that have not yet completed the process to which they are ");
            strcat(message, "related");
            showMessageError(env, message);
            return NULL;
        }
        jobject _contextEvent = env->GetObjectField(_event, contextEvent);
        if (!env->IsSameObject(_contextCommandQueue, _contextEvent)) {
            char *message = (char*)malloc(sizeof(char) * 199);
            strcpy(message, "The barrierWithWaitListEvent method cannot be executed, because one or more of the events in the event ");
            strcat(message, "list you provided do not belong to the same context in which the CommandQueue object was created");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint *positionWaitListEvents = (jint*)malloc(sizeof(jint) * sizeListEvent);
    for (jint position = 0; position < sizeListEvent; position++) {
        jobject _event = env->GetObjectArrayElement(waitListEvent, position);
        positionWaitListEvents[position] = env->GetIntField(_event, currentEvent);
    }
    void **Result = GetEnqueueBarrierWithWaitList(_currentCommandQueue, positionWaitListEvents, sizeListEvent);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, event, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_listeners_Event_getCommandQueue(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return NULL;
    }
    return env->GetObjectField(event, commandQueue);
}
JNICALL jobject Java_com_draico_asvappra_opencl_listeners_Event_getContext(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID context = env->GetFieldID(Event, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return NULL;
    }
    return env->GetObjectField(event, context);
}
JNICALL void Java_com_draico_asvappra_opencl_listeners_Event_releaseEvent(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseEvent(_currentEvent);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(event, currentEvent, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL jint Java_com_draico_asvappra_opencl_listeners_Event_getCommandType(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jint commandType;
    void **Result = GetEventInfo(_currentEvent, CL_EVENT_COMMAND_TYPE, &commandType);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        commandType = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return commandType;
}
JNICALL jint Java_com_draico_asvappra_opencl_listeners_Event_getExecutionStatus(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jint executionStatus;
    void **Result = GetEventInfo(_currentEvent, CL_EVENT_COMMAND_EXECUTION_STATUS, &executionStatus);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        executionStatus = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return executionStatus;
}
JNICALL jint Java_com_draico_asvappra_opencl_listeners_Event_getReferenceCount(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    return _currentEvent;
}
JNICALL jlong Java_com_draico_asvappra_opencl_listeners_Event_getProfilingCommandQueue(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jfieldID isEventCreatedManually = env->GetFieldID(Event, "isEventCreatedManually", "Z");
    jboolean _isEventCreatedManually = env->GetBooleanField(event, isEventCreatedManually);
    if (_isEventCreatedManually) {
        char *message = (char*)malloc(sizeof(char) * 297);
        strcpy(message, "You cannot use the getProfilingCommandQueue method with the current event, because this event was created ");
        strcat(message, "manually, you can only use this method with events generated by methods that will do some action with a ");
        strcat(message, "CommandQueue object such as reading a buffer, migrating one or more memory blocks, etc.");
        showMessageError(env, message);
        return -1;
    }
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jobject _commandQueue = env->GetObjectField(event, commandQueue);
    jclass CommandQueue = env->GetObjectClass(_commandQueue);
    jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
    jlong _propertiesSet = env->GetLongField(_commandQueue, propertiesSet);
    if ((_propertiesSet & (1 << 1)) != 1 << 1) {
        char *message = (char*)malloc(sizeof(char) * 319);
        strcpy(message, "You cannot use the getProfilingCommandQueue method with the current event, because the CommandQueue ");
        strcat(message, "object (which you used in some method such as reading a buffer, writing to a buffer, reading a memory ");
        strcat(message, "block, filling a memory block, etc.) was created without having used the ");
        strcat(message, "CommandQueue.QUEUE_PROFILING_ENABLE property");
        showMessageError(env, message);
        return -1;
    }
    cl_ulong profileEvent;
    void **Result = getProfilingEvent(env, event, CL_PROFILING_COMMAND_QUEUED, &profileEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        profileEvent = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return profileEvent;
}
JNICALL jlong Java_com_draico_asvappra_opencl_listeners_Event_getProfilingCommandSubmit(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jfieldID isEventCreatedManually = env->GetFieldID(Event, "isEventCreatedManually", "Z");
    jboolean _isEventCreatedManually = env->GetBooleanField(event, isEventCreatedManually);
    if (_isEventCreatedManually) {
        char *message = (char*)malloc(sizeof(char) * 298);
        strcpy(message, "You cannot use the getProfilingCommandSubmit method with the current event, because this event was created ");
        strcat(message, "manually, you can only use this method with events generated by methods that will do some action with a ");
        strcat(message, "CommandQueue object such as reading a buffer, migrating one or more memory blocks, etc.");
        showMessageError(env, message);
        return -1;
    }
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jobject _commandQueue = env->GetObjectField(event, commandQueue);
    jclass CommandQueue = env->GetObjectClass(_commandQueue);
    jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
    jlong _propertiesSet = env->GetLongField(_commandQueue, propertiesSet);
    if ((_propertiesSet & (1 << 1)) != 1 << 1) {
        char *message = (char*)malloc(sizeof(char) * 320);
        strcpy(message, "You cannot use the getProfilingCommandSubmit method with the current event, because the CommandQueue ");
        strcat(message, "object (which you used in some method such as reading a buffer, writing to a buffer, reading a memory ");
        strcat(message, "block, filling a memory block, etc.) was created without having used the ");
        strcat(message, "CommandQueue.QUEUE_PROFILING_ENABLE property");
        showMessageError(env, message);
        return -1;
    }
    cl_ulong profileEvent;
    void **Result = getProfilingEvent(env, event, CL_PROFILING_COMMAND_SUBMIT, &profileEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        profileEvent = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return profileEvent;
}
JNICALL jlong Java_com_draico_asvappra_opencl_listeners_Event_getProfilingCommantStart(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jfieldID isEventCreatedManually = env->GetFieldID(Event, "isEventCreatedManually", "Z");
    jboolean _isEventCreatedManually = env->GetBooleanField(event, isEventCreatedManually);
    if (_isEventCreatedManually) {
        char *message = (char*)malloc(sizeof(char) * 297);
        strcpy(message, "You cannot use the getProfilingCommandStart method with the current event, because this event was created ");
        strcat(message, "manually, you can only use this method with events generated by methods that will do some action with a ");
        strcat(message, "CommandQueue object such as reading a buffer, migrating one or more memory blocks, etc.");
        showMessageError(env, message);
        return -1;
    }
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jobject _commandQueue = env->GetObjectField(event, commandQueue);
    jclass CommandQueue = env->GetObjectClass(_commandQueue);
    jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
    jlong _propertiesSet = env->GetLongField(_commandQueue, propertiesSet);
    if ((_propertiesSet & (1 << 1)) != 1 << 1) {
        char *message = (char*)malloc(sizeof(char) * 319);
        strcpy(message, "You cannot use the getProfilingCommandStart method with the current event, because the CommandQueue object ");
        strcat(message, "(which you used in some method such as reading a buffer, writing to a buffer, reading a memory block, ");
        strcat(message, "filling a memory block, etc.) was created without having used the ");
        strcat(message, "CommandQueue.QUEUE_PROFILING_ENABLE property");
        showMessageError(env, message);
        return -1;
    }
    cl_ulong profileEvent;
    void **Result = getProfilingEvent(env, event, CL_PROFILING_COMMAND_START, &profileEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        profileEvent = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return profileEvent;
}
JNICALL jlong Java_com_draico_asvappra_opencl_listeners_Event_getProfilingCommandEnd(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jfieldID isEventCreatedManually = env->GetFieldID(Event, "isEventCreatedManually", "Z");
    jboolean _isEventCreatedManually = env->GetBooleanField(event, isEventCreatedManually);
    if (_isEventCreatedManually) {
        char *message = (char*)malloc(sizeof(char) * 295);
        strcpy(message, "You cannot use the getProfilingCommandEnd method with the current event, because this event was created ");
        strcat(message, "manually, you can only use this method with events generated by methods that will do some action with a ");
        strcat(message, "CommandQueue object such as reading a buffer, migrating one or more memory blocks, etc.");
        showMessageError(env, message);
        return -1;
    }
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jobject _commandQueue = env->GetObjectField(event, commandQueue);
    jclass CommandQueue = env->GetObjectClass(_commandQueue);
    jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
    jlong _propertiesSet = env->GetLongField(_commandQueue, propertiesSet);
    if ((_propertiesSet & (1 << 1)) != 1 << 1) {
        char *message = (char*)malloc(sizeof(char) * 317);
        strcpy(message, "You cannot use the getProfilingCommandEnd method with the current event, because the CommandQueue object ");
        strcat(message, "(which you used in some method such as reading a buffer, writing to a buffer, reading a memory block, ");
        strcat(message, "filling a memory block, etc.) was created without having used the CommandQueue.QUEUE_PROFILING_ENABLE ");
        strcat(message, "property");
        showMessageError(env, message);
        return -1;
    }
    cl_ulong profileEvent;
    void **Result = getProfilingEvent(env, event, CL_PROFILING_COMMAND_END, &profileEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        profileEvent = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return profileEvent;
}
JNICALL jlong Java_com_draico_asvappra_opencl_listeners_Event_getProfilingCommandComplete(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return -1;
    }
    jfieldID isEventCreatedManually = env->GetFieldID(Event, "isEventCreatedManually", "Z");
    jboolean _isEventCreatedManually = env->GetBooleanField(event, isEventCreatedManually);
    if (_isEventCreatedManually) {
        char *message = (char*)malloc(sizeof(char) * 300);
        strcpy(message, "You cannot use the getProfilingCommandComplete method with the current event, because this event was ");
        strcat(message, "created manually, you can only use this method with events generated by methods that will do some action ");
        strcat(message, "with a CommandQueue object such as reading a buffer, migrating one or more memory blocks, etc.");
        showMessageError(env, message);
        return -1;
    }
    jfieldID commandQueue = env->GetFieldID(Event, "currentCommandQueue", "Lcom/draico/asvappra/opencl/CommandQueue;");
    jobject _commandQueue = env->GetObjectField(event, commandQueue);
    jclass CommandQueue = env->GetObjectClass(_commandQueue);
    jfieldID propertiesSet = env->GetFieldID(CommandQueue, "propertiesSet", "J");
    jlong _propertiesSet = env->GetLongField(_commandQueue, propertiesSet);
    if ((_propertiesSet & (1 << 1)) != 1 << 1) {
        char *message = (char*)malloc(sizeof(char) * 322);
        strcpy(message, "You cannot use the getProfilingCommandComplete method with the current event, because the CommandQueue ");
        strcat(message, "object (which you used in some method such as reading a buffer, writing to a buffer, reading a memory ");
        strcat(message, "block, filling a memory block, etc.) was created without having used the ");
        strcat(message, "CommandQueue.QUEUE_PROFILING_ENABLE property");
        showMessageError(env, message);
        return -1;
    }
    cl_ulong profileEvent;
    void **Result = getProfilingEvent(env, event, CL_PROFILING_COMMAND_COMPLETE, &profileEvent);
    if (*(jint*)Result[1] != CL_SUCCESS) {
        profileEvent = -1;
        showMessageError(env, (char*)Result[0]);
    }
    return profileEvent;
}
JNICALL jstring Java_com_draico_asvappra_opencl_listeners_Event_toString(JNIEnv *env, jobject event) {
    jclass Event = env->GetObjectClass(event);
    jfieldID currentEvent = env->GetFieldID(Event, "currentEvent", "I");
    jint _currentEvent = env->GetIntField(event, currentEvent);
    if (_currentEvent == -1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "The event you are trying to use is invalid, since it may have been released or the operation to which ");
        strcat(message, "this event was related was completed");
        showMessageError(env, message);
        return NULL;
    }
    return eventToString(env, event);
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_mallocMemory(JNIEnv *env, jclass memory, jobject context, jint flagsMemory, jint sizeBlock) {
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "The context that you are using to create the memory block is set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 160);
        strcpy(message, "You cannot create the memory block with the mallocMemory method because the version of OpenCL that is ");
        strcat(message, "installed on your android device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 78);
        strcpy(message, "The memory block cannot be created because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsTemp = flagsMemory;
    if ((flagsTemp & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsTemp & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsTemp & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if ((flagsTemp & (1 << 10)) == 1 << 10) flagsTemp -= 1 << 10;
    if ((flagsTemp & (1 << 11)) == 1 << 11) flagsTemp -= 1 << 11;
    if (flagsTemp != 0) {
        char *message = (char*)malloc(sizeof(char) * 372);
        strcpy(message, "The memory block cannot be created because you are using an incorrect value for the flagsMemory flag, you ");
        strcat(message, "can only use the following flags to create the memory block and make combinations with them if you need ");
        strcat(message, "to combine the flags:\nMemory.MEMORY_READ_WRITE\nMemory.MEMORY_WRITE_ONLY\nMemory.MEMORY_READ_ONLY\n");
        strcat(message, "Memory.MEMORY_SVM_FINE_GRAIN_BUFFER\nMemory.MEMORY_SVM_ATOMICS");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsMemory & (1 << 0)) == 1 << 0 && (((flagsMemory & (1 << 1)) == 1 << 1) || ((flagsMemory & (1 << 2)) == 1 << 2))) {
        char *message = (char*)malloc(sizeof(char) * 164);
        strcpy(message, "The memory block cannot be created because you are using the Memory.MEMORY_READ_WRITE flag and the ");
        strcat(message, "Memory.MEMORY_READ_ONLY flag or the Memory.MEMORY_WRITE_ONLY flag");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsMemory & (1 << 1)) == 1 << 1 && (flagsMemory & (1 << 2)) == 1 << 2) {
        char *message = (char*)malloc(sizeof(char) * 136);
        strcpy(message, "The memory block cannot be created because you are using the Memory.MEMORY_READ_ONLY and ");
        strcat(message, "Memory.MEMORY_WRITE_ONLY flags at the same time");
        showMessageError(env, message);
        return NULL;
    }
    if (((flagsMemory & (1 << 10)) == 1 << 10 || (flagsMemory & (1 << 11)) == 1 << 11) && VersionOpenCL < 2) {
        char *message = (char*)malloc(sizeof(char) * 225);
        strcpy(message, "You are using any of the following flags to create a block of memory but the version of opencl that has ");
        strcat(message, "your android device installed is lower than version 2.0:\nMemory.MEMORY_SVM_FINE_GRAIN_BUFFER\n");
        strcat(message, "Memory.MEMORY_SVM_ATOMICS");
        showMessageError(env, message);
        return NULL;
    }
    if ((sizeBlock % 2) != 0) {
        char *message = (char*)malloc(sizeof(char) * 51);
        strcpy(message, "The size of the memory block is not a multiple of 2");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _deviceContext = (jobjectArray) env->GetObjectField(context, devicesContext);
    jobject device = env->GetObjectArrayElement(_deviceContext, 0);
    jmethodID getMaxMemAllocSize = env->GetMethodID(Device, "getMaxMemAllocSize", "()J");
    jlong maxMemAllocSize = env->CallLongMethod(device, getMaxMemAllocSize);
    if (sizeBlock > maxMemAllocSize) {
        char *message = (char*)malloc(sizeof(char) * 206);
        strcpy(message, "The size of the memory block you provided exceeds the size of the maximum memory block, which is provided ");
        strcat(message, "by the getMaxMemAllocSize method of the device you are currently working with in the current context");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getMemBaseAddressAlign = env->GetMethodID(Device, "getMemBaseAddressAlign", "()I");
    jint numberBits = env->CallIntMethod(device, getMemBaseAddressAlign);
    cl_uint numberBytes = numberBits / 8;
    if (sizeBlock < numberBytes || (sizeBlock % numberBytes) != 0) {
        char *message = (char*)malloc(sizeof(char) * 486);
        strcpy(message, "The size of the memory block you provided is not a multiple of the value returned by the ");
        strcat(message, "getMemBaseAddressAlign method of the device you used to create the context, the value returned by the ");
        strcat(message, "previous method is the number of bits in the vector used for reading and writing the block of memory, ");
        strcat(message, "that number divides it by 8 bits to know the number of bytes, knowing the byte size of the previous ");
        strcat(message, "vector, you must provide a size for the memory block that is multiple of that number of bytes");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetSVMAlloc(_currentContext, flagsMemory, sizeBlock, numberBytes);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jmethodID hashMapConstructor = env->GetMethodID(HashMap, "<init>", "()V");
        jmethodID putHashMap = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
        jfieldID currentContext = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
        jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID byteArrayMemory = env->GetStaticFieldID(Memory, "byteArrayMemory", "Ljava/lang/String;");
        jobject hashMap = env->NewObject(HashMap, hashMapConstructor);
        jstring _byteArrayMemory = (jstring)env->GetStaticObjectField(Memory, byteArrayMemory);
        jbyteArray _dataMemory = env->NewByteArray(sizeBlock);
        env->SetByteArrayRegion(_dataMemory, 0, sizeBlock, listDataMemory[positionCurrentMemory]);
        env->CallObjectMethod(hashMap, putHashMap, _byteArrayMemory, _dataMemory);
        jobject _memory = env->AllocObject(Memory);
        env->SetIntField(_memory, currentMemory, positionCurrentMemory);
        env->SetObjectField(_memory, currentContext, context);
        env->SetIntField(_memory, sizeBlockMemory, sizeBlock);
        env->SetIntField(_memory, flagsBlockMemory, flagsMemory);
        env->SetObjectField(_memory, dataMemory, hashMap);
        positionCurrentMemory++;
        return _memory;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_memory_Memory_freeMemory(JNIEnv *env, jobject memory) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the ");
        strcat(message, "enqueueFreeMemory method, use another memory block");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "You cannot use the freeMemory method because the version of OpenCL that is installed on your android ");
        strcat(message, "device is lower than version 2.0");
        showMessageError(env, message);
        return;
    }
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jmethodID clearHashMap = env->GetMethodID(HashMap, "clear", "()V");
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jfieldID currentContext = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID _currentContext = env->GetFieldID(Context, "currentContext", "I");
    jobject context = env->GetObjectField(memory, currentContext);
    jint contextPosition = env->GetIntField(context, _currentContext);
    void **Result = GetSVMFree(contextPosition, _currentMemory);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        env->SetIntField(memory, currentMemory, -1);
        jobject hashMap = env->GetObjectField(memory, dataMemory);
        env->CallVoidMethod(hashMap, clearHashMap);
        env->SetObjectField(memory, dataMemory, hashMap);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_memory_Memory_clear(JNIEnv *env, jobject memory, jobject commandQueue) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 145);
        strcpy(message, "You cannot use the clear method to clear the data from the memory block you are using because the ");
        strcat(message, "CommandQueue object you provided is set to null");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "You cannot use the clear method to clear the data from the memory block you are using because the ");
        strcat(message, "CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return;
    }
    jclass Memory = env->GetObjectClass(memory);
    jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "You cannot use the clear method to erase the data from the memory block you are using because it is invalid");
        showMessageError(env, message);
        return;
    }
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jobject _contextMemory = env->GetObjectField(memory, contextMemory);
    if (!env->IsSameObject(_contextCommandQueue, _contextMemory)) {
        char *message = (char*)malloc(sizeof(char) * 228);
        strcpy(message, "You cannot use the clear method to clear the data from the memory block you are using because the ");
        strcat(message, "CommandQueue object you provided was created in a different context than the one you used to create the ");
        strcat(message, "memory block you are using");
        showMessageError(env, message);
        return;
    }
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    jclass HashMap = env->FindClass("java/util/HashMap");
    jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
    jobject _dataMemory = env->GetObjectField(memory, dataMemory);
    if (_dataMemory == NULL) return;
    env->CallVoidMethod(_dataMemory, clear);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueFreeBlocksMemory(JNIEnv *env, jobject memory, jobject commandQueue,
                                                     jobjectArray memoryArray, jobject callbackMemory) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the ");
        strcat(message, "enqueueFreeMemory method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 156);
        strcpy(message, "You cannot free the memory block(s) available with the enqueueFreeeBlocksMemory method, because the ");
        strcat(message, "CommandQueue object you provided is set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot free the memory block list with the enqueueFreeBlocksMemory method, because the CommandQueue ");
        strcat(message, "object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray listBlocksMemory;
    if (memoryArray == NULL) listBlocksMemory = env->NewObjectArray(1, Memory, memory);
    else {
        jsize lengthArrayMemory = env->GetArrayLength(memoryArray);
        for (jint position = 0; position < lengthArrayMemory; position++) {
            jobject blockMemory = env->GetObjectArrayElement(memoryArray, position);
            if (env->IsSameObject(memory, blockMemory)) {
                char *message = (char*)malloc(sizeof(char) * 223);
                strcpy(message, "You cannot free the memory block list because in this list, you included the memory block with ");
                strcat(message, "which you are using the enqueueFreeBlocksMemory method, this memory block will be added ");
                strcat(message, "internally to the list you have provided");
                showMessageError(env, message);
                return NULL;
            }
        }
        for (jint position1 = 0; position1 < (lengthArrayMemory - 1); position1++) {
            jobject memory1 = env->GetObjectArrayElement(memoryArray, position1);
            for (jint position2 = position1 + 1; position2 < lengthArrayMemory; position2++) {
                jobject memory2 = env->GetObjectArrayElement(memoryArray, position2);
                if (env->IsSameObject(memory1, memory2)) {
                    char *message = (char*)malloc(sizeof(char) * 164);
                    strcpy(message, "You cannot release the list of memory blocks that you provided, because at least one of the ");
                    strcat(message, "memory blocks in that list is the same as another block in the same list");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
        listBlocksMemory = env->NewObjectArray(lengthArrayMemory + 1, Memory, memory);
        for (jint position = 0; position < lengthArrayMemory; position++) {
            jobject blockMemory = env->GetObjectArrayElement(memoryArray, position);
            env->SetObjectArrayElement(listBlocksMemory, position + 1, blockMemory);
        }
    }
    jclass HashMap = env->FindClass("java/util/HashMap");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jsize memoryArrayLength = env->GetArrayLength(listBlocksMemory);
    jint positionDataMemory[memoryArrayLength];
    jint sizeBlocksMemory[memoryArrayLength];
    jint flagsBlocksMemory[memoryArrayLength];
    for (jint position = 0; position < memoryArrayLength; position++) {
        jobject _memory = env->GetObjectArrayElement(listBlocksMemory, position);
        jint _currentMemory = env->GetIntField(_memory, currentMemory);
        jint _sizeBlockMemory = env->GetIntField(_memory, sizeBlockMemory);
        jint _flagsBlockMemory = env->GetIntField(_memory, flagsBlockMemory);
        positionDataMemory[position] = _currentMemory;
        sizeBlocksMemory[position] = _sizeBlockMemory;
        flagsBlocksMemory[position] = _flagsBlockMemory;
    }
    void **Result = GetEnqueueSVMFree(env, commandQueue, memoryArrayLength, positionDataMemory, sizeBlocksMemory, flagsBlocksMemory,
                                      callbackMemory);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
        for (jint position = 0; position < (memoryArrayLength - 1); position++) {
            jobject _memory = env->GetObjectArrayElement(memoryArray, position);
            jobject _dataMemory = env->GetObjectField(_memory, dataMemory);
            env->CallVoidMethod(_dataMemory, clear);
            env->SetIntField(_memory, currentMemory, -1);
            env->SetObjectField(_memory, dataMemory, _dataMemory);
            env->SetObjectArrayElement(memoryArray, position, _memory);
        }
        env->SetIntField(memory, currentMemory, -1);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueCopyBlockMemory(JNIEnv *env, jobject memory, jobject commandQueue,
                                                    jobject srcMemory, jboolean isBlockingMemory) {
    if (commandQueue == NULL || srcMemory == NULL) {
        char *message = (char*)malloc(sizeof(char) * 165);
        strcpy(message, "The source memory block cannot be copied to the destination memory block, because you have provided the ");
        strcat(message, "CommandQueue and/or the source memory block with a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    jint currentSrcMemory = env->GetIntField(srcMemory, currentMemory);
    if (_currentMemory == -1 || currentSrcMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the ");
        strcat(message, "enqueueFreeMemory method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 145);
        strcpy(message, "You cannot use the enqueueCopyBlockMemory method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 178);
        strcpy(message, "You cannot copy the srcMemory memory block to the memory block with which you are using the ");
        strcat(message, "enqueueCopyBlockMemory method, because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (env->IsSameObject(memory, srcMemory)) {
        char *message = (char*)malloc(sizeof(char) * 166);
        strcpy(message, "You cannot copy the memory blocks because both the srcMemory memory block and the destination memory ");
        strcat(message, "block (the one you are currently using) are the same memory block");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint currentDstMemory = env->GetIntField(memory, currentMemory);
    jsize sizeBlockDstMemory = env->GetIntField(memory, sizeBlockMemory);
    jsize sizeBlockSrcMemory = env->GetIntField(srcMemory, sizeBlockMemory);
    if (sizeBlockSrcMemory > sizeBlockDstMemory) {
        char *message = (char*)malloc(sizeof(char) * 183);
        strcpy(message, "The copy of the source memory block to the destination memory block cannot be made, because the size of ");
        strcat(message, "the source memory block is larger than the size of the destination memory block");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, sizeBlockDstMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    void **Result = GetEnqueueSVMMemcpy(_currentCommandQueue, isBlockingMemory, currentDstMemory, currentSrcMemory);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, sizeBlockDstMemory, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(memory, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = sizeBlockDstMemory / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(sizeBlockDstMemory);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, sizeBlockDstMemory, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(memory, dataMemory, _dataMemory);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueFillBlockMemory(JNIEnv *env, jobject memory, jobject commandQueue,
                                                    jobject patternFill, jint sizePatternFill, jint sizeBlockToFill) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the ");
        strcat(message, "enqueueFreeMemory method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 145);
        strcpy(message, "You cannot use the enqueueFillBlockMemory method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL || patternFill == NULL) {
        char *message = (char*)malloc(sizeof(char) * 135);
        strcpy(message, "The memory block cannot be filled with the fill pattern, because it set the CommandQueue object and/or the ");
        strcat(message, "fill pattern with null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 125);
        strcpy(message, "The memory block cannot be filled with the fill pattern you provided, because the CommandQueue object you ");
        strcat(message, "provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizePatternFill <= 0 || sizeBlockToFill <= 0) {
        char *message = (char*)malloc(sizeof(char) * 166);
        strcpy(message, "The filling of the memory block with the filling pattern cannot be performed, because the variables ");
        strcat(message, "sizePatternFill and/or sizeBlockToFill are less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    if ((sizeBlockToFill % sizePatternFill) != 0) {
        char *message = (char*)malloc(sizeof(char) * 566);
        strcpy(message, "The memory block fill size is not multiple of the size of the data type of the fill pattern, to help you ");
        strcat(message, "select an appropriate memory block size, the data types and the number of bytes that will be provided It ");
        strcat(message, "has each type of data:\nbyte - 1 byte\nchar - 1 byte\nshort - 2 bytes\nint - 4 bytes\nfloat - 4 bytes\n");
        strcat(message, "double - 8 bytes\nlong - 8 bytes\n If you use an array of any of the Previous data types should use the ");
        strcat(message, "number of bytes corresponding to the type of data used in the array and multiply it with the length of ");
        strcat(message, "the array to know the size of the fill pattern");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID currentContextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentContextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _currentContextCommandQueue = env->GetObjectField(commandQueue, currentContextCommandQueue);
    jobject _currentContextMemory = env->GetObjectField(memory, currentContextMemory);
    if (!env->IsSameObject(_currentContextMemory, _currentContextCommandQueue)) {
        char *message = (char*)malloc(sizeof(char) * 153);
        strcpy(message, "The CommandQueue object was created in a context different from the context you used to create the memory ");
        strcat(message, "block that you want to fill with a fill pattern");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    if ((_sizeBlockMemory % sizePatternFill) != 0) {
        char *message = (char*)malloc(sizeof(char) * 140);
        strcpy(message, "You cannot fill the memory block with the fill pattern, because the size of the fill pattern is not ");
        strcat(message, "multiple of the size of the memory block");
        showMessageError(env, message);
        return NULL;
    }
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass Character = env->FindClass("java/lang/Character");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Long = env->FindClass("java/lang/Long");
    jclass Short = env->FindClass("java/lang/Short");
    jclass String = env->FindClass("java/lang/String");
    jclass Class = env->FindClass("java/lang/Class");
    jclass Object = env->FindClass("java/lang/Object");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jobject objectClass = env->CallObjectMethod(patternFill, getClass);
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    void **Result;
    if (env->CallBooleanMethod(objectClass, isArray)) {
        jarray listData = (jarray)patternFill;
        jsize sizeListData = env->GetArrayLength(listData);
        jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
        jstring nameClass = (jstring)env->CallObjectMethod(objectClass, getName);
        const char *_nameClass = env->GetStringUTFChars(nameClass, JNI_FALSE);
        if (strcmp(_nameClass, "[I") == 0) {
            cl_int *listNumbersIntegers = env->GetIntArrayElements((jintArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, listNumbersIntegers, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[S") == 0) {
            cl_short *listNumbersShorts = env->GetShortArrayElements((jshortArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, listNumbersShorts, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[J") == 0) {
            cl_long *listNumbersLongs = env->GetLongArrayElements((jlongArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, listNumbersLongs, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[F") == 0) {
            cl_float *listNumberFloats = env->GetFloatArrayElements((jfloatArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, listNumberFloats, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[D") == 0) {
            cl_double *listNumberDoubles = env->GetDoubleArrayElements((jdoubleArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, listNumberDoubles, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[C") == 0) {
            cl_char *_listCharacters = (cl_char*)env->GetCharArrayElements((jcharArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listCharacters, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[B") == 0) {
            cl_uchar *_listBytes = (cl_uchar*)env->GetByteArrayElements((jbyteArray)listData, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listBytes, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Integer;") == 0) {
            cl_int _listIntegers[sizeListData];
            jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectInt = env->GetObjectArrayElement((jobjectArray)listData, position);
                jint valueInt = env->CallIntMethod(objectInt, intValue);
                _listIntegers[position] = valueInt;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listIntegers, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Short;") == 0) {
            cl_short _listShorts[sizeListData];
            jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectShort = env->GetObjectArrayElement((jobjectArray)listData, position);
                jshort valueShort = env->CallShortMethod(objectShort, shortValue);
                _listShorts[position] = valueShort;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listShorts, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Float;") == 0) {
            cl_float _listFloats[sizeListData];
            jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectFloat = env->GetObjectArrayElement((jobjectArray)listData, position);
                jfloat valueFloat = env->CallFloatMethod(objectFloat, floatValue);
                _listFloats[position] = valueFloat;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listFloats, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Double;") == 0) {
            cl_double _listDoubles[sizeListData];
            jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectDouble = env->GetObjectArrayElement((jobjectArray)listData, position);
                jdouble valueDouble = env->CallDoubleMethod(objectDouble, doubleValue);
                _listDoubles[position] = valueDouble;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listDoubles, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Long;") == 0) {
            cl_long _listLongs[sizeListData];
            jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectLong = env->GetObjectArrayElement((jobjectArray)listData, position);
                jlong valueLong = env->CallLongMethod(objectLong, longValue);
                _listLongs[position] = valueLong;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listLongs, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Character;") == 0) {
            cl_char _listChars[sizeListData];
            jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectCharacter = env->GetObjectArrayElement((jobjectArray) listData, position);
                jchar valueChar = env->CallCharMethod(objectCharacter, charValue);
                _listChars[position] = (cl_char) valueChar;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listChars, sizePatternFill, sizeBlockToFill);
        } else if (strcmp(_nameClass, "[Ljava.lang.Byte;") == 0) {
            cl_uchar _listUChars[sizeListData];
            jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
            for (jint position = 0; position < sizeListData; position++) {
                jobject objectByte = env->GetObjectArrayElement((jobjectArray)listData, position);
                cl_uchar valueByte = (cl_uchar) env->CallByteMethod(objectByte, byteValue);
                _listUChars[position] = valueByte;
            }
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _listUChars, sizePatternFill, sizeBlockToFill);
        } else {
            char *message = (char*)malloc(sizeof(char) * 419);
            strcpy(message, "The memory block cannot be filled with the design pattern that you provided, since it is not of the ");
            strcat(message, "appropriate data type for filling the memory block, if you plan on using data arrays for the ");
            strcat(message, "filling pattern you can only enter arrays of data of the primitive types such as int, short, long, ");
            strcat(message, "float, double, char, and byte, as well as arrays of class types such as Integer, Short, Long, Float, ");
            strcat(message, "Double, Character and Byte");
            showMessageError(env, message);
            return NULL;
        }
    } else {
        if (env->IsInstanceOf(patternFill, Byte)) {
            jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
            jbyte valueByte = env->CallByteMethod((jobject)patternFill, byteValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueByte, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Character)) {
            jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
            cl_char valueChar = env->CallCharMethod((jobject)patternFill, charValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueChar, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Double)) {
            jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
            cl_double valueDouble = env->CallDoubleMethod((jobject)patternFill, doubleValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueDouble, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Float)) {
            jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
            cl_float valueFloat = env->CallFloatMethod((jobject)patternFill, floatValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueFloat, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Integer)) {
            jmethodID integerValue = env->GetMethodID(Integer, "intValue", "()I");
            cl_int valueInt = env->CallIntMethod((jobject)patternFill, integerValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueInt, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Long)) {
            jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
            cl_long valueLong = env->CallLongMethod((jobject)patternFill, longValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueLong, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, Short)) {
            jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
            cl_short valueShort = env->CallShortMethod((jobject)patternFill, shortValue);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, &valueShort, sizePatternFill, sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, String)) {
            const char *dataFillParttern = env->GetStringUTFChars((jstring) patternFill, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, (cl_char *) dataFillParttern, sizePatternFill,
                                          sizeBlockToFill);
        } else if (env->IsInstanceOf(patternFill, String)) {
            jmethodID getBytes = env->GetMethodID(String, "getBytes", "()[B");
            jbyteArray dataString = (jbyteArray)env->CallObjectMethod((jobject)patternFill, getBytes);
            jbyte *_dataString = env->GetByteArrayElements(dataString, JNI_FALSE);
            Result = GetEnqueueSVMMemFill(_currentCommandQueue, _currentMemory, _dataString, sizePatternFill, sizeBlockToFill);
        } else {
            char *message = (char*)malloc(sizeof(char) * 593);
            strcpy(message, "The memory block cannot be filled, because the type of data you have provided as a fill pattern is ");
            strcat(message, "incorrect, you can only use the following data types as a fill pattern for the memory block:\na) For ");
            strcat(message, "data from the primitive type can only use int, short, long, float, double, char, and byte\nb) For ");
            strcat(message, "data of the Object type you can only use Integer, Short, Long, Float, Double, Character, Byte and ");
            strcat(message, "String\nc) For arrays you can use both data of the primitive type and of the Object types described ");
            strcat(message, "above but excluding String, you must ensure that the whole array must be of the same type of data");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass HashMap = env->FindClass("java/util/HashMap");
        jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
        jmethodID clear = env->GetMethodID(HashMap, "clear", "()V");
        jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
        jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
        jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
        jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
        jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
        executeCommandQueue(env, commandQueue);
        executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 7);
        jobject _dataMemory = env->GetObjectField(memory, dataMemory);
        env->CallVoidMethod(_dataMemory, clear);
        jsize sizeBlock = _sizeBlockMemory / sizeof(jdouble);
        jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
        jshortArray _dataShort = env->NewShortArray(sizeBlock);
        jintArray _dataInt = env->NewIntArray(sizeBlock);
        jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
        jlongArray _dataLong = env->NewLongArray(sizeBlock);
        env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
        env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
        env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
        env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
        env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
        env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
        env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
        env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
        env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
        env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
        env->SetObjectField(memory, dataMemory, _dataMemory);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueMapMemory(JNIEnv *env, jobject memory, jobject commandQueue, jboolean isBlockingMap,
                                              jint sizeBlock, jint flagsMap) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the enqueueFreeMemory ");
        strcat(message, "method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 139);
        strcpy(message, "You cannot use the enqueueMapMemory method because the version of OpenCL that is installed on your android ");
        strcat(message, "device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "There is a problem with the memory block mapping, because the CommandQueue you set with a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 89);
        strcpy(message, "The memory block cannot be mapped because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeBlock <= 0) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "The memory block mapping cannot be performed, because the mapping size you provided is equal to or less ");
        strcat(message, "than 0");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsTemp = flagsMap;
    if ((flagsTemp & (1 << 0)) == 1 << 0) flagsTemp -= 1 << 0;
    if ((flagsTemp & (1 << 1)) == 1 << 1) flagsTemp -= 1 << 1;
    if ((flagsTemp & (1 << 2)) == 1 << 2) flagsTemp -= 1 << 2;
    if (flagsTemp != 0) {
        char *message = (char*)malloc(sizeof(char) * 267);
        strcpy(message, "There is a problem with the memory block mapping, because you are using a flag for the memory block mapping ");
        strcat(message, "that is not allowed, the only flags for the memory block mapping allowed are the following:\n");
        strcat(message, "Memory.MAP_READ\nMemory.MAP_WRITE\nMemory.MAP_WRITE_INVALIDATE_REGION");
        showMessageError(env, message);
        return NULL;
    }
    if ((flagsMap & (1 << 2)) == 1 << 2 && (((flagsMap & (1 << 0)) == 1 << 0) || ((flagsMap & (1 << 1)) == 1 << 1))) {
        char *message = (char*)malloc(sizeof(char) * 204);
        strcpy(message, "The memory block mapping cannot be performed because you are using the Memory.MAP_WRITE_INVALIDATE_REGION ");
        strcat(message, "flag and this flag cannot be used if you use the Memory.MAP_READ flag or the Memory.MAP_WRITE flag");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    if (sizeBlock > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "There is a problem with memory block mapping, because the size of the mapping exceeds the size of the ");
        strcat(message, "memory block");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetEnqueueSVMMap(_currentCommandQueue, _currentMemory, isBlockingMap, sizeBlock, flagsMap);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
        env->SetIntField(memory, flagsMapMemory, flagsMap);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueUnmapMemory(JNIEnv *env, jobject memory, jobject commandQueue) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the enqueueFreeMemory ");
        strcat(message, "method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "You cannot use the enqueueUnmapMemory method because the version of OpenCL that is installed on your android ");
        strcat(message, "device is lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "There is a problem with the enqueueUnmapMemory method because you set the CommandQueue with a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 127);
        strcpy(message, "The enqueueUnmapMemory method of the current memory block cannot be used because it has provided an invalid ");
        strcat(message, "CommandQueue object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    if (_flagsMapMemory == 0) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "The enqueueUnmapMemory method cannot be executed because no mapping has been applied to the memory block");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetEnqueueSVMUnmap(_currentCommandQueue, _currentMemory);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        env->SetIntField(memory, flagsMapMemory, 0);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_memory_Memory_enqueueMigrateMemory(JNIEnv *env, jobject memory, jobject commandQueue,
                                                  jobjectArray memoryList, jint flagsMigrateMemory) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the ");
        strcat(message, "enqueueFreeMemory method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot use the enqueueMigrateMemory method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "There is a problem with the migration of the memory block list, because the CommandQueue ");
        strcat(message, "you set with a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "The memory block migration cannot be performed because the CommandQueue object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint flagsMigrateTemp = flagsMigrateMemory;
    if ((flagsMigrateTemp & (1 << 0)) == 1 << 0) flagsMigrateTemp -= 1 << 0;
    if ((flagsMigrateTemp & (1 << 1)) == 1 << 1) flagsMigrateTemp -= 1 << 1;
    if (flagsMigrateTemp != 0) {
        char *message = (char*)malloc(sizeof(char) * 197);
        strcpy(message, "The flag you are using to try to migrate the memory block list is incorrect, you can only use the ");
        strcat(message, "following flags:\nMemory.MIGRATE_MEMOTY_OBJECT_HOST\nMemory.MIGRATE_MEMORY_OBJECT_CONTENT_UNDEFINED");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray _memoryList;
    if (memoryList == NULL) _memoryList = env->NewObjectArray(1, Memory, memory);
    else {
        jsize sizeMemoryList = env->GetArrayLength(memoryList);
        jint position = 0;
        _memoryList = env->NewObjectArray(sizeMemoryList + 1, Memory, NULL);
        for (; position < sizeMemoryList; position++) {
            jobject _memory = env->GetObjectArrayElement(memoryList, position);
            env->SetObjectArrayElement(_memoryList, position, _memory);
        }
        env->SetObjectArrayElement(_memoryList, position, memory);
        for (jint position1 = 0; position1 < (sizeMemoryList - 1); position1++) {
            jobject _memory1 = env->GetObjectArrayElement(memoryList, position1);
            for (jint position2 = position1 + 1; position2 < sizeMemoryList; position2++) {
                jobject _memory2 = env->GetObjectArrayElement(memoryList, position2);
                if (env->IsSameObject(_memory2, memory)) {
                    char *message = (char*)malloc(sizeof(char) * 264);
                    strcpy(message, "None of the memory blocks that you have added to the list of memory blocks should not be ");
                    strcat(message, "equal to the memory block you are using to perform the migration of the device in which the ");
                    strcat(message, "memory blocks were created so that they can work without problems in the new device");
                    showMessageError(env, message);
                    return NULL;
                } else if (env->IsSameObject(_memory1, _memory2)) {
                    char *message = (char*)malloc(sizeof(char) * 203);
                    strcpy(message, "The migration of the memory block list cannot be performed, since at least two memory blocks ");
                    strcat(message, "in the list you provided are the same,  and this prevents Migration of the list of memory ");
                    strcat(message, "blocks is successful");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
        env->SetObjectArrayElement(_memoryList, sizeMemoryList, memory);
    }
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jfieldID deviceCommandQueue = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
    jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jsize sizeMemoryList = env->GetArrayLength(_memoryList);
    jobject _deviceCommandQueue = env->GetObjectField(commandQueue, deviceCommandQueue);
    for (jint position = 0; position < sizeMemoryList; position++) {
        jobject _memory = env->GetObjectArrayElement(_memoryList, position);
        jobject _contextMemory = env->GetObjectField(_memory, contextMemory);
        jobjectArray _devicesContext = (jobjectArray) env->GetObjectField(_contextMemory, devicesContext);
        jsize sizeDeviceArray = env->GetArrayLength(_devicesContext);
        for (jint positionArrayDevice = 0; positionArrayDevice < sizeDeviceArray; positionArrayDevice++) {
            jobject device = env->GetObjectArrayElement(_devicesContext, positionArrayDevice);
            if (env->IsSameObject(_deviceCommandQueue, device) && sizeDeviceArray == 1) {
                char *message = (char*)malloc(sizeof(char) * 239);
                strcpy(message, "The migration of the memory block(s) you provided cannot be performed, because in the context where ");
                strcat(message, "the CommandQueue object and the memory block(s) were created there is only one device and for that ");
                strcat(message, "reason the migration cannot be performed");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    cl_int *listBlockMemory = (cl_int *) malloc(sizeof(cl_int) * sizeMemoryList);
    for (jint position = 0; position < sizeMemoryList; position++) {
        jobject _memory = env->GetObjectArrayElement(_memoryList, position);
        jint positionBlockMemory = env->GetIntField(_memory, currentMemory);
        listBlockMemory[position] = positionBlockMemory;
    }
    void **Result = GetEnqueueSVMMigrateMem(_currentCommandQueue, sizeMemoryList, listBlockMemory, flagsMigrateMemory);
    if (*(jint *) Result[1] == CL_SUCCESS) {
        jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
        if (memoryList != NULL) {
            sizeMemoryList--;
            for (jint position = 0; position < sizeMemoryList; position++) {
                jobject _memory = env->GetObjectArrayElement(_memoryList, position);
                env->SetObjectField(_memory, contextMemory, _contextCommandQueue);
                env->SetObjectArrayElement(memoryList, position, _memory);
            }
        }
        env->SetObjectField(memory, contextMemory, _contextCommandQueue);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNIEXPORT void JNICALL Java_com_draico_asvappra_opencl_memory_Memory_addByteArray(JNIEnv *env, jobject memory, jobject commandQueue, jbyteArray data,
                                           jint offset) {
    if (data == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot adjust the memory block because the data array or the CommandQueue object that you provided is ");
        strcat(message, "set to null");
        showMessageError(env, message);
        return;
    }
    jsize sizeData = env->GetArrayLength(data);
    if (sizeData == 0) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot adjust the memory block because the data array you provided is empty");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 155);
        strcpy(message, "You cannot adjust the memory block with the data array you have provided because the memory block or the ");
        strcat(message, "CommandQueue object that you are using is invalid");
        showMessageError(env, message);
        return;
    }
    if (offset < 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the offset you provided is ");
        strcat(message, "less than 0");
        showMessageError(env, message);
        return;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    if (sizeData > _sizeBlockMemory || (sizeData + offset) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 160);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the size of the data array is ");
        strcat(message, "larger than the size of the memory block you are using");
        showMessageError(env, message);
        return;
    }
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    jbyte *_data = env->GetByteArrayElements(data, NULL);
    jint positionListMemory = offset;
    for (jint position = 0; position < sizeData; position++, positionListMemory++) {
        listDataMemory[_currentMemory][positionListMemory] = _data[position];
    }
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 0);
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jmethodID constructorHashMap = env->GetMethodID(HashMap, "<init>", "()V");
    jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
    jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
    jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
    jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
    jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
    jobject _dataMemory = env->NewObject(HashMap, constructorHashMap);
    jsize sizeBlock = _sizeBlockMemory / sizeof(jbyte);
    jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
    jshortArray _dataShort = env->NewShortArray(sizeBlock);
    jintArray _dataInt = env->NewIntArray(sizeBlock);
    jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
    jlongArray _dataLong = env->NewLongArray(sizeBlock);
    env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
    env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
    env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
    env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
    env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
    env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
    env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
    env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
    env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
    env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNIEXPORT void JNICALL Java_com_draico_asvappra_opencl_memory_Memory_addFloatArray(JNIEnv *env, jobject memory, jobject commandQueue, jfloatArray data,
                                            jint offset) {
    if (data == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot adjust the memory block because the data array or the CommandQueue object that you provided is ");
        strcat(message, "set to null");
        showMessageError(env, message);
        return;
    }
    jsize sizeData = env->GetArrayLength(data);
    if (sizeData == 0) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot adjust the memory block because the data array you provided is empty");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 155);
        strcpy(message, "You cannot adjust the memory block with the data array you have provided because the memory block or the ");
        strcat(message, "CommandQueue object that you are using is invalid");
        showMessageError(env, message);
        return;
    }
    if (offset < 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the offset you provided is ");
        strcat(message, "less than 0");
        showMessageError(env, message);
        return;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    jsize sizeDataByte = sizeof(jfloat);
    if (sizeData * sizeDataByte > _sizeBlockMemory || ((sizeData + offset) * sizeDataByte) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 195);
        strcpy(message, "You cannot adjust the memory block with the float type data array that you provided because each data is 4 ");
        strcat(message, "bytes long, so make sure that the memory block size is large enough to hold all the data");
        showMessageError(env, message);
        return;
    }
    jfloat *_data = env->GetFloatArrayElements(data, NULL);
    jclass ByteBuffer = env->FindClass("java/nio/ByteBuffer");
    jmethodID allocate = env->GetStaticMethodID(ByteBuffer, "allocate", "(I)Ljava/nio/ByteBuffer;");
    jmethodID putFloat = env->GetMethodID(ByteBuffer, "putFloat", "(F)Ljava/nio/ByteBuffer;");
    jmethodID array = env->GetMethodID(ByteBuffer, "array", "()[B");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    jint positionListMemory = offset * sizeDataByte;
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    for (jint position = 0; position < sizeData; position++, positionListMemory += sizeDataByte) {
        jobject byteBuffer = env->CallStaticObjectMethod(ByteBuffer, allocate, sizeDataByte);
        byteBuffer = env->CallObjectMethod(byteBuffer, putFloat, _data[position]);
        jbyteArray dataByte = (jbyteArray)env->CallObjectMethod(byteBuffer, array);
        jbyte *_dataByte = env->GetByteArrayElements(dataByte, NULL);
        for (jint positionBuffer = 0; positionBuffer < sizeDataByte; positionBuffer++) {
            listDataMemory[_currentMemory][positionListMemory + positionBuffer] = _dataByte[positionBuffer];
        }
    }
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 5);
    jclass HashMap = env->FindClass("java/util/HashMap");
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jmethodID constructorHashMap = env->GetMethodID(HashMap, "<init>", "()V");
    jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
    jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
    jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
    jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
    jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
    jobject _dataMemory = env->NewObject(HashMap, constructorHashMap);
    jsize sizeBlock = _sizeBlockMemory / sizeof(jfloat);
    jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
    jshortArray _dataShort = env->NewShortArray(sizeBlock);
    jintArray _dataInt = env->NewIntArray(sizeBlock);
    jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
    jlongArray _dataLong = env->NewLongArray(sizeBlock);
    env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
    env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
    env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
    env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
    env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
    env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
    env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
    env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
    env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
    env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNIEXPORT void JNICALL Java_com_draico_asvappra_opencl_memory_Memory_addIntegerArray(JNIEnv *env, jobject memory, jobject commandQueue, jintArray data,
                                              jint offset) {
    if (data == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot adjust the memory block because the data array or the CommandQueue object that you provided is ");
        strcat(message, "set to null");
        showMessageError(env, message);
        return;
    }
    jsize sizeData = env->GetArrayLength(data);
    if (sizeData == 0) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot adjust the memory block because the data array you provided is empty");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 155);
        strcpy(message, "You cannot adjust the memory block with the data array you have provided because the memory block or the ");
        strcat(message, "CommandQueue object that you are using is invalid");
        showMessageError(env, message);
        return;
    }
    if (offset < 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the offset you provided is ");
        strcat(message, "less than 0");
        showMessageError(env, message);
        return;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    jsize sizeDataByte = sizeof(int);
    if (sizeData * sizeDataByte > _sizeBlockMemory || ((sizeData + offset) * sizeDataByte) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 193);
        strcpy(message, "You cannot adjust the memory block with the int type data array that you provided because each data is 4 ");
        strcat(message, "bytes long, so make sure that the memory block size is large enough to hold all the data");
        showMessageError(env, message);
        return;
    }
    jint *__data = env->GetIntArrayElements(data, NULL);
    jclass ByteBuffer = env->FindClass("java/nio/ByteBuffer");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jmethodID allocate = env->GetStaticMethodID(ByteBuffer, "allocate", "(I)Ljava/nio/ByteBuffer;");
    jmethodID putInt = env->GetMethodID(ByteBuffer, "putInt", "(I)Ljava/nio/ByteBuffer;");
    jmethodID array = env->GetMethodID(ByteBuffer, "array", "()[B");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    jint positionListMemory = offset * sizeDataByte;
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    for (jint position = 0; position < sizeData; position++, positionListMemory += sizeDataByte) {
        jobject byteBuffer = env->CallStaticObjectMethod(ByteBuffer, allocate, sizeDataByte);
        byteBuffer = env->CallObjectMethod(byteBuffer, putInt, (jint)__data[position]);
        jbyteArray dataByte = (jbyteArray)env->CallObjectMethod(byteBuffer, array);
        jbyte *_dataByte = env->GetByteArrayElements(dataByte, NULL);
        for (jint positionBuffer = 0; positionBuffer < sizeDataByte; positionBuffer++) {
            listDataMemory[_currentMemory][positionListMemory + positionBuffer] = _dataByte[positionBuffer];
        }
    }
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 4);
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jmethodID constructorHashMap = env->GetMethodID(HashMap, "<init>", "()V");
    jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
    jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
    jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
    jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
    jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
    jobject _dataMemory = env->NewObject(HashMap, constructorHashMap);
    jsize sizeBlock = _sizeBlockMemory / sizeof(jint);
    jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
    jshortArray _dataShort = env->NewShortArray(sizeBlock);
    jintArray _dataInt = env->NewIntArray(sizeBlock);
    jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
    jlongArray _dataLong = env->NewLongArray(sizeBlock);
    env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
    env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
    env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
    env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
    env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
    env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
    env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
    env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
    env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
    env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNIEXPORT void JNICALL Java_com_draico_asvappra_opencl_memory_Memory_addShortArray(JNIEnv *env, jobject memory, jobject commandQueue, jshortArray data,
                                            jint offset) {
    if (data == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot adjust the memory block because the data array or the CommandQueue object that you provided is set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return;
    }
    jsize sizeData = env->GetArrayLength(data);
    if (sizeData == 0) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot adjust the memory block because the data array you provided is empty");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 155);
        strcpy(message, "You cannot adjust the memory block with the data array you have provided because the memory block or the ");
        strcat(message, "CommandQueue object that you are using is invalid");
        showMessageError(env, message);
        return;
    }
    if (offset < 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the offset you provided is ");
        strcat(message, "less than 0");
        showMessageError(env, message);
        return;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    jsize sizeDataByte = sizeof(jshort);
    if (sizeData * sizeDataByte > _sizeBlockMemory || ((sizeData + offset) * sizeDataByte) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 195);
        strcpy(message, "You cannot adjust the memory block with the short type data array that you provided because each data is ");
        strcat(message, "2 bytes long, so make sure that the memory block size is large enough to hold all the data");
        showMessageError(env, message);
        return;
    }
    jshort *_data = env->GetShortArrayElements(data, NULL);
    jclass ByteBuffer = env->FindClass("java/nio/ByteBuffer");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jmethodID allocate = env->GetStaticMethodID(ByteBuffer, "allocate", "(I)Ljava/nio/ByteBuffer;");
    jmethodID putShort = env->GetMethodID(ByteBuffer, "putShort", "(S)Ljava/nio/ByteBuffer;");
    jmethodID array = env->GetMethodID(ByteBuffer, "array", "()[B");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    jint positionListMemory = offset * sizeDataByte;
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    for (jint position = 0; position < sizeData; position++, positionListMemory += sizeDataByte) {
        jobject byteBuffer = env->CallStaticObjectMethod(ByteBuffer, allocate, sizeDataByte);
        byteBuffer = env->CallObjectMethod(byteBuffer, putShort, _data[position]);
        jbyteArray dataByte = (jbyteArray)env->CallObjectMethod(byteBuffer, array);
        jbyte *_dataByte = env->GetByteArrayElements(dataByte, NULL);
        for (jint positionBuffer = 0; positionBuffer < sizeDataByte; positionBuffer++) {
            listDataMemory[_currentMemory][positionListMemory + positionBuffer] = _dataByte[positionBuffer];
        }
    }
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 3);
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jmethodID constructorHashMap = env->GetMethodID(HashMap, "<init>", "()V");
    jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
    jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
    jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
    jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
    jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
    jobject _dataMemory = env->NewObject(HashMap, constructorHashMap);
    jsize sizeBlock = _sizeBlockMemory / sizeof(jshort);
    jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
    jshortArray _dataShort = env->NewShortArray(sizeBlock);
    jintArray _dataInt = env->NewIntArray(sizeBlock);
    jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
    jlongArray _dataLong = env->NewLongArray(sizeBlock);
    env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
    env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
    env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
    env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
    env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
    env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
    env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
    env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
    env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
    env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNIEXPORT void JNICALL Java_com_draico_asvappra_opencl_memory_Memory_addLongArray(JNIEnv *env, jobject memory, jobject commandQueue, jlongArray data,
                                           jint offset) {
    if (data == NULL || commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot adjust the memory block because the data array or the CommandQueue object that you provided is set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return;
    }
    jsize sizeData = env->GetArrayLength(data);
    if (sizeData == 0) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot adjust the memory block because the data array you provided is empty");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 155);
        strcpy(message, "You cannot adjust the memory block with the data array you have provided because the memory block or the ");
        strcat(message, "CommandQueue object that you are using is invalid");
        showMessageError(env, message);
        return;
    }
    if (offset < 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the memory block with the data array you provided because the offset you provided is less than 0");
        showMessageError(env, message);
        return;
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jint _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
    jsize sizeDataByte = sizeof(jlong);
    if (sizeData * sizeDataByte > _sizeBlockMemory || ((sizeData + offset) * sizeDataByte) > _sizeBlockMemory) {
        char *message = (char*)malloc(sizeof(char) * 194);
        strcpy(message, "You cannot adjust the memory block with the long type data array that you provided because each data is 8 ");
        strcat(message, "bytes long, so make sure that the memory block size is large enough to hold all the data");
        showMessageError(env, message);
        return;
    }
    jlong *_data = env->GetLongArrayElements(data, NULL);
    jclass ByteBuffer = env->FindClass("java/nio/ByteBuffer");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jmethodID allocate = env->GetStaticMethodID(ByteBuffer, "allocate", "(I)Ljava/nio/ByteBuffer;");
    jmethodID putLong = env->GetMethodID(ByteBuffer, "putLong", "(J)Ljava/nio/ByteBuffer;");
    jmethodID array = env->GetMethodID(ByteBuffer, "array", "()[B");
    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
    jint positionListMemory = offset * sizeDataByte;
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, -1);
    for (jint position = 0; position < sizeData; position++, positionListMemory += sizeDataByte) {
        jobject byteBuffer = env->CallStaticObjectMethod(ByteBuffer, allocate, sizeDataByte);
        byteBuffer = env->CallObjectMethod(byteBuffer, putLong, _data[position]);
        jbyteArray dataByte = (jbyteArray)env->CallObjectMethod(byteBuffer, array);
        jbyte *_dataByte = env->GetByteArrayElements(dataByte, NULL);
        for (jint positionBuffer = 0; positionBuffer < sizeDataByte; positionBuffer++) {
            listDataMemory[_currentMemory][positionListMemory + positionBuffer] = _dataByte[positionBuffer];
        }
    }
    executeKernel(env, commandQueue, _currentMemory, _sizeBlockMemory, _flagsBlockMemory, _flagsMapMemory, 6);
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jmethodID constructorHashMap = env->GetMethodID(HashMap, "<init>", "()V");
    jmethodID put = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jstring byteArrayMemory = env->NewStringUTF("byteArrayMemory");
    jstring shortArrayMemory = env->NewStringUTF("shortArrayMemory");
    jstring intArrayMemory = env->NewStringUTF("intArrayMemory");
    jstring floatArrayMemory = env->NewStringUTF("floatArrayMemory");
    jstring longArrayMemory = env->NewStringUTF("longArrayMemory");
    jobject _dataMemory = env->NewObject(HashMap, constructorHashMap);
    jsize sizeBlock = _sizeBlockMemory / sizeof(jlong);
    jbyteArray _dataByte = env->NewByteArray(_sizeBlockMemory);
    jshortArray _dataShort = env->NewShortArray(sizeBlock);
    jintArray _dataInt = env->NewIntArray(sizeBlock);
    jfloatArray _dataFloat = env->NewFloatArray(sizeBlock);
    jlongArray _dataLong = env->NewLongArray(sizeBlock);
    env->SetByteArrayRegion(_dataByte, 0, _sizeBlockMemory, dataByte);
    env->SetShortArrayRegion(_dataShort, 0, sizeBlock, dataShort);
    env->SetIntArrayRegion(_dataInt, 0, sizeBlock, dataInt);
    env->SetFloatArrayRegion(_dataFloat, 0, sizeBlock, dataFloat);
    env->SetLongArrayRegion(_dataLong, 0, sizeBlock, dataLong);
    env->CallObjectMethod(_dataMemory, put, byteArrayMemory, _dataByte);
    env->CallObjectMethod(_dataMemory, put, shortArrayMemory, _dataShort);
    env->CallObjectMethod(_dataMemory, put, intArrayMemory, _dataInt);
    env->CallObjectMethod(_dataMemory, put, floatArrayMemory, _dataFloat);
    env->CallObjectMethod(_dataMemory, put, longArrayMemory, _dataLong);
    env->SetObjectField(memory, dataMemory, _dataMemory);
}
JNICALL jstring Java_com_draico_asvappra_opencl_memory_Memory_toString(JNIEnv *env, jobject memory) {
    jclass Memory = env->GetObjectClass(memory);
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jint _currentMemory = env->GetIntField(memory, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "The memory block you are using has already been released with the freeMemory method or the enqueueFreeMemory ");
        strcat(message, "method, use another memory block");
        showMessageError(env, message);
        return NULL;
    }
    return memoryToString(env, memory);
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_createImage(JNIEnv *env, jclass Image, jobject context, jobject imageFormat,
                                        jobject imageDescriptor, jbyteArray dataImage, jint flags) {
    if (context == NULL || imageFormat == NULL || imageDescriptor == NULL || dataImage == NULL) {
        char *message = (char*)malloc(sizeof(char) * 147);
        strcpy(message, "You cannot create the Image object because the context and/or the ImageFormat object and/or the ");
        strcat(message, "ImageDescriptor object and/or the image data are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeArray = env->GetArrayLength(dataImage);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot create the image because the dataImage array that provided this is empty");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jclass ImageFormat = env->GetObjectClass(imageFormat);
    jclass ImageDescriptor = env->GetObjectClass(imageDescriptor);
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentImageFormat = env->GetIntField(imageFormat, currentImageFormat);
    jint _currentImageDescriptor = env->GetIntField(imageDescriptor, currentImageDescriptor);
    jint currentData;
    if (_currentContext == -1 || _currentImageFormat == -1 || _currentImageDescriptor == -1) {
        char *message = (char*)malloc(sizeof(char) * 152);
        strcpy(message, "You cannot create the Image object because the context and/or the ImageFormat object and/or the ");
        strcat(message, "ImageDescriptor object and/or the image data are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _flags = flags;
    if ((_flags & (1 << 0)) == 1 << 0) _flags -= 1 << 0;
    if ((_flags & (1 << 1)) == 1 << 1) _flags -= 1 << 1;
    if ((_flags & (1 << 2)) == 1 << 2) _flags -= 1 << 2;
    if ((_flags & (1 << 3)) == 1 << 3) _flags -= 1 << 3;
    if ((_flags & (1 << 5)) == 1 << 5) _flags -= 1 << 5;
    if (_flags != 0) {
        char *message = (char*)malloc(sizeof(char) * 233);
        strcpy(message, "You cannot create the Image object because the flags variable is incorrect, you can only use the following ");
        strcat(message, "values:\nImage.IMAGE_READ_WRITE\nImage.IMAGE_WRITE_ONLY\nImage.IMAGE_READ_ONLY\nImage.IMAGE_USE_HOST_PTR\n");
        strcat(message, "Image.IMAGE_COPY_HOST_PTR");
        showMessageError(env, message);
        return NULL;
    }
    jbyte *_dataImage = env->GetByteArrayElements(dataImage, NULL);
    void **Result = GetCreateImage(_currentContext, flags, _currentImageFormat, _currentImageDescriptor, currentData, _dataImage);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jobject image;
        image = env->AllocObject(Image);
        jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
        jfieldID _context = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID _imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
        jfieldID _imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
        jfieldID _dataImage = env->GetFieldID(Image, "dataImage", "[B");
        jfieldID flagsImage = env->GetFieldID(Image, "flags", "I");
        env->SetIntField(image, currentImage, positionCurrentImage);
        env->SetObjectField(image, _context, context);
        env->SetObjectField(image, _imageFormat, imageFormat);
        env->SetObjectField(image, _imageDescriptor, imageDescriptor);
        env->SetObjectField(image, _dataImage, dataImage);
        env->SetIntField(image, flagsImage, flags);
        positionCurrentImage++;
        return image;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_readImage(JNIEnv *env, jobject image, jobject commandQueue, jobject buffer,
                                      jboolean isBlockingRead, jintArray origin, jintArray region, jint numberBytesPerRow,
                                      jint numberBytesPerLayer) {
    if (commandQueue == NULL || buffer == NULL || origin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 147);
        strcpy(message, "You cannot read the image because the CommandQueue object and/or the buffer and/or the origin array and/or ");
        strcat(message, "the region array are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 61);
        strcpy(message, "You cannot read the image because the Image object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentCommandQueue == -1 || _currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "You cannot read the image because the CommandQueue object or the buffer is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextBuffer = env->GetObjectField(buffer, contextBuffer);
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    if (!env->IsSameObject(_contextBuffer, _contextCommandQueue)) {
        char *message = (char*)malloc(sizeof(char) * 109);
        strcpy(message, "You cannot read the image because the buffer and the CommandQueue object were not created in the same context");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    if (sizeOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 150);
        strcpy(message, "You cannot read the image because the length of the original array or region array is greater than or less ");
        strcat(message, "than 3, both arrays must have a length of 3");
        showMessageError(env, message);
        return NULL;
    }
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    jfieldID imageType = env->GetFieldID(Image, "imageType", "I");
    jint _imageType = env->GetIntField(image, imageType);
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 && _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 346);
            strcpy(message, "You cannot read the image because the value of position 1 and 2 of the origin array have a value other ");
            strcat(message, "than 0, since the ImageDescriptor object was created with the image type of ImageDescriptor.TYPE_IMAGE1D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 && _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 196);
            strcpy(message, "You cannot read the image because the value of positions 1 and 2 of the region array is not 1, since the ");
            strcat(message, "ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 189);
            strcpy(message, "You cannot read the image because the value of position 2 of the origin array is not 0, since the ");
            strcat(message, "ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 189);
            strcpy(message, "You cannot read the image because the value of position 2 of the region array is not 1, since the ");
            strcat(message, "ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID _numberBytesPerRow = env->GetFieldID(ImageDescriptor, "numberBytesPerRow", "I");
    jfieldID _numberBytesPerLayer = env->GetFieldID(ImageDescriptor, "numberBytesPerLayer", "I");
    jint __numberBytesPerRow = env->GetIntField(_imageDescriptor, _numberBytesPerRow);
    jint __numberBytesPerLayer = env->GetIntField(_imageDescriptor, _numberBytesPerLayer);
    if (numberBytesPerRow < __numberBytesPerRow || numberBytesPerLayer < __numberBytesPerLayer) {
        char *message = (char*)malloc(sizeof(char) * 216);
        strcpy(message, "It cannot read the image because the value of the numberBytesPerRow variable or of the numberBytesPerLayer ");
        strcat(message, "variable is less than the value of the same variable that you calculated to create the ImageDescriptor object");
        showMessageError(env, message);
        return NULL;
    }
    size_t __origin[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[2], (size_t)_region[3] };
    void **Result = GetEnqueueReadImage(_currentCommandQueue, _currentImage, isBlockingRead, __origin, __region, numberBytesPerRow,
    numberBytesPerLayer, _currentBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_writeImage(JNIEnv *env, jobject image, jobject commandQueue, jobject buffer,
                                       jboolean isBlockingWrite, jintArray origin, jintArray region, jint numberBytesPerRow,
                                       jint numberBytesPerLayer) {
    if (commandQueue == NULL || buffer == NULL || origin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 148);
        strcpy(message, "You cannot write the image because the CommandQueue object and/or the buffer and/or the origin array and/or ");
        strcat(message, "the region array are set to a null value");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 62);
        strcpy(message, "You cannot write the image because the Image object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentCommandQueue == -1 || _currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot write the image because the CommandQueue object or the buffer is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextBuffer = env->GetObjectField(buffer, contextBuffer);
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    if (!env->IsSameObject(_contextBuffer, _contextCommandQueue)) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "You cannot write the image because the buffer and the CommandQueue object were not created in the same context");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    if (sizeOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 151);
        strcpy(message, "You cannot write the image because the length of the original array or region array is greater than or less ");
        strcat(message, "than 3, both arrays must have a length of 3");
        showMessageError(env, message);
        return NULL;
    }
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    jfieldID imageType = env->GetFieldID(Image, "imageType", "I");
    jint _imageType = env->GetIntField(image, imageType);
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 && _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 347);
            strcpy(message, "You cannot write the image because the value of position 1 and 2 of the origin array have a value other ");
            strcat(message, "than 0, since the ImageDescriptor object was created with the image type of ImageDescriptor.TYPE_IMAGE1D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 && _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 197);
            strcpy(message, "You cannot write the image because the value of positions 1 and 2 of the region array is not 1, since ");
            strcat(message, "the ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 190);
            strcpy(message, "You cannot write the image because the value of position 2 of the origin array is not 0, since the ");
            strcat(message, "ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 190);
            strcpy(message, "You cannot write the image because the value of position 2 of the region array is not 1, since the ");
            strcat(message, "ImageDescriptor object was created using the image type ImageDescriptor.TYPE_IMAGE_1D_ARRAY");
            showMessageError(env, message);
            return NULL;
        }
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID _numberBytesPerRow = env->GetFieldID(ImageDescriptor, "numberBytesPerRow", "I");
    jfieldID _numberBytesPerLayer = env->GetFieldID(ImageDescriptor, "numberBytesPerLayer", "I");
    jint __numberBytesPerRow = env->GetIntField(_imageDescriptor, _numberBytesPerRow);
    jint __numberBytesPerLayer = env->GetIntField(_imageDescriptor, _numberBytesPerLayer);
    if (numberBytesPerRow < __numberBytesPerRow || numberBytesPerLayer < __numberBytesPerLayer) {
        char *message = (char*)malloc(sizeof(char) * 217);
        strcpy(message, "It cannot write the image because the value of the numberBytesPerRow variable or of the numberBytesPerLayer ");
        strcat(message, "variable is less than the value of the same variable that you calculated to create the ImageDescriptor object");
        showMessageError(env, message);
        return NULL;
    }
    size_t __origin[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[2], (size_t)_region[3] };
    void **Result = GetEnqueueWriteImage(_currentCommandQueue, _currentImage, isBlockingWrite, __origin, __region, numberBytesPerRow,
                                         numberBytesPerLayer, _currentBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_copyImage(JNIEnv *env, jobject image, jobject commandQueue, jobject imageSrc,
                                      jintArray srcOrigin, jintArray dstOrigin, jintArray region) {
    if (commandQueue == NULL || imageSrc == NULL || srcOrigin == NULL || dstOrigin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 171);
        strcpy(message, "You cannot copy the image because the CommandQueue object and/or the imageSrc object and/or the srcOrigin array ");
        strcat(message, "and/or the dstOrigin array and/or the region array are null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot copy the image you are using to call the copyImage method is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentImageSrc = env->GetIntField(imageSrc, currentImage);
    if (_currentCommandQueue == -1 || _currentImageSrc == -1) {
        char *message = (char*)malloc(sizeof(char) * 93);
        strcpy(message, "You cannot copy the image because the CommandQueue object and/or the source image are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeSrcOrigin = env->GetArrayLength(srcOrigin);
    jsize sizeDstOrigin = env->GetArrayLength(dstOrigin);
    jsize sizeRegion = env->GetArrayLength(region);
    if (sizeSrcOrigin != 3 || sizeDstOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 99);
        strcpy(message, "You cannot copy the image because the length of the srcOrigin, dstOrigin and region arrays is not 3");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jobject _imageDescriptorSrc = env->GetObjectField(imageSrc, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jint _currentImageDesciptor = env->GetIntField(_imageDescriptor, currentImageDescriptor);
    jint _currentImageDescriptorSrc = env->GetIntField(_imageDescriptorSrc, currentImageDescriptor);
    if (_currentImageDesciptor == -1 || _currentImageDescriptorSrc == -1) {
        char *message = (char*)malloc(sizeof(char) * 152);
        strcpy(message, "You cannot copy the image because the ImageDescriptor object of the image object you are currently using ");
        strcat(message, "and/or of the imageSrc image object are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextImage = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jobject _contextImageSrc = env->GetObjectField(imageSrc, contextImage);
    jobject _contextImageDst = env->GetObjectField(image, contextImage);
    if (!env->IsSameObject(_contextImageDst, _contextImageSrc)) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot copy the source image to the destination image because both Image objects were created with a ");
        strcat(message, "different context");
        showMessageError(env, message);
        return NULL;
    }
    if (!env->IsSameObject(_contextCommandQueue, _contextImageDst)) {
        char *message = (char*)malloc(sizeof(char) * 215);
        strcpy(message, "You cannot copy the source image to the destination image because the context used to create both the ");
        strcat(message, "destination and the source Image objects is different from the context you used to create the CommandQueue ");
        strcat(message, "object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jint _imageType = env->GetIntField(_imageDescriptor, imageType);
    jint _imageSrcType = env->GetIntField(_imageDescriptorSrc, imageType);
    if (_imageType != _imageSrcType) {
        char *message = (char*)malloc(sizeof(char) * 184);
        strcpy(message, "You cannot copy from the source image object because both the source image object and the image object you ");
        strcat(message, "are using to use the copyImage method were created with different image types");
        showMessageError(env, message);
        return NULL;
    }
    jint *_srcOrigin = env->GetIntArrayElements(srcOrigin, NULL);
    jint *_dstOrigin = env->GetIntArrayElements(dstOrigin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_srcOrigin[1] != 0 || _srcOrigin[2] != 0 || _dstOrigin[1] != 0 || _dstOrigin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 285);
            strcpy(message, "You cannot copy from the srcOrigin array or the dstOrigin array in position 1 and 2 is not set to 0, ");
            strcat(message, "since the image type set for the source Image object as the destination Image object was created with ");
            strcat(message, "the Image type imageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1D_BUFFER");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 || _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 256);
            strcpy(message, "You cannot copy from the region array in positions 1 and 2 is not set to a value of 1, since both the ");
            strcat(message, "source Image object and the destination Image object were created using the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1D_BUFFER");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5 && (_srcOrigin[2] != 0 || _dstOrigin[2] != 0)) {
        char *message = (char*)malloc(sizeof(char) * 246);
        strcpy(message, "You cannot copy from the srcOrigin array or the dstOrigin array in position 2 is not set to 0, since the ");
        strcat(message, "image type set for the source Image object as the destination Image object was created with the image type ");
        strcat(message, "ImageDescriptor.TYPE_IMAGE1D_ARRAY");
        showMessageError(env, message);
        return NULL;
    }
    if ((_imageType == 0x10F1 || _imageType == 0x10F5) && _region[2] != 1) {
        char *message = (char*)malloc(sizeof(char) * 249);
        strcpy(message, "You cannot copy from the region array in positions 2 is not set to a value of 1, since both the source ");
        strcat(message, "Image object and the destination Image object were created using the image type ");
        strcat(message, "ImageDescriptor.TYPE_IMAGE1D_ARRAY or ImageDescriptor.TYPE_IMAGE2D");
        showMessageError(env, message);
        return NULL;
    }
    size_t __srcOrigin[] = { (size_t)_srcOrigin[0], (size_t)_srcOrigin[1], (size_t)_srcOrigin[2] };
    size_t __dstOrigin[] = { (size_t)_dstOrigin[0], (size_t)_dstOrigin[1], (size_t)_dstOrigin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    void **Result = GetEnqueueCopyImage(_currentCommandQueue, _currentImageSrc, _currentImage, __srcOrigin, __dstOrigin, __region);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_fillImage(JNIEnv *env, jobject image, jobject commandQueue, jobject fillColor,
                                      jintArray origin, jintArray region) {
    if (commandQueue == NULL || fillColor == NULL || origin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 149);
        strcpy(message, "You cannot fill the Image object because the CommandQueue object and/or the fill color and/or the origin ");
        strcat(message, "array and/or the region array are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "You cannot fill the Image object because the Image object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 75);
        strcpy(message, "You cannot fill the Image object because the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Class = env->FindClass("java/lang/Class");
    jclass Object = env->FindClass("java/lang/Object");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jobject objectClass = env->CallObjectMethod(fillColor, getClass);
    jboolean _isArray = env->CallBooleanMethod(objectClass, isArray);
    if (!_isArray) {
        char *message = (char*)malloc(sizeof(char) * 236);
        strcpy(message, "You cannot fill the Image object with the fill color, because the fillColor object is not an array of the ");
        strcat(message, "type of data you set in the imageChannelDataType variable, to create an ImageFormat object that you use to ");
        strcat(message, "create the Image object");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray fillColorArray = (jobjectArray)fillColor;
    jsize sizeFillColor = env->GetArrayLength(fillColorArray);
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageFormat = env->GetObjectClass(_imageFormat);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jfieldID imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jint _imageChannelOrder = env->GetIntField(_imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(_imageFormat, imageChannelDataType);
    jint _imageType = env->GetIntField(_imageDescriptor, imageType);
    jstring nameArray = (jstring)env->CallObjectMethod(objectClass, getName);
    const char *_nameArray = env->GetStringUTFChars(nameArray, NULL);
    if (strcmp(_nameArray, "[I") != 0 || strcmp(_nameArray, "[S") != 0 || strcmp(_nameArray, "[F") != 0 || strcmp(_nameArray, "[B") != 0 ||
        strcmp(_nameArray, "[Ljava/lang/Integer;") != 0 || strcmp(_nameArray, "[Ljava/lang/Short;") != 0 ||
        strcmp(_nameArray, "[Ljava/lang/Float;") != 0 || strcmp(_nameArray, "[Ljava/lang/Byte;") != 0) {
        char *message = (char*)malloc(sizeof(char) * 191);
        strcpy(message, "You cannot fill color on the Image object because the array you provided is not of the primitive type ");
        strcat(message, "such as int, byte, short, float or of the object type such as Integer, Byte, Short, Float");
        showMessageError(env, message);
        return NULL;
    }
    jsize _sizeFillColor;
    switch(_imageChannelOrder) {
        case 0x10B0: case 0x10B1: case 0x10B8: case 0x10B9: case 0x10BA: case 0x10BD: _sizeFillColor = 1; break;
        case 0x10B2: case 0x10B3: case 0x10BB: case 0x10BE: _sizeFillColor = 2; break;
        case 0x10B4: case 0x10BC: _sizeFillColor = 3; break;
        case 0x10B5: case 0x10B6: case 0x10B7: case 0x10BF: case 0x10C0: case 0x10C3: _sizeFillColor = 4; break;
        case 0x10C1: case 0x10C2: _sizeFillColor = 5; break;
    }
    if (sizeFillColor != _sizeFillColor || sizeOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 341);
        strcpy(message, "You cannot fill the Image object because the length of the fillColor array must be equal to the type ");
        strcat(message, "of format you selected when you created the ImageFormat object that you used to create the Image object ");
        strcat(message, "(value of the imageChannelOrder variable), another possible problem is that the length of the origin and ");
        strcat(message, "region arrays is not equal to 3");
        showMessageError(env, message);
        return NULL;
    }
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    if (_origin[0] < 0 || _origin[1] < 0 || _origin[2] < 0) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "You cannot perfom fill in the color of the Image object because the origin array you set values less than 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_region[0] <= 0 || _region[1] <= 0 || _region[2] <= 0) {
        char *message = (char*)malloc(sizeof(char) * 116);
        strcpy(message, "You cannot perfom fill in the color of the Image object because the region array you set values less or ");
        strcat(message, "equal than 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_imageType == 0x10F1) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 296);
            strcpy(message, "You cannot perform fill the color of the Image object because position 2 of the origin array is not ");
            strcat(message, "set to 0 (the origion array represents the offset x, y and z), since the Image object was created ");
            strcat(message, "using an ImageDescriptor object that was created using the ImageDescriptor.TYPE_IMAGE2D image type");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 402);
            strcpy(message, "You cannot color fill the Image object because position 2 of the region array is not set to value 1, ");
            strcat(message, "since the region array contains the width, height, and depth values of the image, so in an image that ");
            strcat(message, "has been created using an ImageDescriptor object, which has been created using the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D, means that in depth (position 2 of the region array) only work with ");
            strcat(message, "1 layer");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 || _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 369);
            strcpy(message, "You cannot perform fill in the image object because the Image object you created using an ");
            strcat(message, "ImageDescriptor object which was created using the image type ImageDescriptor.TYPE_IMAGE1D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER and therefore the data in positions 1 and 2 of the array ");
            strcat(message, "origin must be set to 0, since the origin array represents the offset for positions x, y and z");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 || _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 363);
            strcpy(message, "You cannot color fill the Image object because positions 1 and 2 of the region array are not set to ");
            strcat(message, "value 1, since the region array contains the width, height, and depth values of the image, so in an ");
            strcat(message, "image that has created using an ImageDescriptor object, which was created using the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D and ImageDescriptor.TYPE_IMAGE1D_BUFFER");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 279);
            strcpy(message, "You cannot fill the Image object because you created the Image object using an ImageDescriptor object ");
            strcat(message, "using the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY and therefore position 2 of the origin array ");
            strcat(message, "must always be set to 0 (the origion array represents the offset x, y and z)");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 403);
            strcpy(message, "You cannot perfom fill the color of the Image object because the value of position 2 of the region ");
            strcat(message, "array is not set to 1 (since the region array defines the width, height and depth), since you created ");
            strcat(message, "the Image object using an ImageDescriptor object the which was created using the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_ARRAY the value of the depth position of the region array must always be ");
            strcat(message, "set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Byte = env->FindClass("java/lang/Byte");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
    jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
    const size_t __origin[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    const size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[1] };
    void **Result;
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D7: {
                cl_char *dataFill = (cl_char*)malloc(sizeof(cl_char) * sizeFillColor);
                if (strcmp(_nameArray, "[B") == 0) {
                    const jint *data = env->GetIntArrayElements((jintArray) fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        if (data[position] > 128 || data[position] < -127) {
                            char *message = (char*)malloc(sizeof(char) * 193);
                            strcpy(message, "You cannot performed color fill the Image object because the value you provided in the ");
                            strcat(message, "signed byte array exceeds the allowed limit that is 127 for positive numbers and -128 ");
                            strcat(message, "for negative numbers");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFill[position] = data[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Byte;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _byteValue = env->GetObjectArrayElement(fillColorArray, position);
                        jint value = env->CallByteMethod(_byteValue, byteValue);
                        if (value > 127 || value < -128) {
                            char *message = (char*)malloc(sizeof(char) * 234);
                            strcpy(message,"You cannot performed fill color the Image object because the value that the value you ");
                            strcat(message, "provided in the signed Byte array exceeds the allowed limit that is 127 for positive ");
                            strcat(message, "numbers and -128 for negative numbers of the signed Byte object");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFill[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 240);
                    strcpy(message, "You cannot perform the fill color on the Image object because the type of data that you set ");
                    strcat(message, "on the ImageFormat object was of the ImageFormat.SNORM_INT8 or ImageFormat.SIGNED_INT8 type ");
                    strcat(message, "so you can only use an array of the byte or Byte ");
                    strcat(message, "type");
                    showMessageError(env, message);
                    return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFill, __origin, __region);
            }
            break;
        case 0x10D1: case 0x10D8: {
                cl_short *dataFillShort = (cl_short*)malloc(sizeof(cl_short) * sizeFillColor);
                if (strcmp(_nameArray, "[S") == 0) {
                    const jshort *dataShortPrimitive = env->GetShortArrayElements((jshortArray) fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        if (dataShortPrimitive[position] > 32767 || dataShortPrimitive[position] < -32768) {
                            char *message = (char*)malloc(sizeof(char) * 234);
                            strcpy(message, "You cannot performed fill color the Image object because the value that the value you ");
                            strcat(message, "provided in the signed short array exceeds the allowed limit that is 32767 for ");
                            strcat(message, "positive numbers and -32768 for negative numbers of type signed short");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFillShort[position] = dataShortPrimitive[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Short;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _shortValue = env->GetObjectArrayElement(fillColorArray, NULL);
                        jshort value = env->CallShortMethod(_shortValue, shortValue);
                        if (value > 32767 || value < -32768) {
                            char *message = (char*)malloc(sizeof(char) * 241);
                            strcpy(message, "You cannot performed fill color the Image object because the value that the value ");
                            strcat(message, "you provided in the signed Short array exceeds the allowed limit that is 32767 for ");
                            strcat(message, "positive numbers and -32768 for negative numbers of type signed Short object");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFillShort[position] = value;
                    }
                } else {
                char *message = (char*)malloc(sizeof(char) * 113);
                strcpy(message, "You cannot perform the fill in color because the data array you provided is not of the short type or ");
                strcat(message, "Short object");
                showMessageError(env, message);
                return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillShort, __origin, __region);
            }
            break;
        case 0x10D9: {
                cl_int *dataFillInt = (cl_int*)malloc(sizeof(cl_int) * sizeFillColor);
                if (strcmp(_nameArray, "[I") == 0) {
                    jint *dataInt = env->GetIntArrayElements((jintArray) fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        if (dataInt[position] > 2147483647 || dataInt[position] < -2147483648) {
                            char *message = (char*)malloc(sizeof(char) * 229);
                            strcpy(message, "You cannot perform fill color of the Image object because some of the arrangement data ");
                            strcat(message, "of the signed int type that you provided exceeds the limit for positive numbers which ");
                            strcat(message, "is 2147483647 and for negative numbers it is -2147483648");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFillInt[position] = dataInt[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Integer;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _intValue = env->GetObjectArrayElement(fillColorArray, position);
                        jint value = env->CallIntMethod(_intValue, intValue);
                        if (value > 2147483647 || value < -2147483648) {
                            char *message = (char*)malloc(sizeof(char) * 233);
                            strcpy(message, "You cannot perform fill color of the Image object because some of the array data of the ");
                            strcat(message, "Integer signedobject type that you provided exceeds the limit for positive numbers that ");
                            strcat(message, "is 2147483647 and for negative numbers it is -2147483648");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFillInt[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 111);
                    strcpy(message, "You cannot perform color fill the Image object because the array you provided is not of the int or ");
                    strcat(message, "Integer type");
                    showMessageError(env, message);
                    return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillInt, __origin, __region);
            }
            break;
        case 0x10D2: case 0x10DA: {
                cl_uchar *dataFillUnsigned = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeFillColor);
                if (strcmp(_nameArray, "[B") == 0) {
                    jbyte *data = env->GetByteArrayElements((jbyteArray)fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        dataFillUnsigned[position] = data[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Byte;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _byteValue = env->GetObjectArrayElement(fillColorArray, position);
                        jbyte value = env->CallByteMethod(_byteValue, byteValue);
                        dataFillUnsigned[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 122);
                    strcpy(message, "You cannot perform fill the color of the Image object because the arrangement you provided is not ");
                    strcat(message, "of the byte or byte type");
                    showMessageError(env, message);
                    return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillUnsigned, __origin, __region);
            }
            break;
        case 0x10D3: case 0x10DB: {
                cl_ushort *dataFillShortUnsigned = (cl_ushort*)malloc(sizeof(cl_ushort) * sizeFillColor);
                if (strcmp(_nameArray, "[S") == 0) {
                    jshort *dataShort = env->GetShortArrayElements((jshortArray) fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        dataFillShortUnsigned[position] = dataShort[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Short;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _shortValue = env->GetObjectArrayElement(fillColorArray, position);
                        jshort value = env->CallShortMethod(_shortValue, shortValue);
                        dataFillShortUnsigned[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 99);
                    strcpy(message, "You cannot perform fill color because the data array you provided is not of the short or Short type");
                    showMessageError(env, message);
                    return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillShortUnsigned, __origin, __region);
            }
            break;
        case 0x10DC: {
                cl_uint *dataFillIntUnsigned = (cl_uint*)malloc(sizeof(cl_uint) * sizeFillColor);
                if (strcmp(_nameArray, "[I") == 0) {
                    jint *dataInt = env->GetIntArrayElements((jintArray)fillColorArray, NULL);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        dataFillIntUnsigned[position] = dataInt[position];
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Integer;") == 0) {
                    for (jint position = 0; position < sizeFillColor; position++) {
                    jobject _intValue = env->GetObjectArrayElement(fillColorArray, position);
                    jint value = env->CallIntMethod(_intValue, intValue);
                    dataFillIntUnsigned[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 99);
                    strcpy(message, "You cannot perform fill color because the data array you provided is not of the int or Integer type");
                    showMessageError(env, message);
                    return NULL;
                }
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillIntUnsigned, __origin, __region);
            }
            break;
        case 0x10D4: {
                if (sizeFillColor != 3 || _imageChannelOrder != 0x10B4) {
                    char *message = (char*)malloc(sizeof(char) * 196);
                    strcpy(message, "You cannot perform fill color of the Image object because the array you provided is not 3 in length,");
                    strcat(message, "since the format you set is not ImageFormat.RGB to use the ImageFormat.UNORM_SHORT565 data type");
                    showMessageError(env, message);
                    return NULL;
                }
                cl_ushort *dataFillShort565 = (cl_ushort*)malloc(sizeof(cl_ushort));
                jshort *dataRGB565;
                if (strcmp(_nameArray, "[S") == 0) {
                    dataRGB565 = env->GetShortArrayElements((jshortArray) fillColorArray, NULL);
                    if (dataRGB565[0] > 31 || dataRGB565[1] > 63 || dataRGB565[2] > 31) {
                        char *message = (char *) malloc(sizeof(char) * 454);
                        strcpy(message, "You cannot perform fill the color in the Image object because you adjusted the ImageFormat.RGB");
                        strcat(message, "format with the ImageFormat.UNORM_SHORT565 data type, but the data you provided in the short or");
                        strcat(message, "Short type array exceeds the allowed limit for each RGB value, the maximum value for red (R) ");
                        strcat(message, "is 31 since it is a 5-bit number, the maximum value for green (G) is 63 since it is a 6-bit ");
                        strcat(message, "number, and the maximum value for blue (B) is of 31 since it is a 5-bit number");
                        showMessageError(env, message);
                        return NULL;
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Short;") == 0) {
                    dataRGB565 = (jshort*)malloc(sizeof(jshort) * sizeFillColor);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _shortValue = env->GetObjectArrayElement(fillColorArray, position);
                        jshort value = env->CallShortMethod(_shortValue, shortValue);
                        if ((value > 31 && position != 1) || (value > 63 && position == 1)) {
                            char *message = (char*)malloc(sizeof(char) * 454);
                            strcpy(message, "You cannot perform fill the color in the Image object because you adjusted the ");
                            strcat(message, "ImageFormat.RGB format with the ImageFormat.UNORM_SHORT565 data type, but the data you ");
                            strcat(message, "provided in the short or Short type array exceeds the allowed limit for each RGB value, ");
                            strcat(message, "the maximum value for red (R) is 31 since it is a 5-bit number, the maximum value for ");
                            strcat(message, "green (G) is 63 since it is a 6-bit number, and the maximum value for blue (B) is of 31 ");
                            strcat(message, "since it is a 5-bit number");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataRGB565[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 193);
                    strcpy(message, "You cannot perform color fill the Image object because the data array you provided for the ");
                    strcat(message, "ImageFormat.RGB format with the ImageFormat.UNORM_SHORT565 data type is not of the short or ");
                    strcat(message, "Short type");
                    showMessageError(env, message);
                    return NULL;
                }
                *dataFillShort565 = dataRGB565[2];
                *dataFillShort565 |= dataRGB565[1] << 5;
                *dataFillShort565 |= dataRGB565[0] << 11;
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillShort565, __origin, __region);
            }
            break;
        case 0x10D5: {
                if (sizeFillColor != 3 || _imageChannelOrder != 0x10B4) {
                    char *message = (char*)malloc(sizeof(char) * 193);
                    strcpy(message, "You cannot perform color fill the Image object because the data array you provided for the ");
                    strcat(message, "ImageFormat.RGB format with the ImageFormat.UNORM_SHORT555 data type is not of the short or ");
                    strcat(message, "Short type");
                    showMessageError(env, message);
                    return NULL;
                }
                cl_ushort *dataFillShort555 = (cl_ushort*)malloc(sizeof(cl_ushort));
                jshort *dataRGB555;
                if (strcmp(_nameArray, "[S") == 0) {
                    dataRGB555 = env->GetShortArrayElements((jshortArray)fillColorArray, NULL);
                    if (dataRGB555[0] > 31 || dataRGB555[1] > 31 || dataRGB555[2] > 31) {
                        char *message = (char*)malloc(sizeof(char) * 452);
                        strcpy(message, "You cannot fill the color in the Image object because the values of the data array that you ");
                        strcat(message, "provided for the ImageFormat.RGB format with the ImageFormat.UNORM_SHORT555 data type exceed ");
                        strcat(message, "the allowed limits, for the red (R) color having only 5 bits In length, only 31 can be the ");
                        strcat(message, "maximum value, for the green color (G) it is also 5 bits long and also only allows 31 as the ");
                        strcat(message, "maximum value, and the blue color (B) is 5 bits and only allows 31 as maximum value");
                        showMessageError(env, message);
                        return NULL;
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Short;") == 0) {
                    dataRGB555 = (jshort*)malloc(sizeof(jshort) * sizeFillColor);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _shortValue = env->GetObjectArrayElement(fillColorArray, position);
                        jshort value = env->CallShortMethod(_shortValue, shortValue);
                        if (value > 31) {
                            char *message = (char*)malloc(sizeof(char) * 452);
                            strcpy(message, "You cannot fill the color in the Image object because the values of the data array that you ");
                            strcat(message, "provided for the ImageFormat.RGB format with the ImageFormat.UNORM_SHORT555 data type exceed ");
                            strcat(message, "the allowed limits, for the red (R) color having only 5 bits In length, only 31 can be the ");
                            strcat(message, "maximum value, for the green color (G) it is also 5 bits long and also only allows 31 as the ");
                            strcat(message, "maximum value, and the blue color (B) is 5 bits and only allows 31 as maximum value");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataRGB555[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 198);
                    strcpy(message, "You cannot perform color fill the Image object because the data array that you provided for the ");
                    strcat(message, "ImageFormat.RGB format with the ImageFormat.UNORM_SHORT555 data type is not of the short or Short type");
                    showMessageError(env, message);
                    return NULL;
                }
                dataFillShort555[0] = dataRGB555[2];
                dataFillShort555[1] |= dataRGB555[1] << 5;
                dataFillShort555[2] |= dataRGB555[0] << 10;
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillShort555, __origin, __region);
            }
            break;
        case 0x10D6: {
                if (sizeFillColor != 3 || _imageChannelOrder != 0x10B4) {
                    char *message = (char*)malloc(sizeof(char) * 240);
                    strcpy(message, "You cannot perform fill the color in the Image object because the format that you set in the ");
                    strcat(message, "imageChannelOrder variable of the ImageFormat object is not the ImageFormat.RGB format, so you ");
                    strcat(message, "cannot use the ImageFormat.UNORM_INT101010 data type");
                    showMessageError(env, message);
                    return NULL;
                }
                cl_uint *dataFillUnsignedInt101010 = (cl_uint*)malloc(sizeof(cl_uint));
                jint *dataFillInt101010;
                if (strcmp(_nameArray, "[I") == 0) {
                    dataFillInt101010 = env->GetIntArrayElements((jintArray) fillColorArray, NULL);
                    if (dataFillInt101010[0] > 1023 || dataFillInt101010[1] > 1023 || dataFillInt101010[2] > 1023) {
                        char *message = (char*)malloc(sizeof(char) * 322);
                        strcpy(message, "You cannot perform fill the color in the Image object because the array values you provided ");
                        strcat(message, "for use with the ImageFormat.RGB format and with the ImageFormat.UNORM_INT101010 data type ");
                        strcat(message, "are out of range, since the values are 10 bits for each color , therefore the maximum value ");
                        strcat(message, "is 1023 each of the 3 colors (Red, Green, Blue)");
                        showMessageError(env, message);
                        return NULL;
                    }
                } else if (strcmp(_nameArray, "[Ljava/lang/Integer;") == 0) {
                    dataFillInt101010 = (jint *) malloc(sizeof(jint) * sizeFillColor);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _intValue = env->GetObjectArrayElement(fillColorArray, position);
                        jint value = env->CallIntMethod(_intValue, intValue);
                        if (value > 1023) {
                            char *message = (char*)malloc(sizeof(char) * 322);
                            strcpy(message, "You cannot perform fill the color in the Image object because the array values you ");
                            strcat(message, "provided for use with the ImageFormat.RGB format and with the ImageFormat.UNORM_INT101010");
                            strcat(message, "data type are out of range, since the values are 10 bits for each color, ");
                            strcat(message, "therefore the maximum value is 1023 each of the 3 colors (Red, Green, Blue)");
                            showMessageError(env, message);
                            return NULL;
                        }
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 209);
                    strcpy(message, "You cannot perform color fill the Image object because the data array you provided for use with ");
                    strcat(message, "the ImageFormat.RGB format and with the ImageFormat.UNORM_INT101010 data type is not an int or ");
                    strcat(message, "Integer type array");
                    showMessageError(env, message);
                    return NULL;
                }
                *dataFillUnsignedInt101010 = dataFillInt101010[2];
                *dataFillUnsignedInt101010 |= dataFillInt101010[1] << 10;
                *dataFillUnsignedInt101010 |= dataFillInt101010[0] << 20;
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillUnsignedInt101010, __origin, __region);
            }
            break;
        case 0x10E0: {
                if (sizeFillColor != 4 || _imageChannelOrder != 0x10B4) {
                    char *message = (char*)malloc(sizeof(char) * 243);
                    strcpy(message, "You cannot perform fill the color in the Image object because the format that you set in the ");
                    strcat(message, "imageChannelOrder variable of the ImageFormat object is not the ImageFormat.RGBA format, so you ");
                    strcat(message, "cannot use the ImageFormat.UNORM_INT101010_2 data type");
                    showMessageError(env, message);
                    return NULL;
                }
                cl_uint *dataFillUnsignedInt101010_2 = (cl_uint*)malloc(sizeof(cl_uint));
                jint *dataFillInt101010_2;
                if (strcmp(_nameArray, "[I") == 0) {
                dataFillInt101010_2 = env->GetIntArrayElements((jintArray)fillColorArray, NULL);
                if (dataFillInt101010_2[0] > 1023 || dataFillInt101010_2[1] > 1023 || dataFillInt101010_2[2] > 1023 ||
                    dataFillInt101010_2[3] > 3) {
                    char *message = (char*)malloc(sizeof(char) * 273);
                    strcpy(message, "You cannot perform color fill the Image object because the array values that you provided for the ");
                    strcat(message, "ImageFormat.RGBA format with the data type ImageFormat.UNORM_INT_101010_2 exceeds the allowed ");
                    strcat(message, "limit for the colors red, green, and blue that is 1023, and 3 for the alpha value");
                    showMessageError(env, message);
                    return NULL;
                }
                } else if (strcmp(_nameArray, "[Ljava/lang/Integer;") == 0) {
                    dataFillInt101010_2 = (jint*)malloc(sizeof(jint) * sizeFillColor);
                    for (jint position = 0; position < sizeFillColor; position++) {
                        jobject _intValue = env->GetObjectArrayElement(fillColorArray, position);
                        jint value = env->CallIntMethod(_intValue, intValue);
                        if ((value > 1023 && position != 3) || (value > 3 && position == 3)) {
                            char *message = (char*)malloc(sizeof(char) * 273);
                            strcpy(message, "You cannot perform color fill the Image object because the array values that you provided ");
                            strcat(message, "for the ImageFormat.RGBA format with the data type ImageFormat.UNORM_INT_101010_2 exceeds ");
                            strcat(message, "the allowed limit for the colors red, green, and blue that is 1023, and 3 for the ");
                            strcat(message, "alpha value");
                            showMessageError(env, message);
                            return NULL;
                        }
                        dataFillInt101010_2[position] = value;
                    }
                } else {
                    char *message = (char*)malloc(sizeof(char) * 196);
                    strcpy(message, "You cannot perform color fill the Image object because the array you provided for the ");
                    strcat(message, "ImageFormat.RGBA format using the ImageFormat.UNORM_INT_101010_2 data type is not an int or ");
                    strcat(message, "Integer type array");
                    showMessageError(env, message);
                    return NULL;
                }
                *dataFillUnsignedInt101010_2 = dataFillInt101010_2[3];
                *dataFillUnsignedInt101010_2 |= dataFillInt101010_2[2] << 2;
                *dataFillUnsignedInt101010_2 |= dataFillInt101010_2[1] << 12;
                *dataFillUnsignedInt101010_2 |= dataFillInt101010_2[0] << 22;
                Result = GetEnqueueFillImage(_currentCommandQueue, _currentImage, dataFillUnsignedInt101010_2, __origin, __region);
            }
            break;
    }
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_copyImageToBuffer(JNIEnv *env, jobject image, jobject commandQueue, jobject buffer,
    jintArray origin, jintArray region) {
    if (commandQueue == NULL || buffer == NULL || origin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 156);
        strcpy(message, "You cannot perform copy the Image object to the buffer because the CommandQueue object and/or the buffer ");
        strcat(message, "and/or the origin and region arrays are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentImage == -1 || _currentCommandQueue == -1 || _currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 140);
        strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object and/or the CommandQueue ");
        strcat(message, "object and/or the buffer are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    if (sizeOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 106);
        strcpy(message, "You cannot copy the Image object to the buffer because the length of the origin and region arrays is not 3");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageFormat = env->GetObjectClass(_imageFormat);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jfieldID imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jfieldID numberImages = env->GetFieldID(ImageDescriptor, "numberImages", "I");
    jint _currentImageFormat = env->GetIntField(_imageFormat, currentImageFormat);
    jint _currentImageDescriptor = env->GetIntField(_imageDescriptor, currentImageDescriptor);
    if (_currentImageFormat == -1 || _currentImageDescriptor == -1) {
        char *message = (char*)malloc(sizeof(char) * 163);
        strcpy(message, "You cannot copy the Image object to the buffer because the ImageFormat object and/or the ImageDescriptor object ");
        strcat(message, "that you used to create the Image object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _imageChannelOrder = env->GetIntField(_imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(_imageFormat, imageChannelDataType);
    jint _imageType = env->GetIntField(_imageDescriptor, imageType);
    jint _numberImages = env->GetIntField(_imageDescriptor, numberImages);
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    if (_origin[0] < 0 || _origin[1] < 0 || _origin[2] < 0) {
        char *message = (char*)malloc(sizeof(char) * 112);
        strcpy(message, "You cannot copy the Image object to the buffer because the data you provided for the origin array is less than 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_region[0] <= 0 || _region[1] <= 0 || _region[2] <= 0) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot copy the Image object to the buffer because the data you provided for the region array is less than or ");
        strcat(message, "equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_imageType == 0x10F1) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 330);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor type object, which was created using the image type ImageDescriptor.TYPE_IMAGE2D, since ");
            strcat(message, "the value of position 2 of the origin array is different from 0 (the origin array is used to adjust the ");
            strcat(message, "offset of x, y and z)");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 333);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor type object, which was created using the image type ImageDescriptor.TYPE_IMAGE2D, since ");
            strcat(message, "the value of position 2 of the region array is different from 1 (the region array is used to adjust the ");
            strcat(message, "width, height and depth)");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 || _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 290);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor object, which was created using the image type ImageDescriptor.TYPE_IMAGE1D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER, so positions 1 and 2 of the origin array must be set to 0");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 || _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 291);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor object, which was created using the image type ImageDescriptor.TYPE_IMAGE1D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER, so positions 1 and 2 of the origin region must be set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 250);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor object, which was created using the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY, so ");
            strcat(message, "position 2 of the origin array must be set to 0");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 250);
            strcpy(message, "You cannot perform copy the Image object to the buffer because the Image object was created using an ");
            strcat(message, "ImageDescriptor object, which was created using the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY, so ");
            strcat(message, "position 2 of the region array must be set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint numberChannels;
    jint numberBytesByTypeData;
    jint numberBytesPerPixel;
    size_t offsetCopyByImageType;
    switch(_imageChannelOrder) {
        case 0x10B0: case 0x10B1: case 0x10BA: case 0x10BE: numberChannels = 1; break;
        case 0x10B2: case 0x10B3: case 0x10BB: case 0x10BD: numberChannels = 2; break;
        case 0x10B4: case 0x10BC: numberChannels = 3; break;
        case 0x10B5: case 0x10B6: case 0x10B7: case 0x10B8: case 0x10B9: case 0x10C3: numberChannels = 4; break;
        case 0x10BF: case 0x10C0: case 0x10C1: case 0x10C2: numberChannels = 5; break;
    }
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D2: case 0x10D7: case 0x10DA: numberBytesByTypeData = 1; break;
        case 0x10D1: case 0x10D3: case 0x10D4: case 0x10D5: case 0x10D8: case 0x10DB: case 0x10DD: numberBytesByTypeData = 2; break;
        case 0x10D6: case 0x10D9: case 0x10DC: case 0x10DE: case 0x10E0: numberBytesByTypeData = 4; break;
    }
    if (_imageChannelOrder == 0x10B4 && (_imageChannelDataType == 0x10D4 || _imageChannelDataType == 0x10D5)) numberChannels = 1;
    numberBytesPerPixel = numberChannels * numberBytesByTypeData;
    jfieldID imageWidth = env->GetFieldID(ImageDescriptor, "imageWidth", "I");
    jfieldID imageHeight = env->GetFieldID(ImageDescriptor, "imageHeight", "I");
    jfieldID imageDepth = env->GetFieldID(ImageDescriptor, "imageDepth", "I");
    jint _imageWidth = env->GetIntField(_imageDescriptor, imageWidth);
    jint _imageHeight = env->GetIntField(_imageDescriptor, imageHeight);
    jint _imageDepth = env->GetIntField(_imageDescriptor, imageDepth);
    switch(_imageType) {
        case 0x10F1: offsetCopyByImageType = _imageWidth * _imageHeight * numberBytesPerPixel; break;
        case 0x10F2: offsetCopyByImageType = _imageWidth * _imageHeight * _imageDepth * numberBytesPerPixel; break;
        case 0x10F3: offsetCopyByImageType = _imageWidth * _imageHeight * _numberImages * numberBytesPerPixel; break;
        case 0x10F4: case 0x10F6: offsetCopyByImageType = _imageWidth * numberBytesPerPixel; break;
        case 0x10F5: offsetCopyByImageType = _imageWidth * _numberImages * numberBytesPerPixel; break;
    }
    size_t __origion[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    void **Result = GetEnqueueCopyImageToBuffer(_currentCommandQueue, _currentImage, _currentBuffer, __origion, __region,
                                                offsetCopyByImageType);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_copyBufferToImage(JNIEnv *env, jobject image, jobject commandQueue, jobject buffer,
                                              jintArray origin, jintArray region) {
    if (commandQueue == NULL || buffer == NULL || origin == NULL || region == NULL) {
        char *message = (char*)malloc(sizeof(char) * 177);
        strcpy(message, "You cannot copy the contents of the buffer to the Image object, because the CommandQueue object and/or the ");
        strcat(message, "buffer and/or the origin array and/or the region array are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentImage == -1 || _currentCommandQueue == -1 || _currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 210);
        strcpy(message, "You cannot copy the contents of the buffer to the Image object, because the Image object you are using to ");
        strcat(message, "copy the buffer to the Image object is invalid, and/or CommandQueue object and/or the buffer are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    if (sizeOrigin != 3 || sizeRegion != 3) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot copy the contents of the buffer to the Image object because the length of the origin and region ");
        strcat(message, "arrays is not 3");
        showMessageError(env, message);
        return NULL;
    }
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    if (_origin[0] < 0 || _origin[1] < 0 || _origin[2] < 0) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot copy the contents of the buffer to the Image object because the data in the origin array cannot ");
        strcat(message, "be less than 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_region[0] <= 0 || _region[1] <= 0 || _region[2] <= 0) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "You cannot copy the contents of the buffer to the Image object because the data in the region array cannot ");
        strcat(message, "be less than or equal to 0");
        showMessageError(env, message);
        return NULL;
    }
    jclass ImageFormat = env->FindClass("com/draico/asvappra/opencl/image/ImageFormat");
    jclass ImageDescriptor = env->FindClass("com/draico/asvappra/opencl/image/ImageDescriptor");
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jfieldID imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jfieldID imageWidth = env->GetFieldID(ImageDescriptor, "imageWidth", "I");
    jfieldID imageHeight = env->GetFieldID(ImageDescriptor, "imageHeight", "I");
    jfieldID imageDepth = env->GetFieldID(ImageDescriptor, "imageDepth", "I");
    jfieldID numberImages = env->GetFieldID(ImageDescriptor, "numberImages", "I");
    jint _imageChannelOrder = env->GetIntField(_imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(_imageFormat, imageChannelDataType);
    jint _imageType = env->GetIntField(_imageDescriptor, imageType);
    jint _imageWidth = env->GetIntField(_imageDescriptor, imageWidth);
    jint _imageHeight = env->GetIntField(_imageDescriptor, imageHeight);
    jint _imageDepth = env->GetIntField(_imageDescriptor, imageDepth);
    jint _numberImages = env->GetIntField(_imageDescriptor, numberImages);
    if (_imageType == 0x10F1) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 232);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because position 2 of the original array ");
            strcat(message, "must be set to 0 for the type of image you set when you created the ImageDescriptor object which is ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 230);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because position 2 of the region array ");
            strcat(message, "must be set to 1 for the type of image you set when you created the ImageDescriptor object which is ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 || _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 438);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because positions 1 and 2 of the origin ");
            strcat(message, "array are not set to 0 (the original array is used as offset for x, y and z) since you used the image ");
            strcat(message, "type ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor. TYPE_IMAGE1D_BUFFER when creating the ");
            strcat(message, "ImageDescriptor object that you used to create the Image object, make sure that positions 1 and 2 of ");
            strcat(message, "the origin array have the correct value");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 || _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 454);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because positions 1 and 2 of the region ");
            strcat(message, "array are not set to 1 (the original array is used as dimensions for width, height and depth) since you ");
            strcat(message, "used the image type ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1D_BUFFER when creating ");
            strcat(message, "the ImageDescriptor object that you used to create the Image object, make sure that positions 1 and 2 ");
            strcat(message, "of the region array have the correct value");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 275);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because position 2 of the origin array is ");
            strcat(message, "not set to 0, since you used the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY when you created the ");
            strcat(message, "ImageDescriptor object that you used when you created the Image object");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 275);
            strcpy(message, "You cannot copy the contents of the buffer to the Image object because position 2 of the region array is ");
            strcat(message, "not set to 1, since you used the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY when you created the ");
            strcat(message, "ImageDescriptor object that you used when you created the Image object");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint numberChannels;
    jint numberBytesByTypeData;
    jint numberBytesPerPixel;
    size_t offsetCopyByImageType;
    switch(_imageChannelOrder) {
        case 0x10B0: case 0x10B1: case 0x10BA: case 0x10BE: numberChannels = 1; break;
        case 0x10B2: case 0x10B3: case 0x10BB: case 0x10BD: numberChannels = 2; break;
        case 0x10B4: case 0x10BC: numberChannels = 3; break;
        case 0x10B5: case 0x10B6: case 0x10B7: case 0x10B8: case 0x10B9: case 0x10C3: numberChannels = 4; break;
        case 0x10BF: case 0x10C0: case 0x10C1: case 0x10C2: numberChannels = 5; break;
    }
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D2: case 0x10D7: case 0x10DA: numberBytesByTypeData = 1; break;
        case 0x10D1: case 0x10D3: case 0x10D4: case 0x10D5: case 0x10D8: case 0x10DB: case 0x10DD: numberBytesByTypeData = 2; break;
        case 0x10D6: case 0x10D9: case 0x10DC: case 0x10DE: case 0x10E0: numberBytesByTypeData = 4; break;
    }
    if (_imageChannelOrder == 0x10B4 && (_imageChannelDataType == 0x10D4 || _imageChannelDataType == 0x10D5)) numberChannels = 1;
    numberBytesPerPixel = numberChannels * numberBytesByTypeData;
    switch(_imageType) {
        case 0x10F1: offsetCopyByImageType = _imageWidth * _imageHeight * numberBytesPerPixel; break;
        case 0x10F2: offsetCopyByImageType = _imageWidth * _imageHeight * _imageDepth * numberBytesPerPixel; break;
        case 0x10F3: offsetCopyByImageType = _imageWidth * _imageHeight * _numberImages * numberBytesPerPixel; break;
        case 0x10F4: case 0x10F6: offsetCopyByImageType = _imageWidth * numberBytesPerPixel; break;
        case 0x10F5: offsetCopyByImageType = _imageWidth * _numberImages * numberBytesPerPixel; break;
    }
    size_t __origin[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    void **Result = GetEnqueueCopyBufferToImage(_currentCommandQueue, _currentImage, _currentBuffer, __origin, __region,
                                                offsetCopyByImageType);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_mapImage(JNIEnv *env, jobject image, jobject commandQueue, jintArray origin, jintArray region,
                                    jintArray numberBytesPerRow, jintArray numberBytesPerLayer, jboolean isBlockingMap, jint flagMap) {
    if (commandQueue == NULL || origin == NULL || region == NULL || numberBytesPerRow == NULL || numberBytesPerLayer == NULL) {
        char *message = (char*)malloc(sizeof(char) * 199);
        strcpy(message, "You cannot map the Image object because the CommandQueue object and/or the origin array and/or the region ");
        strcat(message, "array and/or the numberBytesPerRow array and/or the numberBytesPerLayer array are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentImage == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot map the Image object because the Image object or the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _flagMap = flagMap;
    jint countFlags = 0;
    if ((_flagMap & (1 << 0)) == 1 << 0) { _flagMap -= 1 << 0; countFlags++; }
    if ((_flagMap & (1 << 1)) == 1 << 1) { _flagMap -= 1 << 1; countFlags++; }
    if ((_flagMap & (1 << 2)) == 1 << 2) { _flagMap -= 1 << 2; countFlags++; }
    if (_flagMap != 0 || countFlags > 1) {
        char *message = (char*)malloc(sizeof(char) * 280);
        strcpy(message, "You cannot map the Image object because you have entered a data not allowed in the flagMap variable or ");
        strcat(message, "used more than 1 value for the flag, you can only choose one of the following values to map the Image ");
        strcat(message, "object:\nImage.MAP_READ\nImage.MAP_WRITE\nImage.MAP_WRITE_INVALIDATE_REGION");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeOrigin = env->GetArrayLength(origin);
    jsize sizeRegion = env->GetArrayLength(region);
    jsize sizeNumberBytesPerRow = env->GetArrayLength(numberBytesPerRow);
    jsize sizeNumberBytesPerLayer = env->GetArrayLength(numberBytesPerLayer);
    if (sizeOrigin != 3 || sizeRegion != 3 || sizeNumberBytesPerRow == 0 || sizeNumberBytesPerLayer == 0) {
        char *message = (char*)malloc(sizeof(char) * 365);
        strcpy(message, "You cannot map the Image object because the origin and region arrays must have 3 integers, while the ");
        strcat(message, "numberBytesPerRow and numberBytesPerLayer arrays must have at least 1 integer data, to determine the ");
        strcat(message, "number of bytes per row and for the entire layer, depending on the type of image that you have set in ");
        strcat(message, "the ImageDescriptor object will be the size of these 2 arrays");
        showMessageError(env, message);
        return NULL;
    }
    jint *_origin = env->GetIntArrayElements(origin, NULL);
    jint *_region = env->GetIntArrayElements(region, NULL);
    jint *_numberBytesPerRow = env->GetIntArrayElements(numberBytesPerRow, NULL);
    jint *_numberBytesPerLayer = env->GetIntArrayElements(numberBytesPerLayer, NULL);
    if (_origin[0] < 0 || _origin[1] < 0 || _origin[2] < 0) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot map the Image object because the values of the origin array are less than 0");
        showMessageError(env, message);
        return NULL;
    }
    if (_region[0] <= 0 || _region[1] <= 0 || _region[2] <= 0) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "You cannot map the Image object because the values of the region array are less or equal than 0");
        showMessageError(env, message);
        return NULL;
    }
    for (jint position = 0; position < sizeNumberBytesPerRow; position++) {
        if (_numberBytesPerRow[position] <= 0) {
            char *message = (char*)malloc(sizeof(char) * 124);
            strcpy(message, "You cannot map the Image object because at least one of the values in the numberBytesPerRow array is less ");
            strcat(message, "than or equal to 0");
            showMessageError(env, message);
            return NULL;
        }
    }
    for (jint position = 0; position < sizeNumberBytesPerLayer; position++) {
        if (_numberBytesPerLayer[position] <= 0) {
            char *message = (char*)malloc(sizeof(char) * 126);
            strcpy(message, "You cannot map the Image object because at least one of the values in the numberBytesPerLayer array is ");
            strcat(message, "less than or equal to 0");
            showMessageError(env, message);
            return NULL;
        }
    }
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageFormat = env->GetObjectClass(_imageFormat);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jfieldID imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jint _imageChannelOrder = env->GetIntField(_imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(_imageFormat, imageChannelDataType);
    jint _imageType = env->GetIntField(_imageDescriptor, imageType);
    if (_imageType == 0x10F1) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 214);
            strcpy(message, "You cannot map the Image object because the values that you provided in the origin array for the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D are incorrect, since position 2 of the original array must always be set to 0");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 214);
            strcpy(message, "You cannot map the Image object because the values that you provided in the region array for the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D are incorrect, since position 2 of the original array must always be set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F4 || _imageType == 0x10F6) {
        if (_origin[1] != 0 || _origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 272);
            strcpy(message, "You cannot map the Image object because the data you provided in positions 1 and 2 of the origin array ");
            strcat(message, "is incorrect, for the image type ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1D_BUFFER, ");
            strcat(message, "since positions 1 and 2 of the origin array must always be set to 0");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[1] != 1 || _region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 272);
            strcpy(message, "You cannot map the Image object because the data you provided in positions 1 and 2 of the region array ");
            strcat(message, "is incorrect, for the image type ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1D_BUFFER, ");
            strcat(message, "since positions 1 and 2 of the region array must always be set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (_imageType == 0x10F5) {
        if (_origin[2] != 0) {
            char *message = (char*)malloc(sizeof(char) * 217);
            strcpy(message, "You cannot map the Image object because the data in position 2 of the origin array you provided is ");
            strcat(message, "incorrect for the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY position 2 of the origin array must ");
            strcat(message, "always be set to 0");
            showMessageError(env, message);
            return NULL;
        }
        if (_region[2] != 1) {
            char *message = (char*)malloc(sizeof(char) * 217);
            strcpy(message, "You cannot map the Image object because the data in position 2 of the region array you provided is ");
            strcat(message, "incorrect for the image type ImageDescriptor.TYPE_IMAGE1D_ARRAY position 2 of the region array must ");
            strcat(message, "always be set to 1");
            showMessageError(env, message);
            return NULL;
        }
    }
    jfieldID imageWidth = env->GetFieldID(ImageDescriptor, "imageWidth", "I");
    jfieldID imageHeight = env->GetFieldID(ImageDescriptor, "imageHeight", "I");
    jfieldID imageDepth = env->GetFieldID(ImageDescriptor, "imageDepth", "I");
    jfieldID numberImages = env->GetFieldID(ImageDescriptor, "numberImages", "I");
    jint _imageWidth = env->GetIntField(_imageDescriptor, imageWidth);
    jint _imageHeight = env->GetIntField(_imageDescriptor, imageHeight);
    jint _imageDepth = env->GetIntField(_imageDescriptor, imageDepth);
    jint _numberImages = env->GetIntField(_imageDescriptor, numberImages);
    jint numberChannels;
    jint numberBytesByTypeData;
    jint numberBytesPerPixel;
    jsize totalBytesPerLayer;
    jsize totalBytesPerRow;
    switch(_imageChannelOrder) {
        case 0x10B0: case 0x10B1: case 0x10BA: case 0x10BE: numberChannels = 1; break;
        case 0x10B2: case 0x10B3: case 0x10BB: case 0x10BD: numberChannels = 2; break;
        case 0x10B4: case 0x10BC: numberChannels = 3; break;
        case 0x10B5: case 0x10B6: case 0x10B7: case 0x10B8: case 0x10B9: case 0x10C3: numberChannels = 4; break;
        case 0x10BF: case 0x10C0: case 0x10C1: case 0x10C2: numberChannels = 5; break;
    }
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D2: case 0x10D7: case 0x10DA: numberBytesByTypeData = 1; break;
        case 0x10D1: case 0x10D3: case 0x10D4: case 0x10D5: case 0x10D8: case 0x10DB: case 0x10DD: numberBytesByTypeData = 2; break;
        case 0x10D6: case 0x10D9: case 0x10DC: case 0x10DE: case 0x10E0: numberBytesByTypeData = 4; break;
    }
    if (_imageChannelOrder == 0x10B4 && (_imageChannelDataType == 0x10D4 || _imageChannelDataType == 0x10D5)) numberChannels = 1;
    numberBytesPerPixel = numberChannels * numberBytesByTypeData;
    switch(_imageType) {
        case 0x10F1: totalBytesPerLayer = _imageWidth * _imageHeight * numberBytesPerPixel; break;
        case 0x10F2: totalBytesPerLayer = _imageWidth * _imageHeight * _imageDepth * numberBytesPerPixel; break;
        case 0x10F3: totalBytesPerLayer = _imageWidth * _imageHeight * _numberImages * numberBytesPerPixel; break;
        case 0x10F4: case 0x10F6: totalBytesPerLayer = _imageWidth * numberBytesPerPixel; break;
        case 0x10F5: totalBytesPerLayer = _imageWidth * _numberImages * numberBytesPerPixel; break;
    }
    totalBytesPerRow = numberBytesPerPixel * _imageWidth;
    for (jint position = 0; position < sizeNumberBytesPerRow; position++) {
        if (_numberBytesPerRow[position] != totalBytesPerRow) {
            char *message = (char*)malloc(sizeof(char) * 337);
            strcpy(message, "You cannot map the Image object because the values that you provided in the numberBytesPerRow array ");
            strcat(message, "are incorrect, since they do not correspond to the number of bytes in the number of pixels of the ");
            strcat(message, "image width, with respect to the format you have set in the object ImageFormat and ImageDescriptor ");
            strcat(message, "that you used to create the Image object");
            showMessageError(env, message);
            return NULL;
        }
    }
    for (jint position = 0; position < sizeNumberBytesPerLayer; position++) {
        if (_numberBytesPerLayer[position] != totalBytesPerLayer) {
            char *message = (char*)malloc(sizeof(char) * 345);
            strcpy(message, "You cannot map the Image object because the values you provided in the numberBytesPerLayer array are ");
            strcat(message, "incorrect, since they do not correspond to the number of bytes in the number of pixels of the entire ");
            strcat(message, "image per layer, with respect to the format you have set in the ImageFormat and ImageDescriptor object ");
            strcat(message, "that you used to create the Image object");
            showMessageError(env, message);
            return NULL;
        }
    }
    size_t __origin[] = { (size_t)_origin[0], (size_t)_origin[1], (size_t)_origin[2] };
    size_t __region[] = { (size_t)_region[0], (size_t)_region[1], (size_t)_region[2] };
    size_t __numberBytesPerRow[sizeNumberBytesPerRow];
    size_t __numberBytesPerLayer[sizeNumberBytesPerLayer];
    for (jint position = 0; position < sizeNumberBytesPerRow; position++) {
        __numberBytesPerRow[position] = _numberBytesPerRow[position];
    }
    for (jint position = 0; position < sizeNumberBytesPerLayer; position++) {
        __numberBytesPerLayer[position] = _numberBytesPerLayer[position];
    }
    void **Result = GetEnqueueMapImage(_currentCommandQueue, _currentImage, __origin, __region, __numberBytesPerRow, __numberBytesPerLayer,
                                       isBlockingMap, flagMap);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID flag_Map = env->GetFieldID(Image, "flagMap", "I");
        env->SetIntField(image, flag_Map, flagMap);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_unmapImage(JNIEnv *env, jobject image, jobject commandQueue) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot use the unmapImage method because the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Image = env->GetObjectClass(image);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentImage == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 99);
        strcpy(message, "You cannot use the unmapImage method because the Image object or the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID flagMap = env->GetFieldID(Image, "flagMap", "I");
    jint _flagMap = env->GetIntField(image, flagMap);
    if ((_flagMap & (1 << 0)) != 1 << 0 && (_flagMap & (1 << 1)) != 1 << 1 && (_flagMap & (1 << 2)) != 1 << 2) {
        char *message = (char*)malloc(sizeof(char) * 85);
        strcpy(message, "You cannot use the unmapImage method because the Image object has not yet been mapped");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID buffer = env->GetFieldID(Image, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
    jobject _buffer = env->GetObjectField(image, buffer);
    jclass Buffer = env->GetObjectClass(_buffer);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentBuffer = env->GetIntField(_buffer, currentBuffer);
    void **Result = GetEnqueueUnmapImage(_currentCommandQueue, _currentImage, _currentBuffer);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        env->SetIntField(image, flagMap, 0);
        return newEvent(env, NULL, commandQueue);
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_migrateImage(JNIEnv *env, jobject image, jobject commandQueue, jobjectArray images,
                                         jint flagMigrate) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 87);
        strcpy(message, "You cannot perform migrate Image objects because the CommandQueue object is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Image = env->GetObjectClass(image);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 146);
        strcpy(message, "You cannot perform migrate the Image objects, because the Image object that you use to perform the migration ");
        strcat(message, "or the CommandQueue object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint *listImages;
    jsize sizeList;
    if (images == NULL) {
        listImages = (jint*)malloc(sizeof(jint));
        listImages[0] = _currentImage;
        sizeList = 1;
    } else {
        jsize sizeListImages = env->GetArrayLength(images);
        listImages = (jint*)malloc(sizeof(jint) * (sizeListImages + 1));
        jfieldID contextImage = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
        jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
        jint position = 0;
        for ( ; position < (sizeListImages - 1); position++) {
            jobject img1 = env->GetObjectArrayElement(images, position);
            _currentImage = env->GetIntField(img1, currentImage);
            jobject contextImg1 = env->GetObjectField(img1, contextImage);
            for (jint position1 = position + 1; position < sizeListImages; position++) {
                jobject img2 = env->GetObjectArrayElement(images, position1);
                jint _currentImage2 = env->GetIntField(img2, currentImage);
                jobject contextImg2 = env->GetObjectField(img2, contextImage);
                if (_currentImage == -1 || _currentImage2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 93);
                    strcpy(message, "You cannot perform migrate the image list, because some of the images in the list are invalid");
                    showMessageError(env, message);
                    return NULL;
                }
                if (env->IsSameObject(img1, img2)) {
                    char *message = (char*)malloc(sizeof(char) * 103);
                    strcpy(message, "You cannot perform migrate the image list because the same object is repeated in the list at least ");
                    strcat(message, "once");
                    showMessageError(env, message);
                    return NULL;
                }
                if (!env->IsSameObject(contextImg1, contextImg2)) {
                char *message = (char*)malloc(sizeof(char) * 107);
                    strcpy(message, "You cannot perform migrate the Image objects because the image objects were not created in the ");
                    strcat(message, "same context");
                    showMessageError(env, message);
                    return NULL;
                }
            }
            if (!env->IsSameObject(contextImg1, _contextCommandQueue)) {
                char *message = (char*)malloc(sizeof(char) * 152);
                strcpy(message, "You cannot perform migrate the Image objects because the image objects were not created in the same ");
                strcat(message, "context in which the CommandQueue object was created");
                showMessageError(env, message);
                return NULL;
            }
        }
        for (position = 0; position < sizeListImages; position++) {
            jobject img = env->GetObjectArrayElement(images, position);
            _currentImage = env->GetIntField(img, currentImage);
            if (_currentImage == -1) {
                char *message = (char*)malloc(sizeof(char) * 93);
                strcpy(message, "You cannot perform migrate the image list, because some of the images in the list are invalid");
                showMessageError(env, message);
                return NULL;
            }
            listImages[position] = _currentImage;
        }
        _currentImage = env->GetIntField(image, currentImage);
        listImages[position] = _currentImage;
        sizeList = sizeListImages + 1;
    }
    jint _flagMigrate = flagMigrate;
    jint countFlag = 0;
    if ((_flagMigrate & (1 << 0)) == 1 << 0) { _flagMigrate -= 1 << 0; countFlag++; }
    if ((_flagMigrate & (1 << 1)) == 1 << 1) { _flagMigrate -= 1 << 0; countFlag++; }
    if (_flagMigrate != 0 || countFlag > 1) {
        char *message = (char*)malloc(sizeof(char) * 245);
        strcpy(message, "You cannot perform migrate the image list because the flag you used for the migration is incorrect or used more ");
        strcat(message, "than 1 data for the flag, you can only use one of the following flags:\nImage.MIGRATE_IMAGE_HOST\n");
        strcat(message, "Image.MIGRATE_IMAGE_CONTENT_UNDEFINED");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetEnqueueMigrateImage(_currentCommandQueue, sizeList, listImages, flagMigrate);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_image_Image_release(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 65);
        strcpy(message, "You cannot release the current Image object because it is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageFormat = env->GetObjectClass(_imageFormat);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jint _currentImageFormat = env->GetIntField(_imageFormat, currentImageFormat);
    jint _currentImageDescriptor = env->GetIntField(_imageDescriptor, currentImageDescriptor);
    void **Result = GetReleaseImage(_currentImage, _currentImageFormat, _currentImageDescriptor);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        env->SetIntField(image, currentImage, -1);
        env->SetIntField(_imageFormat, currentImageFormat, -1);
        env->SetIntField(_imageDescriptor, currentImageDescriptor, -1);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_Image_getImageFormat(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 87);
        strcpy(message, "You cannot get the ImageFormat object because the Image object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    return env->GetObjectField(image, imageFormat);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getSizePixel(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "You cannot get the size in bytes of each pixel of the Image object because the Image object is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jobject _imageFormat = env->GetObjectField(image, imageFormat);
    jclass ImageFormat = env->GetObjectClass(_imageFormat);
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jint _imageChannelOrder = env->GetIntField(_imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(_imageFormat, imageChannelDataType);
    jint numberChannels;
    jint numberBytesByTypeData;
    switch(_imageChannelOrder) {
        case 0x10B0: case 0x10B1: case 0x10BA: case 0x10BE: numberChannels = 1; break;
        case 0x10B2: case 0x10B3: case 0x10BB: case 0x10BD: numberChannels = 2; break;
        case 0x10B4: case 0x10BC: numberChannels = 3; break;
        case 0x10B5: case 0x10B6: case 0x10B7: case 0x10B8: case 0x10B9: case 0x10C3: numberChannels = 4; break;
        case 0x10BF: case 0x10C0: case 0x10C1: case 0x10C2: numberChannels = 5; break;
    }
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D2: case 0x10D7: case 0x10DA: numberBytesByTypeData = 1; break;
        case 0x10D1: case 0x10D3: case 0x10D4: case 0x10D5: case 0x10D8: case 0x10DB: case 0x10DD: numberBytesByTypeData = 2; break;
        case 0x10D6: case 0x10D9: case 0x10DC: case 0x10DE: case 0x10E0: numberBytesByTypeData = 4; break;
    }
    if (_imageChannelOrder == 0x10B4 && (_imageChannelDataType == 0x10D4 || _imageChannelDataType == 0x10D5)) numberChannels = 1;
    return numberChannels * numberBytesByTypeData;
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getNumberBytesPerRow(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "You cannot get the number of bytes per row because the Image object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID numberBytesPerRow = env->GetFieldID(ImageDescriptor, "numberBytesPerRow", "I");
    return env->GetIntField(_imageDescriptor, numberBytesPerRow);
}
JNICALL jint Java_com_draico_opencl_image_Image_getNumberBytesPerLayer(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot get the number of bytes per layer because the Image object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID numberBytesPerLayer = env->GetFieldID(ImageDescriptor, "numberBytesPerLayer", "I");
    return env->GetIntField(_imageDescriptor, numberBytesPerLayer);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getWidth(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "No puede obtener el ancho del objeto Imagen porque el objeto imagen que esta usando es invalido");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID imageWidth = env->GetFieldID(ImageDescriptor, "imageWidth", "I");
    return env->GetIntField(_imageDescriptor, imageWidth);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getHeight(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "You cannot get the height of the Image object because the image object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID imageHeight = env->GetFieldID(ImageDescriptor, "imageHeight", "I");
    return env->GetIntField(_imageDescriptor, imageHeight);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getDepth(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot get the depth of the Image object because the image object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID imageDepth = env->GetFieldID(ImageDescriptor, "imageDepth", "I");
    return env->GetIntField(_imageDescriptor, imageDepth);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_Image_getNumberImages(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "You cannot get the number of images of the Image object because the Image object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
    jclass ImageDescriptor = env->GetObjectClass(_imageDescriptor);
    jfieldID numberImages = env->GetFieldID(ImageDescriptor, "numberImages", "I");
    return env->GetIntField(_imageDescriptor, numberImages);
}
JNICALL jstring Java_com_draico_asvappra_opencl_image_Image_toString(JNIEnv *env, jobject image) {
    jclass Image = env->GetObjectClass(image);
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jint _currentImage = env->GetIntField(image, currentImage);
    if (_currentImage == -1) {
        char *message = (char*)malloc(sizeof(char) * 84);
        strcpy(message, "You cannot use the toString method because the Image object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return imageToString(env, image);
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_ImageFormat_createImageFormat(JNIEnv *env, jclass ImageFormat, jobject context,
                                                         jint imageChannelOrder, jint imageChannelDataType) {
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot create an ImageFormat because the context you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 76);
        strcpy(message, "You cannot create an ImageFormat because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (imageChannelDataType == 0x10E0 && VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 288);
        strcpy(message, "You cannot create an ImageFormat because the data you provided for the imageChannelDataType variable is ");
        strcat(message, "ImageFormat.UNORM_INT_101010_2 is only available for OpenCL versions greater than or equal to 2.1 and the ");
        strcat(message, "OpenCL version that your android device has installed is less than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    if (imageChannelOrder == 0x10BF || imageChannelOrder == 0x10C0 || imageChannelOrder == 0x10C1 || imageChannelOrder == 0x10C2 ||
        imageChannelOrder == 0x10C3) {
        if (VersionOpenCL < 2.0) {
            char *message = (char*)malloc(sizeof(char) * 393);
            strcpy(message, "You cannot create an ImageFormat because the data you provided for the imageChannelOrder variable is one ");
            strcat(message, "of the following types:\nImageFormat.sRGB\nImageFormat.sRGBx\nImageFormat.sRGBA\nImageFormat.sBGRA\n");
            strcat(message, "Since any of these previous values are only available for versions OpenCL greater than or equal to 2.0 ");
            strcat(message, "and the version of OpenCL that your android device has installed is lower than version 2.0");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint _imageChannelOrder = imageChannelOrder;
    jint _imageChannelDataType = imageChannelDataType;
    jint data = 0x10B0;
    jint dataType = 0x10D0;
    for (jint count = 0, countData = 0; count < 20; count++, countData++, data++) {
        if (_imageChannelOrder == data) _imageChannelOrder -= data;
        if (countData < 17) {
            if (dataType == 0x10DF) { dataType++; countData--; continue; }
            if (_imageChannelDataType == dataType) _imageChannelDataType -= dataType;
            dataType++;
        }
    }
    if (_imageChannelOrder != 0 || _imageChannelDataType != 0) {
        char *message = (char*)malloc(sizeof(char) * 1075);
        strcpy(message, "You cannot create an ImageFormat object because the values you are using in the imageChannelOrder and ");
        strcat(message, "imageChannelDataType variables are incorrect or at least one of the two variables, for the imageChannelOrder ");
        strcat(message, "variable you can only use one of the following values:\nImageFormat.R\nImageFormat.A\nImageFormat.RG\n");
        strcat(message, "ImageFormat.RA\nImageFormat.RGB\nImageFormat.RGBA\nImageFormat.BGRA\nImageFormat.ARGB\nImageFormat.INTENSITY\n");
        strcat(message, "ImageFormat.LUMINANCE\nImageFormat.Rx\nImageFormat.RGx\nImageFormat.RGBx\nImageFormat.DEPTH\n");
        strcat(message, "Image.DEPTH_STENCIL\nImageFormat.sRGB\nImageFormat.sRGBx\nImageFormat.sRGBA\nImageFormat.sBGRA\n");
        strcat(message, "ImageFormat.ABGR\nThe values you can use for imageChannelDataType are as follows:\n");
        strcat(message, "ImageFormat.SNORM_INT8\nImageFormat.SNORM_INT16\nImageFormat.UNORM_INT8\nImageFormat.UNORM_INT16\n");
        strcat(message, "ImageFormat.UNORM_SHORT565\nImageFormat.UNORM_SHORT555\nImageFormat.UNORM_INT_101010\nImageFormat.SIGNED_INT8\n");
        strcat(message, "ImageFormat.SIGNED_INT16\nImageFormat.SIGNED_INT32\nImageFormat.UNSIGNED_INT8\nImageF ormat.UNSIGNED_INT16\n");
        strcat(message, "ImageFormat.UNSIGNED_INT32\nImageFormat.HALF_FLOAT\nImageFormat.FLOAT\nImageFormat.UNORM_INT_101010_2");
        showMessageError(env, message);
        return NULL;
    }
    if ((imageChannelOrder == 0x10B8 || imageChannelOrder == 0x10B9) && (imageChannelDataType != 0x10D0 && imageChannelDataType != 0x10D1 &&
        imageChannelDataType != 0x10D2 && imageChannelDataType != 0x10D3)) {
        char *message = (char*)malloc(sizeof(char) * 376);
        strcpy(message, "You cannot create an ImageFormat object because you are using the ImageFormat.INTENSITY or ImageFormat.LUMINANCE ");
        strcat(message, "value for the imageChannelOrder variable and either of the two previous values requires you to use any of the ");
        strcat(message, "following values:\nImageFormat.SNORM_INT8\nImageFormat.SNORM_Int16\nImageFormat. UNORM_INT8\n");
        strcat(message, "ImageFormat.UNORM_INT16\nImageFormat.HALF_FLOAT\nImageFormat.FLOAT");
        showMessageError(env, message);
        return NULL;
    }
    if ((imageChannelOrder == 0x10B6 || imageChannelOrder == 0x10B7) && (imageChannelDataType != 0x10D0 && imageChannelDataType != 0x10D2 &&
        imageChannelDataType != 0x10D7 && imageChannelDataType != 0x10DA)) {
        char *message = (char*)malloc(sizeof(char) * 343);
        strcpy(message, "You cannot create an ImageFormat object because the value you set for the imageChannelOrder variable is ");
        strcat(message, "ImageFormat.ARGB or ImageFormat.BGRA and these values can only be used with one of the following values for ");
        strcat(message, "the imageChannelDataType variable:\nImageFormat.UNORM_INT8\nImageFormat.SNORM_INT8\nImageFormat .SIGNED_INT8\n");
        strcat(message, "ImageFormat.UNSIGNED_INT8");
        showMessageError(env, message);
        return NULL;
    }
    if ((imageChannelOrder == 0x10B0 || imageChannelOrder == 0x10B2 || imageChannelOrder == 0x10B5) && (imageChannelDataType != 0x10D0 &&
        imageChannelDataType != 0x10D1 && imageChannelDataType != 0x10D2 && imageChannelDataType != 0x10D3 && imageChannelDataType != 0x10D7 &&
        imageChannelDataType != 0x10D8 && imageChannelDataType != 0x10D9 && imageChannelDataType != 0x10DA && imageChannelDataType != 0x10DB &&
        imageChannelDataType != 0x10DC && imageChannelDataType != 0x10DD && imageChannelDataType != 0x10DE)) {
        char *message = (char*)malloc(sizeof(char) * 566);
        strcpy(message, "You cannot create an ImageFormat because I set any of the following values as the value for the imageChannelOrder ");
        strcat(message, "variable:\nImageFormat.R\nImageFormat.RG\nImageFormat.RGBA\nAny of the above values requires that in the ");
        strcat(message, "imageChannelDataType variable set any of the following values:\nImageFormat.UNORM_INT8\nImageFormat.UNORM_INT16\n");
        strcat(message, "ImageFormat.SNORM_INT8\nImageFormat.SNORM_INT16\nImageFormat.SIGNED_INT8\nImageFormat.SIGNED_INT16\n");
        strcat(message, "ImageFormat.SIGNED_INT32\nImageFormat.UNSIGNED_INT8\nImageFormat.UNSIGNED_INT16\nImageFormat.UNSIGNED_INT32\n");
        strcat(message, "ImageFormat.HALF_FLOAT\nImageFormat.FLOAT");
        showMessageError(env, message);
        return NULL;
    }
    if ((imageChannelOrder == 0x10BD && (imageChannelDataType != 0x10D3 && imageChannelDataType != 0x10DE))) {
        char *message = (char*)malloc(sizeof(char) * 263);
        strcpy(message, "You cannot create an ImageFormat object because you set the value for the imageChannelOrder ImageFormat.DEPTH ");
        strcat(message, "variable and for this value you can only use one of the following values for the imageChannelDataType variable:\n");
        strcat(message, "ImageFormat.UNORM_INT16\nImageFormat.FLOAT");
        showMessageError(env, message);
        return NULL;
    }
    if ((imageChannelOrder == 0x10BE) && (imageChannelDataType != 0x10DE)) {
        char *message = (char*)malloc(sizeof(char) * 254);
        strcpy(message, "You cannot create the ImageFormat object because the value you set for the imageChannelOrder variable is ");
        strcat(message, "ImageFormat.DEPTH_STENCIL and this value only works if you adjust one of the following values to the ");
        strcat(message, "imageChannelDataType variable:\nImageFormat.FLOAT");
        showMessageError(env, message);
        return NULL;
    }
    addImageFormatToListImageFormat(imageChannelOrder, imageChannelDataType);
    jfieldID _context = env->GetFieldID(ImageFormat, "context", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jfieldID __imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID __imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jobject imageFormat = env->AllocObject(ImageFormat);
    env->SetObjectField(imageFormat, _context, context);
    env->SetIntField(imageFormat, currentImageFormat, positionCurrentImageFormat);
    env->SetIntField(imageFormat, __imageChannelOrder, imageChannelOrder);
    env->SetIntField(imageFormat, __imageChannelDataType, imageChannelDataType);
    positionCurrentImageFormat++;
    return imageFormat;
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_image_ImageFormat_getSupportedImageFormats(JNIEnv *env, jclass ImageFormat, jobject context,
                                                                      jint typeAccessImage, jint imageType) {
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot get the list of image formats supported by opencl on this device, because the context you provided ");
        strcat(message, "is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot get the list of image formats supported by opencl on this device, because the context you are ");
        strcat(message, "using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _typeAccessImage = typeAccessImage;
    jint _imageType = imageType;
    jint counterTypeAccessImage = 0;
    if (_typeAccessImage == 1 << 0) { _typeAccessImage -= 1 << 0; counterTypeAccessImage++; }
    if (_typeAccessImage == 1 << 1) { _typeAccessImage -= 1 << 1; counterTypeAccessImage++; }
    if (_typeAccessImage == 1 << 2) { _typeAccessImage -= 1 << 2; counterTypeAccessImage++; }
    if (_typeAccessImage != 0) {
        char *message = (char*)malloc(sizeof(char) * 272);
        strcpy(message, "You cannot get the list of available image formats that opencl supports on this device, because the type of ");
        strcat(message, "access to the image you provided is invalid, you can only use one of the following access types:\n");
        strcat(message, "Image.IMAGE_READ_WRITE\nImage.IMAGE_WRITE_ONLY\nImage.IMAGE_READ_ONLY");
        showMessageError(env, message);
        return NULL;
    }
    if (counterTypeAccessImage > 1) {
        char *message = (char*)malloc(sizeof(char) * 144);
        strcpy(message, "You cannot get the list of available image formats that opencl supports on this device, because you are using ");
        strcat(message, "more than one type of image access");
        showMessageError(env, message);
        return NULL;
    }
    jint data = 0x10F1;
    for (jint counter = 0; counter < 6; counter++, data++) {
    if (_imageType == data) _imageType -= data;
    }
    if (_imageType != 0) {
        char *message = (char*)malloc(sizeof(char) * 376);
        strcpy(message, "You cannot get the list of available image formats that opencl supports on this device, because the type of ");
        strcat(message, "image you used is incorrect, you can only use one of the following image types:\nImageDescriptor.TYPE_IMAGE1D\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE1D_ARRAY\nImageDescriptor. TYPE_IMAGE1D_BUFFER\nImageDescriptor.TYPE_IMAGE2D\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE2D_ARRAY\nImageDescriptor.IMAGE3D");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetSupportedImageFormats(_currentContext, typeAccessImage, imageType);
    if (*(jint*)Result[1]) {
        void **data = getListImageFormatSupportByTypImage();
        cl_image_format *listFormatsImage = (cl_image_format*)data[0];
        jsize sizeList = *(jint*)data[1];
        jobjectArray _listFormatImage = env->NewObjectArray(sizeList, ImageFormat, NULL);
        jfieldID _context = env->GetFieldID(ImageFormat, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
        jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
        jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
        for (jint position = 0; position < sizeList; position++) {
            jobject imageFormat = env->AllocObject(ImageFormat);
            jint image_channel_order = listFormatsImage[position].image_channel_order;
            jint image_channel_data_type = listFormatsImage[position].image_channel_data_type;
            env->SetObjectField(imageFormat, _context, context);
            env->SetIntField(imageFormat, currentImageFormat, positionCurrentImageFormat);
            env->SetIntField(imageFormat, imageChannelOrder, image_channel_order);
            env->SetIntField(imageFormat, imageChannelDataType, image_channel_data_type);
            env->SetObjectArrayElement(_listFormatImage, position, imageFormat);
            positionCurrentImageFormat++;
        }
        return _listFormatImage;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_image_ImageFormat_toString(JNIEnv *env, jobject imageFormat) {
    jclass ImageFormat = env->GetObjectClass(imageFormat);
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jint _currentImageFormat = env->GetIntField(imageFormat, currentImageFormat);
    if (_currentImageFormat == -1) {
        char *message = (char*)malloc(sizeof(char) * 90);
        strcpy(message, "You cannot use the toString method because the ImageFormat object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return imageFormatToString(env, imageFormat);
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_ImageDescriptor_createImageDescriptor(JNIEnv *env, jclass ImageDescriptor,
                                                                   jobject imageFormat, jobject buffer, jint imageType,
                                                                   jint width, jint height, jint depth, jint numberImages) {
    if (imageFormat == NULL || buffer == NULL) {
        char *message = (char*)malloc(sizeof(char) * 112);
        strcpy(message, "You cannot create an ImageDescriptor object because the ImageFormat object or the buffer you provided is set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass ImageFormat = env->GetObjectClass(imageFormat);
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jint _currentImageFormat = env->GetIntField(imageFormat, currentImageFormat);
    if (_currentImageFormat == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "You cannot create an ImageDescriptor because the ImageFormat object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Buffer = env->GetObjectClass(buffer);
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
    if (_currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot create an ImageDescriptor object because the buffer you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _imageType = imageType;
    jint counterImageType = 0;
    if ((_imageType & 0x10F1) == 0x10F1) { _imageType -= 0x10F1; counterImageType++; }
    if ((_imageType & 0x10F2) == 0x10F2) { _imageType -= 0x10F2; counterImageType++; }
    if ((_imageType & 0x10F3) == 0x10F3) { _imageType -= 0x10F3; counterImageType++; }
    if ((_imageType & 0x10F4) == 0x10F4) { _imageType -= 0x10F4; counterImageType++; }
    if ((_imageType & 0x10F5) == 0x10F5) { _imageType -= 0x10F5; counterImageType++; }
    if ((_imageType & 0x10F6) == 0X10F6) { _imageType -= 0x10F6; counterImageType++; }
    if (_imageType != 0) {
        char *message = (char*)malloc(sizeof(char) * 346);
        strcpy(message, "You cannot create an ImageDescriptor object because you are using an invalid value for the imageType variable, the ");
        strcat(message, "only values allowed are the following:\nImageDescriptor.TYPE_IMAGE1D\nImageDescriptor.TYPE_IMAGE1D_ARRAY\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER\nImageDescriptor.TYPE_IMAGE2D\nImageDescriptor.TYPE_IMAGE2D_ARRAY\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE3D");
        showMessageError(env, message);
        return NULL;
    }
    if (counterImageType > 1) {
        char *message = (char*)malloc(sizeof(char) * 330);
        strcpy(message, "You cannot create an ImageDescriptor object because you must use only one value for the imageType variable of the ");
        strcat(message, "following values:\nImageDescriptor.TYPE_IMAGE1D\nImageDescriptor.TYPE_IMAGE1D_ARRAY\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE1D_BUFFER\nImageDescriptor.TYPE_IMAGE2D\nImageDescriptor.TYPE_IMAGE2D_ARRAY\n");
        strcat(message, "ImageDescriptor.TYPE_IMAGE3D");
        showMessageError(env, message);
        return NULL;
    }
    if (height <= 0 || width <= 0 || depth <= 0 || numberImages <= 0) {
        char *message = (char*)malloc(sizeof(char) * 166);
        strcpy(message, "You cannot create an ImageDescriptor object because one of the following variables was set with a value equal ");
        strcat(message, "to or less than 0: width, height, depth and numberImages");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID imageChannelOrder = env->GetFieldID(ImageFormat, "imageChannelOrder", "I");
    jfieldID imageChannelDataType = env->GetFieldID(ImageFormat, "imageChannelDataType", "I");
    jfieldID context = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jint _imageChannelOrder = env->GetIntField(imageFormat, imageChannelOrder);
    jint _imageChannelDataType = env->GetIntField(imageFormat, imageChannelDataType);
    jobject _context = env->GetObjectField(buffer, context);
    jclass Context = env->GetObjectClass(_context);
    jfieldID devices = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_context, devices);
    jobject device = env->GetObjectArrayElement(_devices, 0);
    jclass Device = env->GetObjectClass(device);
    jmethodID getImage2DMaxHeight = env->GetMethodID(Device, "getImage2DMaxHeight", "()I");
    jmethodID getImage2DMaxWidth = env->GetMethodID(Device, "getImage2DMaxWidth", "()I");
    jmethodID getImage3DMaxHeight = env->GetMethodID(Device, "getImage3DMaxHeight", "()I");
    jmethodID getImage3DMaxWidth = env->GetMethodID(Device, "getImage3DMaxWidth", "()I");
    jmethodID getImage3DMaxDepth = env->GetMethodID(Device, "getImage3DMaxDepth", "()I");
    jmethodID getImageMaxBufferSize = env->GetMethodID(Device, "getImageMaxBufferSize", "()I");
    jmethodID getImageMaxArraySize = env->GetMethodID(Device, "getImageMaxArraySize", "()I");
    jmethodID getImagePitchAlignment = env->GetMethodID(Device, "getImagePitchAlignment", "()I");
    jint image2DMaxHeight = env->CallIntMethod(device, getImage2DMaxHeight);
    jint image2DMaxWidth = env->CallIntMethod(device, getImage2DMaxWidth);
    jint image3DMaxHeight = env->CallIntMethod(device, getImage3DMaxHeight);
    jint image3DMaxWidth = env->CallIntMethod(device, getImage3DMaxWidth);
    jint image3DMaxDepth = env->CallIntMethod(device, getImage3DMaxDepth);
    jint imageMaxBufferSize = env->CallIntMethod(device, getImageMaxBufferSize);
    jint imageMaxArraySize = env->CallIntMethod(device, getImageMaxArraySize);
    jint imagePitchAlignment = env->CallIntMethod(device, getImagePitchAlignment);
    jint numberChannels = 4;
    jint numberBytesByDataType;
    jint numberBytesPerRow, numberBytesPerLayer;
    switch(_imageChannelOrder) {
        case 0x10B4: case 0x10BC: case 0x10BD: numberChannels = 3; break;
        case 0x10BE: numberChannels = 2; break;
        case 0x10BF: case 0x10C0: case 0x10C1: case 0x10C2: numberChannels++; break;
    }
    switch(_imageChannelDataType) {
        case 0x10D0: case 0x10D2: case 0x10D7: case 0x10DA: numberBytesByDataType = 1; break;
        case 0x10D1: case 0x10D3: case 0x10D4: case 0x10D5: case 0x10D6: case 0x10D8: case 0x10DB: case 0x10DD: case 0x10E0:
            numberBytesByDataType = 2;
            break;
        case 0x10D9: case 0x10DC: case 0x10DE: numberBytesByDataType = 4; break;
    }
    if ((_imageChannelOrder == 0x10B4 || _imageChannelOrder == 0x10BC) && (_imageChannelDataType == 0x10D6 || _imageChannelDataType == 0x10E0))
        numberChannels = 4;
    if (imageType == 0x10F6) {
        if (width > imageMaxBufferSize) {
            char *message = (char*)malloc(sizeof(char) * 453);
            strcpy(message, "You cannot create an ImageDescriptor object because the value of the width variable exceeds the maximum ");
            strcat(message, "value that the image can support with the image type ImageDescriptor.TYPE_IMAGE1D_BUFFER, so that you ");
            strcat(message, "know the maximum value that the device supports with the previous image type, use the getImageMaxBufferSize ");
            strcat(message, "method of the device you used to create the context you used to create the buffer you are using to try to ");
            strcat(message, "create the ImageDescriptor object");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (imageType == 0x10F1 || imageType == 0x10F3 || imageType == 0x10F4 || imageType == 0x10F5) {
        if (width > image2DMaxWidth) {
            char *message = (char*)malloc(sizeof(char) * 610);
            strcpy(message, "You cannot create an ImageDescriptor object because the value of the width variable is greater than that ");
            strcat(message, "allowed by the device for the type of image you specified, if the value used for the image type was ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE1D or ImageDescriptor.TYPE_IMAGE1_ARRAY or ImageDescriptor.TYPE_IMAGE2D or ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE2D_ARRAY, you should know the limit that the device allows with any of the 3 ");
            strcat(message, "types of images above, to do this use the getImage2DMaxWidth method of the device used to create the ");
            strcat(message, "context that you used to create the buffer you are using to try to create an ImageDescriptor object");
            showMessageError(env, message);
            return NULL;
        }
        if (imageType != 0x10F4 && imageType != 0x10F5) {
            if (height > image2DMaxHeight && imageType != 0x10F4 && imageType != 0x10F5) {
                char *message = (char*)malloc(sizeof(char) * 409);
                strcpy(message, "You cannot create an ImageDescriptor object because the value of the height variable for the image type ");
                strcat(message, "ImageDescriptor.TYPE_IMAGE2D and ImageDescriptor.TYPE_IMAGE2D_ARRAY is greater than what the device ");
                strcat(message, "allows, to know the maximum value you must use the getImage2DMaxHeight method of the device used to ");
                strcat(message, "create the context you used to create the buffer you are using to try to create an ImageDescriptor object");
                showMessageError(env, message);
                return NULL;
            }
            if (depth > 1) {
                char *message = (char*)malloc(sizeof(char) * 279);
                strcpy(message, "You cannot create an ImageDescriptor object because the value you set for the depth variable is not ");
                strcat(message, "equal to 1, the value of the depth variable must always be 1 when you are working with those with the ");
                strcat(message, "image type ImageDescriptor.TYPE_IMAGE2D or ImageDescriptor.TYPE_IMAGE2D_ARRAY");
                showMessageError(env, message);
                return NULL;
            }
        }
        if (imageType == 0x10F3 || imageType == 0x10F4) {
            if (numberImages > imageMaxArraySize) {
                char *message = (char *) malloc(sizeof(char) * 438);
                strcpy(message, "You cannot create an ImageDescriptor because the value you set in the numberImages variable is greater ");
                strcat(message, "than what the device allows when you are working with a type of ImageDescriptor.TYPE_IMAGE1D or ");
                strcat(message, "ImageDescriptor.TYPE_IMAGE2D_ARRAY, to know the maximum value you must use the getImageMaxArraySize ");
                strcat(message, "method of the device that used to create the context you used to create the buffer you are using to ");
                strcat(message, "try to create an ImageDescriptor object");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    if (imageType == 0x10F2) {
        if (width > image3DMaxWidth) {
            char *message = (char*)malloc(sizeof(char) * 372);
            strcpy(message, "You cannot create an ImageDescriptor object because the value of the width variable for the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE3D is greater than what the device allows, to know the maximum value you must ");
            strcat(message, "use the getImage3DMaxWidth method of the device you used to create the context you used to create the ");
            strcat(message, "buffer you are using to try to create an ImageDescriptor object");
            showMessageError(env, message);
            return NULL;
        }
        if (height > image3DMaxHeight) {
            char *message = (char*)malloc(sizeof(char) * 374);
            strcpy(message, "You cannot create an ImageDescriptor object because the value of the height variable for the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE3D is greater than what the device allows, to know the maximum value you must ");
            strcat(message, "use the getImage3DMaxHeight method of the device you used to create the context you used to create the ");
            strcat(message, "buffer you are using to try to create an ImageDescriptor object");
            showMessageError(env, message);
            return NULL;
        }
        if (depth > image3DMaxDepth) {
            char *message = (char*)malloc(sizeof(char) * 372);
            strcpy(message, "You cannot create an ImageDescriptor object because the value of the depth variable for the image type ");
            strcat(message, "ImageDescriptor.TYPE_IMAGE3D is greater than what the device allows, to know the maximum value you must ");
            strcat(message, "use the getImage3DMaxDepth method of the device you used to create the context you used to create the ");
            strcat(message, "buffer you are using to try to create an ImageDescriptor object");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (imageType == 0x10F1 || imageType == 0x10F2 || imageType == 0x10F3) {
        numberBytesPerRow = width * numberChannels * numberBytesByDataType;
        if ((numberBytesPerRow % imagePitchAlignment) != 0) {
            char *message = (char*)malloc(sizeof(char) * 437);
            strcpy(message, "You cannot create the ImageDescriptor object because the value you provided for the width variable you ");
            strcat(message, "provided is not multiple of the value returned by the getImagePitchAlignment method, which you can use ");
            strcat(message, "with any of the devices you used to create the context you are providing to try to create this ");
            strcat(message, "ImageDescriptor object, so use that value returned by the previous method and multiply it with the value ");
            strcat(message, "you want for the width variable");
            showMessageError(env, message);
            return NULL;
        }
        numberBytesPerLayer = numberBytesPerRow * height;
    }
    if (imageType == 0x10F5) numberBytesPerLayer = width * numberChannels * numberBytesByDataType;
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jobject _bufferData = env->GetObjectField(buffer, bufferData);
    jint _sizeBlockMemory = env->GetIntField(_bufferData, sizeBlockMemory);
    if (imageType == 0x10F4 || imageType == 0x10F5 || imageType == 0x10F6) {
        if ((width * numberChannels * numberBytesByDataType) > _sizeBlockMemory) {
            char *message = (char*)malloc(sizeof(char) * 449);
            strcpy(message, "You cannot create the ImageDescriptor object because the value you provided for the width variable is ");
            strcat(message, "multiplied by the number of channels of the format you have provided for the imageChannelOrder variable, ");
            strcat(message, "it is also multiplied by the size in bytes of the type of data you have provided for the variable ");
            strcat(message, "imageChannelDataType of the ImageFormat object, the result of this multiplication is larger than the size ");
            strcat(message, "of the Buffer memory block it provided");
            showMessageError(env, message);
            return NULL;
        }
    }
    if (imageType == 0x10F1 || imageType == 0x10F2 || imageType == 0x10F3) {
        if (numberBytesPerLayer > _sizeBlockMemory) {
            char *message = (char*)malloc(sizeof(char) * 637);
            strcpy(message, "You cannot create the ImageDescriptor object because the value you provided for the height variable is ");
            strcat(message, "multiplied by the total number of bytes occupied by all the pixels of the width and height, as well as ");
            strcat(message, "the number of bytes per pixel (this value is determined by the multiplication of the values of the ");
            strcat(message, "channelOrderType and channelOrderDataType variables of the ImageFormat object you provided, the first ");
            strcat(message, "determines the number of channels of the adjusted format and the second the number of bytes of the data ");
            strcat(message, "type you have set), and the result of this multiplication is larger than the size of the buffer memory ");
            strcat(message, "block that you provided");
            showMessageError(env, message);
            return NULL;
        }
    }
    jboolean addBuffer = JNI_FALSE;
    if (imageType == 0x10F1 || imageType == 0x10F6) addBuffer = JNI_TRUE;
    addImageDescriptorToListImageDescriptor(imageType, width, height, depth, numberImages, numberBytesPerRow, numberBytesPerLayer,
                                            _currentBuffer,
    addBuffer);
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jfieldID _imageFormat = env->GetFieldID(ImageDescriptor, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID _buffer = env->GetFieldID(ImageDescriptor, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
    jfieldID __imageType = env->GetFieldID(ImageDescriptor, "imageType", "I");
    jfieldID _width = env->GetFieldID(ImageDescriptor, "imageWidth", "I");
    jfieldID _height = env->GetFieldID(ImageDescriptor, "imageHeight", "I");
    jfieldID _depth = env->GetFieldID(ImageDescriptor, "imageDepth", "I");
    jfieldID _numberBytesPerRow = env->GetFieldID(ImageDescriptor, "numberBytesPerRow", "I");
    jfieldID _numberBytesPerLayer = env->GetFieldID(ImageDescriptor, "numberBytesPerLayer", "I");
    jfieldID _numberImages = env->GetFieldID(ImageDescriptor, "numberImages", "I");
    jobject imageDescriptor = env->AllocObject(ImageDescriptor);
    env->SetIntField(imageDescriptor, currentImageDescriptor, positionCurrentImageDescriptor);
    env->SetObjectField(imageDescriptor, _imageFormat, imageFormat);
    env->SetObjectField(imageDescriptor, _buffer, buffer);
    env->SetIntField(imageDescriptor, __imageType, imageType);
    env->SetIntField(imageDescriptor, _width, width);
    env->SetIntField(imageDescriptor, _height, height);
    env->SetIntField(imageDescriptor, _depth, depth);
    env->SetIntField(imageDescriptor, _numberBytesPerRow, numberBytesPerRow);
    env->SetIntField(imageDescriptor, _numberBytesPerLayer, numberBytesPerLayer);
    env->SetIntField(imageDescriptor, _numberImages, numberImages);
    positionCurrentImageDescriptor++;
    return imageDescriptor;
}
JNICALL jstring Java_com_draico_asvappra_opencl_image_ImageDescriptor_toString(JNIEnv *env, jobject imageDescriptor) {
    jclass ImageDescriptor = env->GetObjectClass(imageDescriptor);
    jfieldID currentImageDescriptor = env->GetFieldID(ImageDescriptor, "currentImageDescriptor", "I");
    jint _currentImageDescriptor = env->GetIntField(imageDescriptor, currentImageDescriptor);
    if (_currentImageDescriptor == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot use the toString method because the ImageDescriptor object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass ImageFormat = env->FindClass("com/draico/asvappra/opencl/image/ImageFormat");
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID imageFormat = env->GetFieldID(ImageDescriptor, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
    jfieldID buffer = env->GetFieldID(ImageDescriptor, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
    jfieldID currentImageFormat = env->GetFieldID(ImageFormat, "currentImageFormat", "I");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jobject _imageFormat = env->GetObjectField(imageDescriptor, imageFormat);
    jint _currentImageFormat = env->GetIntField(_imageFormat, currentImageFormat);
    if (_currentImageFormat == -1) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "You cannot use the toString method of the ImageDescriptor object because the ImageFormat object that you used ");
        strcat(message, "to create it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobject _buffer = env->GetObjectField(imageDescriptor, buffer);
    jint _currentBuffer = env->GetIntField(_buffer, currentBuffer);
    if (_currentBuffer == -1) {
        char *message = (char*)malloc(sizeof(char) * 116);
        strcpy(message, "You cannot use the toString method of the ImageDescriptor object because the buffer you used to create it is ");
        strcat(message, "invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
    jobject _bufferData = env->GetObjectField(_buffer, bufferData);
    jint _currentMemory = env->GetIntField(_bufferData, currentMemory);
    if (_currentMemory == -1) {
        char *message = (char*)malloc(sizeof(char) * 151);
        strcpy(message, "You cannot use the toString method of the ImageDescriptor object because the buffer you provided when you ");
        strcat(message, "created the ImageDescriptor object is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return imageDescriptorToString(env, imageDescriptor);
}
JNICALL jobject Java_com_draico_asvappra_opencl_pipe_Pipe_createPipe(JNIEnv *env, jclass Pipe, jobject context, jint typeAccess, jint packetSize,
                                     jint numberPackets) {
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 72);
        strcpy(message, "You cannot create a pipe because the context you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "You cannot create the Pipe object because the version of OpenCL that is installed on your android device is ");
        strcat(message, "lower than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 68);
        strcpy(message, "You cannot create a pipe because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _typeAccess = typeAccess;
    if ((_typeAccess & (1 << 0)) == 1 << 0) _typeAccess -= 1 << 0;
    if ((_typeAccess & (1 << 9)) == 1 << 9) _typeAccess -= 1 << 9;
    if (_typeAccess != 0) {
        char *message = (char*)malloc(sizeof(char) *223);
        strcpy(message, "You cannot create a pipe because the type of access you have provided is invalid, you can only use one or both ");
        strcat(message, "available values to create a Pipe object, which are the following:\nPipe.PIPE_READ_WRITE\nPipe.PIPE_HOST_NO_ACCESS");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCreatePipe(_currentContext, typeAccess, packetSize, numberPackets);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jobject pipe = env->AllocObject(Pipe);
        jfieldID contextPipe = env->GetFieldID(Pipe, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
        jfieldID _packetSize = env->GetFieldID(Pipe, "packetSize", "I");
        jfieldID _numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
        env->SetObjectField(pipe, contextPipe, context);
        env->SetIntField(pipe, currentPipe, positionCurrentPipe);
        env->SetIntField(pipe, _packetSize, packetSize);
        env->SetIntField(pipe, _numberPackets, numberPackets);
        positionCurrentPipe++;
        return pipe;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_pipe_Pipe_getPacketSize(JNIEnv *env, jobject pipe) {
    jclass Pipe = env->GetObjectClass(pipe);
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jint _currentPipe = env->GetIntField(pipe, currentPipe);
    if (_currentPipe == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the package size of the Pipe object, because the Pipe object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID packetSize = env->GetFieldID(Pipe, "packetSize", "I");
    return env->GetIntField(pipe, packetSize);
}
JNICALL jint Java_com_draico_asvappra_opencl_pipe_Pipe_getNumberPackets(JNIEnv *env, jobject pipe) {
    jclass Pipe = env->GetObjectClass(pipe);
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jint _currentPipe = env->GetIntField(pipe, currentPipe);
    if (_currentPipe == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "You cannot get the number of packages of the Pipe object because the Pipe object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
    return env->GetIntField(pipe, numberPackets);
}
JNICALL void Java_com_draico_asvappra_opencl_pipe_Pipe_release(JNIEnv *env, jobject pipe) {
    jclass Pipe = env->GetObjectClass(pipe);
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jint _currentPipe = env->GetIntField(pipe, currentPipe);
    if (_currentPipe == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot release the Pipe object because the Pipe object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleasePipe(_currentPipe);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(pipe, currentPipe, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL jstring Java_com_draico_asvappra_opencl_pipe_Pipe_toString(JNIEnv *env, jobject pipe) {
    jclass Pipe = env->GetObjectClass(pipe);
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jint _currentPipe = env->GetIntField(pipe, currentPipe);
    if (_currentPipe == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot use the toString method because the Pipe object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return pipeToString(env, pipe);
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_sample_Sample_createSampleWithProperties(JNIEnv *env, jclass Sample, jobject context,
                                                        jboolean isNormalizedCoords, jint addressingMode, jint filterMode) {
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot create the Sample object because the context you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 175);
        strcpy(message, "You cannot create the Sampler object with the createSampleWithProperties method because the version of OpenCL ");
        strcat(message, "that is installed on your android device is less than version 2.0");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot create the Sample object because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jint _addressingMode = addressingMode;
    jint _filterMode = filterMode;
    jint counterAddressingMode = 0;
    jint counterFilterMode = 0;
    if (_addressingMode == 0x1130) { _addressingMode -= 0x1130; counterAddressingMode++; }
    if (_addressingMode == 0x1131) { _addressingMode -= 0x1131; counterAddressingMode++; }
    if (_addressingMode == 0x1132) { _addressingMode -= 0x1132; counterAddressingMode++; }
    if (_addressingMode == 0x1133) { _addressingMode -= 0x1133; counterAddressingMode++; }
    if (_addressingMode == 0x1134) { _addressingMode -= 0x1134; counterAddressingMode++; }
    if (_filterMode == 0x1140) { _filterMode -= 0x1140; counterFilterMode++; }
    if (_filterMode == 0x1141) { _filterMode -= 0x1141; counterFilterMode++; }
    if (_addressingMode != 0 || counterAddressingMode > 1) {
        char *message = (char*)malloc(sizeof(char) * 327);
        strcpy(message, "You cannot create the Sample object because the value you are using for the addressingMode variable is ");
        strcat(message, "invalid or you are using more than one value, you can only use one of the following allowed values:\n");
        strcat(message, "Sample.ADDRESS_NONE\nSample.ADDRESS_CLAMP_TO_EDGE\nSample.ADDRESS_CLAMP\nSample.ADDRESS_REPEAT\n");
        strcat(message, "Sample.ADDRESS_MIRRORED_REPEAT");
        showMessageError(env, message);
        return NULL;
    }
    if (_filterMode != 0 || counterFilterMode > 1) {
        char *message = (char*)malloc(sizeof(char) * 232);
        strcpy(message, "You cannot create the Sample object because the value you are using for the filterMode variable is invalid or ");
        strcat(message, "you are using more than 1 value, you can only use the following allowed values:\nSample.FILTER_NEAREST\n");
        strcat(message, "Sample.FILTER_LINEAR");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCreateSample(_currentContext, isNormalizedCoords, addressingMode, filterMode);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jobject sample = env->AllocObject(Sample);
        jfieldID _context = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
        jfieldID _isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
        jfieldID _addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
        jfieldID _filterMode = env->GetFieldID(Sample, "filterMode", "I");
        env->SetObjectField(sample, _context, context);
        env->SetIntField(sample, currentSample, positionCurrentSampler);
        env->SetBooleanField(sample, _isNormalizedCoords, isNormalizedCoords);
        env->SetIntField(sample, _addressingMode, addressingMode);
        env->SetIntField(sample, _filterMode, filterMode);
        positionCurrentSampler++;
        return sample;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_image_sample_Sample_getContext(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 77);
        strcpy(message, "You cannot get the context because the Sample object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID context = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
    return env->GetObjectField(sample, context);
}
JNICALL jboolean Java_com_draico_asvappra_opencl_image_sample_Sample_isNormalizedCoords(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot get the status of the coordinates (whether or not the coordinates are normalized) because the ");
        strcat(message, "Sample object you are using is invalid");
        showMessageError(env, message);
        return JNI_FALSE;
    }
    jfieldID isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
    return env->GetBooleanField(sample, isNormalizedCoords);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_sample_Sample_getAddressingMode(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 85);
        strcpy(message, "You cannot get the addressing mode because the Sample object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
    return env->GetIntField(sample, addressingMode);
}
JNICALL jint Java_com_draico_asvappra_opencl_image_sample_Sample_getFilterMode(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the filter mode because the Sample object you are using is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID filterMode = env->GetFieldID(Sample, "filterMode", "I");
    return env->GetIntField(sample, filterMode);
}
JNICALL void Java_com_draico_asvappra_opencl_image_sample_Sample_release(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 59);
        strcpy(message, "You cannot release the Sample object because it is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseSample(_currentSample);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(sample, currentSample, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL jstring Java_com_draico_asvappra_opencl_image_sample_Sample_toString(JNIEnv *env, jobject sample) {
    jclass Sample = env->GetObjectClass(sample);
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jint _currentSample = env->GetIntField(sample, currentSample);
    if (_currentSample == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot use the toString method because the Sample object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return sampleToString(env, sample);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_createProgramWithSource(JNIEnv *env, jclass Program, jobject context,
                                                        jobjectArray filesProgramSources) {
    if (context == NULL || filesProgramSources == NULL) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "You cannot create the Program object because the context and/or the array of source code files are set ");
        strcat(message, "to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot create the Program object because the context you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeArray = env->GetArrayLength(filesProgramSources);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "You cannot create the Program object because the array you provided of source files is empty");
        showMessageError(env, message);
        return NULL;
    }
    jclass File = env->FindClass("java/io/File");
    jclass FileInputStream = env->FindClass("java/io/FileInputStream");
    jclass String = env->FindClass("java/lang/String");
    jmethodID constructorFileInputStream = env->GetMethodID(FileInputStream, "<init>", "(Ljava/io/File;)V");
    jmethodID constructorString = env->GetMethodID(String, "<init>", "([B)V");
    jmethodID available = env->GetMethodID(FileInputStream, "available", "()I");
    jmethodID close = env->GetMethodID(FileInputStream, "close", "()V");
    jmethodID read = env->GetMethodID(FileInputStream, "read", "([BII)I");
    jmethodID existFile = env->GetMethodID(File, "exists", "()Z");
    jmethodID getName = env->GetMethodID(File, "getName", "()Ljava/lang/String;");
    jmethodID isFile = env->GetMethodID(File, "isFile", "()Z");
    jmethodID contains = env->GetMethodID(String, "contains", "(Ljava/lang/CharSequence;)Z");
    jstring fileExtension_c = env->NewStringUTF(".c");
    jstring fileExtension_C = env->NewStringUTF(".C");
    jstring fileExtension_h = env->NewStringUTF(".h");
    jstring fileExtension_H = env->NewStringUTF(".H");
    char **_filesProgramSources = (char**)malloc(sizeof((char*)malloc(sizeof(char))) * sizeArray);
    size_t *sizeNameFileProgramSource = (size_t*)malloc(sizeof(size_t) * sizeArray);
    for (jint position = 0; position < sizeArray; position++) {
        jobject file = env->GetObjectArrayElement(filesProgramSources, position);
        if (file == NULL) {
            char *message = (char*)malloc(sizeof(char) * 132);
            strcpy(message, "You cannot create the Program object because in the array of the source code files you provided there ");
            strcat(message, "are paths that are set to null");
            showMessageError(env, message);
            return NULL;
        }
        if (!env->CallBooleanMethod(file, existFile)) {
            char *message = (char*)malloc(sizeof(char) * 128);
            strcpy(message, "You cannot create the Program object because at least one of the file paths you provided is incorrect ");
            strcat(message, "or the file does not exist");
            showMessageError(env, message);
            return NULL;
        }
        if (!env->CallBooleanMethod(file, isFile)) {
            char *message = (char*)malloc(sizeof(char) * 102);
            strcpy(message, "You cannot create the Program object because at least one of the file paths you provided is not a file");
            showMessageError(env, message);
            return NULL;
        }
        jstring nameFile = (jstring)env->CallObjectMethod(file, getName);
        if (!env->CallBooleanMethod(nameFile, contains, fileExtension_c) && !env->CallBooleanMethod(nameFile, contains, fileExtension_C) &&
            !env->CallBooleanMethod(nameFile, contains, fileExtension_h) && !env->CallBooleanMethod(nameFile, contains, fileExtension_H)) {
            char *message = (char*)malloc(sizeof(char) * 284);
            strcpy(message, "You cannot create the Program object because at least one of the files you provided are not source ");
            strcat(message, "code files c and if this source code file requires your header file you must also specify it, the ");
            strcat(message, "source code files have a c or C extension and the header files have an extension h or H");
            showMessageError(env, message);
            return NULL;
        }
        jobject fileInputStream = env->NewObject(FileInputStream, constructorFileInputStream, file);
        jint sizeFile = env->CallIntMethod(fileInputStream, available);
        jbyteArray dataFile = env->NewByteArray(sizeFile);
        env->CallIntMethod(fileInputStream, read, dataFile, 0, sizeFile);
        env->CallVoidMethod(fileInputStream, close);
        jobject _dataFile = env->NewObject(String, constructorString, dataFile);
        sizeNameFileProgramSource[position] = env->GetStringUTFLength((jstring)_dataFile);
        _filesProgramSources[position] = (char*)env->GetStringUTFChars((jstring)_dataFile, NULL);
    }
    void **Result = GetCreateProgramWithSource(_currentContext, sizeArray, (const char**)_filesProgramSources, sizeNameFileProgramSource);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobject program = env->AllocObject(Program);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, _context, context);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithSource"));
        env->SetObjectField(program, devicesProgram, env->GetObjectField(context, devicesContext));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNIEXPORT jobject JNICALL Java_com_draico_asvappra_opencl_Program_createProgramWithSourceScriptKernel(JNIEnv *env, jclass Program, jobject context,
                                                                              jbyteArray data) {
    if (context == NULL || data == NULL) {
        char *message = (char*)malloc(sizeof(char) * 159);
        strcpy(message, "You cannot use the createProgramWithSourceScriptKernel method to create a Program object because the ");
        strcat(message, "context you provided and/or the data array are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 132);
        strcpy(message, "You cannot use the createProgramWithSourceScriptKernel method to create a Program object because the ");
        strcat(message, "context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeDataArray = env->GetArrayLength(data);
    if (sizeDataArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 139);
        strcpy(message, "You cannot use the createProgramWithSourceScriptKernel method to create a Program object because the data ");
        strcat(message, "array that provided this is empty");
        showMessageError(env, message);
        return NULL;
    }
    char **scriptKernel = (char**)malloc(sizeof((char*)malloc(sizeof(char))));
    *scriptKernel = (char*)env->GetByteArrayElements(data, NULL);
    size_t *sizeScriptKernel = (size_t*)malloc(sizeof(size_t));
    *sizeScriptKernel = sizeDataArray;
    void **Result = GetCreateProgramWithSource(_currentContext, 1, (const char**)scriptKernel, sizeScriptKernel);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobject program = env->AllocObject(Program);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, _context, context);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithSource"));
        env->SetObjectField(program, devicesProgram, env->GetObjectField(context, devicesContext));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_createProgramWithSourceAssets(JNIEnv *env, jclass Program, jobject context) {
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "You cannot create the Program object because the context and/or the array of source code files are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot create the Program object because the context you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass OpenCL = env->FindClass("com/draico/asvappra/opencl/OpenCL");
    jfieldID dataScript = env->GetStaticFieldID(OpenCL, "dataScript", "[B");
    jbyteArray _dataScript = (jbyteArray)env->GetStaticObjectField(OpenCL, dataScript);
    scriptKernel = (char**)malloc(sizeof((jchar*)malloc(sizeof(char))));
    *scriptKernel = (char*)env->GetByteArrayElements(_dataScript, NULL);
    size_t *sizeNameFileProgramSource = (size_t*)malloc(sizeof(size_t));
    sizeNameFileProgramSource[0] = env->GetArrayLength(_dataScript);
    void **Result = GetCreateProgramWithSource(_currentContext, 1, (const char**)scriptKernel, sizeNameFileProgramSource);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobject program = env->AllocObject(Program);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, _context, context);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithSource"));
        env->SetObjectField(program, devicesProgram, env->GetObjectField(context, devicesContext));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_createProgramWithIL(JNIEnv *env, jclass Program, jobject context, jbyteArray dataProgram) {
    if (context == NULL || dataProgram == NULL) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "You cannot create the Program object because the context or array with the SPIRV intermediate language program ");
        strcat(message, "data is set to null");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 169);
        strcpy(message, "You cannot create the Program object with the createProgramWithIL method because the version of OpenCL that ");
        strcat(message, "is installed on your android device is lower than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot create the Program object because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeArray = env->GetArrayLength(dataProgram);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot create the Program object because the array that provided the SPIRV intermediate language data is empty");
        showMessageError(env, message);
        return NULL;
    }
    jbyte *dataArraySPIRV = env->GetByteArrayElements(dataProgram, NULL);
    void **Result = GetCreateProgramWithIL(_currentContext, sizeArray, dataArraySPIRV);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobject program = env->AllocObject(Program);
        env->SetObjectField(program, _context, context);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithIL"));
        env->SetObjectField(program, devicesProgram, env->GetObjectField(context, devicesContext));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_createProgramWithBinary(JNIEnv *env, jclass Program, jobject context,
                                                        jobjectArray devices, jobjectArray filesBinaries,
                                                        jintArray stateFilesBinaries) {
    if (context == NULL || devices == NULL || filesBinaries == NULL) {
        char *message = (char*)malloc(sizeof(char) * 150);
        strcpy(message, "You cannot create the Program object because the context and/or the array of devices and/or the array of ");
        strcat(message, "the names of the binary files are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot create the Program object because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeArrayDevices = env->GetArrayLength(devices);
    jsize sizeArrayFilesBinaries = env->GetArrayLength(filesBinaries);
    if (sizeArrayDevices == 0 || sizeArrayFilesBinaries == 0) {
        char *message = (char*)malloc(sizeof(char) * 117);
        strcpy(message, "You cannot create the Program object because the devices array or the filesBinaries array that you provided ");
        strcat(message, "are empty");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint *currentDeviceList = (jint*)malloc(sizeof(jint) * sizeArrayDevices);
    jint *positionSubDevice = (jint*)malloc(sizeof(jint) * sizeArrayDevices);
    for (jint position1 = 0; position1 < (sizeArrayDevices -1); position1++) {
        jobject device1 = env->GetObjectArrayElement(devices, position1);
        for (jint position2 = position1 + 1; position2 < sizeArrayDevices; position2++) {
            jobject device2 = env->GetObjectArrayElement(devices, position2);
            if (device1 == NULL || device2 == NULL) {
                char *message = (char*)malloc(sizeof(char) * 122);
                strcpy(message, "You cannot create the Program object because the device array you provided, it has at least one ");
                strcat(message, "device that is set to null");
                showMessageError(env, message);
                return NULL;
            }
            jint _currentDevice1 = env->GetIntField(device1, currentDevice);
            jint _currentDevice2 = env->GetIntField(device2, currentDevice);
            if (_currentDevice1 == -1 || _currentDevice2 == -1) {
                char *message = (char*)malloc(sizeof(char) * 110);
                strcpy(message, "You cannot create the Program object because the device array you provided, it has at least one ");
                strcat(message, "invalid device");
                showMessageError(env, message);
                return NULL;
            }
            if (env->IsSameObject(device1, device2)) {
                char *message = (char*)malloc(sizeof(char) * 107);
                strcpy(message, "You cannot create the Program object because there are repeated devices in the list of devices you provided");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    for (jint position = 0; position < sizeArrayDevices; position++) {
        jobject device = env->GetObjectArrayElement(devices, position);
        if (device == NULL) {
            char *message = (char*)malloc(sizeof(char) * 122);
            strcpy(message, "You cannot create the Program object because the device array you provided, it has at least one device that is ");
            strcat(message, "set to null");
            showMessageError(env, message);
            return NULL;
        }
        jint _currentDevice = env->GetIntField(device, currentDevice);
        if (_currentDevice == -1) {
            char *message = (char*)malloc(sizeof(char) * 110);
            strcpy(message, "You cannot create the Program object because the device array you provided, it has at least one invalid device");
            showMessageError(env, message);
            return NULL;
        }
        currentDeviceList[position] = _currentDevice;
        if (env->GetBooleanField(device, isDevicePartition)) positionSubDevice[position] = env->GetIntField(device, currentSubDevice);
        else positionSubDevice[position] = 0;
    }
    jclass File = env->FindClass("java/io/File");
    jclass FileInputStream = env->FindClass("java/io/FileInputStream");
    jmethodID canReadFile = env->GetMethodID(File, "canRead", "()Z");
    jmethodID existsFile = env->GetMethodID(File, "exists", "()Z");
    jmethodID isFile = env->GetMethodID(File, "isFile", "()Z");
    jmethodID fileInputStreamConstructor = env->GetMethodID(FileInputStream, "<init>", "(Ljava/io/File;)V");
    jmethodID available = env->GetMethodID(FileInputStream, "available", "()I");
    jmethodID close = env->GetMethodID(FileInputStream, "close", "()V");
    jmethodID read = env->GetMethodID(FileInputStream, "read", "([BII)I");
    unsigned char **listFilesBinaries = (unsigned char**)malloc(sizeof((unsigned char*)malloc(sizeof(unsigned char))) * sizeArrayFilesBinaries);
    size_t *sizeFilesBinaries = (size_t*)malloc(sizeof(size_t) * sizeArrayFilesBinaries);
    for (jint position = 0; position < sizeArrayFilesBinaries; position++) {
        jobject file = env->GetObjectArrayElement(filesBinaries, position);
        if (file == NULL) {
            char *message = (char*)malloc(sizeof(char) * 126);
            strcpy(message, "You cannot create the Program object because some of the binary file paths you provided in the binary file ");
            strcat(message, "list is set to null");
            showMessageError(env, message);
            return NULL;
        }
        if (!env->CallBooleanMethod(file, existsFile)) {
            char *message = (char*)malloc(sizeof(char) * 143);
            strcpy(message, "You cannot create the Program object because the binary file that some of the binary file paths you ");
            strcat(message, "provided is incorrect or the file not exist");
            showMessageError(env, message);
            return NULL;
        }
        if (!env->CallBooleanMethod(file, isFile)) {
            char *message = (char*)malloc(sizeof(char) * 88);
            strcpy(message, "You cannot create the Program object because some of the path you provided is not a file");
            showMessageError(env, message);
            return NULL;
        }
        if (!env->CallBooleanMethod(file, canReadFile)) {
            char *message = (char*)malloc(sizeof(char) * 141);
            strcpy(message, "You cannot create the Program object because the file defined by one of the paths in the filesBinaries ");
            strcat(message, "array that you provided cannot be read");
            showMessageError(env, message);
            return NULL;
        }
        jobject fileInputStream = env->NewObject(FileInputStream, fileInputStreamConstructor, file);
        jsize sizeFile = env->CallIntMethod(fileInputStream, available);
        jbyteArray dataFile = env->NewByteArray(sizeFile);
        env->CallIntMethod(fileInputStream, read, dataFile, 0, sizeFile);
        env->CallVoidMethod(fileInputStream, close);
        jbyte *_dataFile = env->GetByteArrayElements(dataFile, NULL);
        listFilesBinaries[position] = (unsigned char*)_dataFile;
        sizeFilesBinaries[position] = sizeFile;
    }
    jint *isLoadFileSuccessfulOverDevice = NULL;
    if (stateFilesBinaries != NULL) isLoadFileSuccessfulOverDevice = (jint*)malloc(sizeof(jint) * sizeArrayFilesBinaries);
    void **Result = GetCreateProgramWithBinaries(_currentContext, currentDeviceList, positionSubDevice, sizeArrayDevices, sizeFilesBinaries,
                                                 (const unsigned char**)listFilesBinaries, isLoadFileSuccessfulOverDevice);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID _devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jobject program = env->AllocObject(Program);
        env->SetObjectField(program, _context, context);
        env->SetObjectField(program, _devices, devices);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithBinaries"));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        if (stateFilesBinaries != NULL) env->SetIntArrayRegion(stateFilesBinaries, 0, sizeArrayFilesBinaries, NULL);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_createProgramWithBuiltInKernels(JNIEnv *env, jclass Program, jobject context,
                                                                jobjectArray devices, jobjectArray kernelNames) {
    if (context == NULL || kernelNames == NULL) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot create the Program object because the context and/or the kernel name list are set to null");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 180);
        strcpy(message, "You cannot create the Program object with the createProgramWithBuiltInKernels method because the version of ");
        strcat(message, "OpenCL that is installed on your android device is less than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    if (_currentContext == -1) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot create the Program object because the context you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray _devices;
    if (devices == NULL) {
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobjectArray _devicesContext = (jobjectArray)env->GetObjectField(context, devicesContext);
        _devices = _devicesContext;
    } else _devices = devices;
    jsize sizeDevices = env->GetArrayLength(_devices);
    jsize sizeKernelNames = env->GetArrayLength(kernelNames);
    if (sizeDevices == 0 || sizeKernelNames == 0) {
        char *message = (char*)malloc(sizeof(char) * 97);
        strcpy(message, "You cannot create the Program object because the array devices or the kernelNames array are empty");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    for (jint position1 = 0; position1 < (sizeDevices - 1); position1++) {
        jobject device1 = env->GetObjectArrayElement(_devices, position1);
        for (jint position2 = position1 + 1; position2 < sizeDevices; position2++) {
            jobject device2 = env->GetObjectArrayElement(_devices, position2);
            if (device1 == NULL || device2 == NULL) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot create the Program object because the list of devices you provided contains at least one ");
                strcat(message, "device that is set to null");
                showMessageError(env, message);
                return NULL;
            }
            jint _currentDevice1 = env->GetIntField(device1, currentDevice);
            jint _currentDevice2 = env->GetIntField(device2, currentDevice);
            if (_currentDevice1 == -1 || _currentDevice2 == -1) {
                char *message = (char*)malloc(sizeof(char) * 117);
                strcpy(message, "You cannot create the Program object because in the list of devices you provided there is at least ");
                strcat(message, "one invalid device");
                showMessageError(env, message);
                return NULL;
            }
            if (env->IsSameObject(device1, device2)) {
                char *message = (char*)malloc(sizeof(char) * 115);
                strcpy(message, "You cannot create the Program object because the list of devices you provided contains at least 2 ");
                strcat(message, "identical devices");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    for (jint position = 0; position < sizeKernelNames; position++) {
        jstring kernelName = (jstring)env->GetObjectArrayElement(kernelNames, position);
        jsize sizeKernelName = env->GetStringUTFLength(kernelName);
        if (sizeKernelName == 0) {
            char *message = (char*)malloc(sizeof(char) * 128);
            strcpy(message, "You cannot create the Program object because there is at least 1 empty kernel name in the list of kernel ");
            strcat(message, "names that you provided");
            showMessageError(env, message);
            return NULL;
        }
    }
    jint *listDevices = (jint*)malloc(sizeof(jint) * sizeDevices);
    jint *listSubDevices = (jint*)malloc(sizeof(jint) * sizeDevices);
    jclass String = env->FindClass("java/lang/String");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    for (jint position = 0; position < sizeDevices; position++) {
        jobject device = env->GetObjectArrayElement(devices, position);
        listDevices[position] = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) listSubDevices[position] = env->GetIntField(device, currentSubDevice);
        else listSubDevices[position] = 0;
    }
    jstring listKernelNames = env->NewStringUTF("");
    jstring semiColon = env->NewStringUTF(";");
    for (jint position = 0; position < sizeKernelNames; position++) {
        jstring name = (jstring)env->GetObjectArrayElement(kernelNames, position);
        listKernelNames = (jstring)env->CallObjectMethod(listKernelNames, concat, name);
        if (position < (sizeKernelNames - 1)) listKernelNames = (jstring)env->CallObjectMethod(listKernelNames, concat, semiColon);
    }
    const char *_listKernelNames = env->GetStringUTFChars(listKernelNames, NULL);
    void **Result = GetCreateProgramWithBuiltInKernels(_currentContext, sizeDevices, listDevices, listSubDevices, _listKernelNames);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID _context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID _devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jobject program = env->AllocObject(Program);
        env->SetObjectField(program, _context, context);
        env->SetObjectField(program, _devices, devices);
        env->SetIntField(program, currentProgram, positionCurrentProgram);
        env->SetObjectField(program, typeProgram, env->NewStringUTF("createProgramWithBuiltInKernels"));
        positionCurrentProgram++;
        return program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_Program_releaseProgram(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 59);
        strcpy(message, "You cannot release the Program object because it is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseProgram(_currentProgram);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(program, currentProgram, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_Program_setProgramReleaseCallback(JNIEnv *env, jobject program, jobject callbackProgram) {
    if (callbackProgram == NULL) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot adjust the Callback to monitor the release of the Program object because the callback you provided ");
        strcat(message, "is set to null");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.2) {
        char *message = (char*)malloc(sizeof(char) * 148);
        strcpy(message, "You cannot use the setProgramReleaseCallback method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.2");
        showMessageError(env, message);
        return;
    }
    jclass Program = env->GetObjectClass(program);
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 159);
        strcpy(message, "You cannot get to use the setProgramReleaseCallback method because the Program object you are using was ");
        strcat(message, "created with the createProgramWithBuildInKernels method");
        showMessageError(env, message);
        return;
    }
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 127);
        strcpy(message, "You cannot adjust the Callback to monitor the release of the Program object because the Program object you ");
        strcat(message, "are using is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = SetProgramReleaseCallback(env, program, callbackProgram);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_Program_setProgramSpecializationConstant(JNIEnv *env, jobject program, jint specializationID,
                                                      jobject dataSpecialization) {
    if (dataSpecialization == NULL) {
        char *message = (char*)malloc(sizeof(char) * 150);
        strcpy(message, "You cannot use the SetProgramSpecializationConstant method of the Program object you are using, because the ");
        strcat(message, "dataSpecialization variable is set to null");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.2) {
        char *message = (char*)malloc(sizeof(char) * 152);
        strcpy(message, "You cannot use the setProgramSpecializationConstant method because the version of OpenCL that your android ");
        strcat(message, "device has installed is less than version 2.2");
        showMessageError(env, message);
        return;
    }
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "You cannot use the setProgramSpecializationConstant method because the Program object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramCreateWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 321);
        strcpy(message, "You cannot use the setProgramSpecializationConstant method because the Program object you are using was ");
        strcat(message, "not created with the createProgramWithIL method, for this you must have created a previously compiled code ");
        strcat(message, "using the SPIRV api, and load the binary data from the static library generated after compiling the SPIRV code");
        showMessageError(env, message);
        return;
    }
    jclass Object = env->FindClass("java/lang/Object");
    jclass Class = env->FindClass("java/lang/Class");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Boolean = env->FindClass("java/lang/Boolean");
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Long = env->FindClass("java/lang/Long");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
    jmethodID booleanValue = env->GetMethodID(Boolean, "booleanValue", "()Z");
    jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
    jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
    jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jobject objectClass = env->CallObjectMethod(dataSpecialization, getClass);
    jstring name = (jstring)env->CallObjectMethod(objectClass, getName);
    const char *_name = env->GetStringUTFChars(name, NULL);
    size_t sizeData;
    void **Result;
    if (!env->CallBooleanMethod(objectClass, isArray)) {
        if (env->IsInstanceOf(dataSpecialization, Short)) {
            sizeData = sizeof(cl_short);
            cl_short data = env->CallShortMethod((jobject)dataSpecialization, shortValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Boolean)) {
            sizeData = sizeof(cl_bool);
            cl_bool data = env->CallBooleanMethod((jobject)dataSpecialization, booleanValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Byte)) {
            sizeData = sizeof(cl_uchar);
            cl_uchar data = env->CallByteMethod((jobject)dataSpecialization, byteValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Float)) {
            sizeData = sizeof(cl_float);
            cl_float data = env->CallFloatMethod((jobject)dataSpecialization, floatValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Double)) {
            sizeData = sizeof(cl_double);
            cl_double data = env->CallDoubleMethod((jobject)dataSpecialization, doubleValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Integer)) {
            sizeData = sizeof(cl_int);
            cl_int data = env->CallIntMethod((jobject)dataSpecialization, intValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else if (env->IsInstanceOf(dataSpecialization, Long)) {
            sizeData = sizeof(cl_long);
            cl_long data = env->CallLongMethod((jobject)dataSpecialization, longValue);
            Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, &data);
        } else {
            char *message = (char*)malloc(sizeof(char) * 310);
            strcpy(message, "You cannot use the setProgramSpecializationConstant method because you can only use primitive data types ");
            strcat(message, "such as int, short, long, float, double, byte and boolean, as well as object type data such as Integer, ");
            strcat(message, "Short, Long, Float, Double, Byte and Boolean to the dataSpecialization variable that you must provide");
            showMessageError(env, message);
            return;
        }
    } else {
        jsize sizeArray = env->GetArrayLength((jobjectArray)dataSpecialization);
        if (strcmp(_name, "[I") == 0) {
        sizeData = sizeof(jint) * sizeArray;
        jint *data = env->GetIntArrayElements((jintArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[S") == 0) {
        sizeData = sizeof(jshort) * sizeArray;
        jshort *data = env->GetShortArrayElements((jshortArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[B") == 0) {
        sizeData = sizeof(jbyte) *sizeArray;
        jbyte *data = env->GetByteArrayElements((jbyteArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[F") == 0) {
        sizeData = sizeof(jfloat) * sizeArray;
        jfloat *data = env->GetFloatArrayElements((jfloatArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[D") == 0) {
        sizeData = sizeof(jdouble) * sizeArray;
        jdouble *data = env->GetDoubleArrayElements((jdoubleArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[J") == 0) {
        sizeData = sizeof(jlong) * sizeArray;
        jlong *data = env->GetLongArrayElements((jlongArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Z") == 0) {
        sizeData = sizeof(jboolean) * sizeArray;
        jboolean *data = env->GetBooleanArrayElements((jbooleanArray)dataSpecialization, NULL);
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[I") == 0) {
        jint **data = (jint**)malloc(sizeof((jint*)malloc(sizeof(jint))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jintArray dataArray = (jintArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 206);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the int primitive data type for the dataSpecialization variable, but this array contains ");
                strcat(message, "null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 225);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the primitive data type int for the dataSpecialization variable, but this two-dimensional ");
                strcat(message, "array contains empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jint) * sizeArrayData;
            data[position] = env->GetIntArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[S") == 0) {
        jshort **data = (jshort**)malloc(sizeof((jshort*)malloc(sizeof(jshort))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jshortArray dataArray = (jshortArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 188);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type short for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 208);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type short for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jshort) * sizeArrayData;
            data[position] = env->GetShortArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[B") == 0) {
        jbyte **data = (jbyte**)malloc(sizeof((jbyte*)malloc(sizeof(jbyte))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jbyteArray dataArray = (jbyteArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 187);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type byte for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength((dataArray));
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 207);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type byte for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jbyte) * sizeArrayData;
            data[position] = env->GetByteArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[F") == 0) {
        jfloat **data = (jfloat**)malloc(sizeof((jfloat*)malloc(sizeof(jfloat))) * sizeArray);
        sizeData = 0;
        for (jint position  = 0; position < sizeArray; position++) {
            jfloatArray dataArray = (jfloatArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 188);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type float for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 208);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type float for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jfloat) * sizeArrayData;
            data[position] = env->GetFloatArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[D") == 0) {
        jdouble **data = (jdouble**)malloc(sizeof((jdouble*)malloc(sizeof(jdouble))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jdoubleArray dataArray = (jdoubleArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 189);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type double for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type double for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jdouble) * sizeArrayData;
            data[position] = env->GetDoubleArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[J") == 0) {
        jlong **data = (jlong**)malloc(sizeof((jlong*)malloc(sizeof(jlong))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jlongArray dataArray = (jlongArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 187);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type long for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type long for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jlong) * sizeArrayData;
            data[position] = env->GetLongArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Z") == 0) {
        jboolean **data = (jboolean**)malloc(sizeof((jboolean*)malloc(sizeof(jboolean))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jbooleanArray dataArray = (jbooleanArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 190);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type boolean for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeArrayData = env->GetArrayLength(dataArray);
            if (sizeArrayData == 0) {
                char *message = (char*)malloc(sizeof(char) * 210);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type boolean for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(jboolean) * sizeArrayData;
            data[position] = env->GetBooleanArrayElements(dataArray, NULL);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Integer;") == 0) {
        cl_int *data = (cl_int*)malloc(sizeof(cl_int) * sizeArray);
        sizeData = sizeof(cl_int) * sizeData;
        for (jint position = 0; position < sizeArray; position++) {
            jobject integerValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (integerValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 136);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided ");
                strcat(message, "of the Integer type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallIntMethod(integerValue, intValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Short;") == 0) {
        cl_short *data = (cl_short*)malloc(sizeof(cl_short) * sizeArray);
        sizeData = sizeof(cl_short) * sizeArray;
        for (jint position = 0; position < sizeArray; position++) {
            jobject _shortValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_shortValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 134);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided ");
                strcat(message, "of the Short type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallShortMethod(_shortValue, shortValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Byte;") == 0) {
        cl_uchar *data = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeArray);
        sizeData = sizeof(cl_uchar) * sizeArray;
        for (jint position = 0; position < sizeData; position++) {
            jobject _byteValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_byteValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 133);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided of ");
                strcat(message, "the Byte type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallByteMethod(_byteValue, byteValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Float;") == 0) {
        cl_float *data = (cl_float*)malloc(sizeof(cl_float) * sizeArray);
        sizeData = sizeof(cl_float) * sizeArray;
        for (jint position = 0; position < sizeData; position++) {
            jobject _floatValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_floatValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 134);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided ");
                strcat(message, "of the Float type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallFloatMethod(_floatValue, floatValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Double;") == 0) {
        cl_double *data = (cl_double*)malloc(sizeof(cl_double) * sizeArray);
        sizeData = sizeof(cl_double) * sizeArray;
        for (jint position = 0; position < sizeData; position++) {
            jobject _doubleValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_doubleValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 135);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided of ");
                strcat(message, "the Double type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallDoubleMethod(_doubleValue, doubleValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Long;") == 0) {
        cl_long *data = (cl_long*)malloc(sizeof(cl_long) * sizeArray);
        sizeData = sizeof(cl_long) * sizeArray;
        for (jint position = 0; position < sizeData; position++) {
            jobject _longValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_longValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 133);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided of ");
                strcat(message, "the Long type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallLongMethod(_longValue, longValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[Ljava.lang.Boolean;") == 0) {
        cl_bool *data = (cl_bool*)malloc(sizeof(cl_bool) * sizeArray);
        sizeData = sizeof(cl_bool) * sizeArray;
        for (jint position = 0; position < sizeData; position++) {
            jobject _booleanValue = env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (_booleanValue == NULL) {
                char *message = (char*)malloc(sizeof(char) * 136);
                strcpy(message, "You cannot use the set Program Specialization Constant method because the data array you provided of ");
                strcat(message, "the Boolean type contains null data");
                showMessageError(env, message);
                return;
            }
            data[position] = env->CallBooleanMethod(_booleanValue, booleanValue);
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Integer;") == 0) {
        cl_int **data = (cl_int**)malloc(sizeof((cl_int*)malloc(sizeof(cl_int))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 194);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Integer type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeIntegerArray = env->GetArrayLength(dataArray);
            if (sizeIntegerArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 210);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Integer for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_int) * sizeIntegerArray;
            data[position] = (cl_int*)malloc(sizeof(cl_int) * sizeIntegerArray);
            for (jint positionData = 0; positionData < sizeIntegerArray; positionData++) {
                jobject integerValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallIntMethod(integerValue, intValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Short;") == 0) {
        cl_short **data = (cl_short**)malloc(sizeof((cl_short*)malloc(sizeof(cl_short))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 192);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Short type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeShortArray = env->GetArrayLength(dataArray);
            if (sizeShortArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 208);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Short for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_short) * sizeShortArray;
            data[position] = (cl_short*)malloc(sizeof(cl_short) * sizeShortArray);
            for (jint positionData = 0; positionData < sizeShortArray; position++) {
                jobject _shortValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallShortMethod(_shortValue, shortValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Byte;") == 0) {
        cl_uchar **data = (cl_uchar**)malloc(sizeof((cl_uchar*)malloc(sizeof(cl_uchar))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 191);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Byte type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeByteArray = env->GetArrayLength(dataArray);
            if (sizeByteArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 207);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Byte for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_uchar) * sizeByteArray;
            data[position] = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeByteArray);
            for (jint positionData = 0; positionData < sizeByteArray; positionData++) {
                jobject _byteValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallByteMethod(_byteValue, byteValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Float;") == 0) {
        cl_float **data = (cl_float**)malloc(sizeof((cl_float*)malloc(sizeof(cl_float))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 192);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Float type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeFloatArray = env->GetArrayLength(dataArray);
            if (sizeFloatArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 208);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Float for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_float) * sizeFloatArray;
            data[position] = (cl_float*)malloc(sizeof(cl_float) * sizeFloatArray);
            for (jint positionData = 0; positionData < sizeFloatArray; positionData++) {
                jobject _floatValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallFloatMethod(_floatValue, floatValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Double;") == 0) {
        cl_double **data = (cl_double**)malloc(sizeof((cl_double*)malloc(sizeof(cl_double))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position< sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
            char *message = (char*)malloc(sizeof(char) * 193);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional array ");
                strcat(message, "of the Double type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeDoubleArray = env->GetArrayLength(dataArray);
            if (sizeDoubleArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 209);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional array ");
                strcat(message, "of type Double for the dataSpecialization variable, but this two-dimensional array contains empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_double) * sizeDoubleArray;
            data[position] = (cl_double*)malloc(sizeof(cl_double) * sizeDoubleArray);
            for (jint positionData = 0; positionData < sizeDoubleArray; positionData++) {
                jobject _doubleValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallDoubleMethod(_doubleValue, doubleValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Long;") == 0) {
        cl_long **data = (cl_long**)malloc(sizeof((cl_long*)malloc(sizeof(cl_long))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 191);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Long type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeLongArray = env->GetArrayLength(dataArray);
            if (sizeLongArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 207);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Long for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_long) * sizeLongArray;
            data[position] = (cl_long*)malloc(sizeof(cl_long) * sizeLongArray);
            for (jint positionData = 0; positionData < sizeLongArray; positionData++) {
                jobject _longValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallLongMethod(_longValue, longValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else if (strcmp(_name, "[[Ljava.lang.Boolean;") == 0) {
        cl_bool **data = (cl_bool**)malloc(sizeof((cl_bool*)malloc(sizeof(cl_bool))) * sizeArray);
        sizeData = 0;
        for (jint position = 0; position < sizeArray; position++) {
            jobjectArray dataArray = (jobjectArray)env->GetObjectArrayElement((jobjectArray)dataSpecialization, position);
            if (dataArray == NULL) {
                char *message = (char*)malloc(sizeof(char) * 194);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of the Boolean type for the dataSpecialization variable, but the array contains null data");
                showMessageError(env, message);
                return;
            }
            jsize sizeBooleanArray = env->GetArrayLength(dataArray);
            if (sizeBooleanArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 210);
                strcpy(message, "You cannot use the setProgramSpecializationConstant method because you are using a two-dimensional ");
                strcat(message, "array of type Boolean for the dataSpecialization variable, but this two-dimensional array contains ");
                strcat(message, "empty arrays");
                showMessageError(env, message);
                return;
            }
            sizeData += sizeof(cl_bool) * sizeBooleanArray;
            data[position] = (cl_bool*)malloc(sizeof(cl_bool) * sizeBooleanArray);
            for (jint positionData = 0; positionData < sizeBooleanArray; positionData++) {
                jobject _booleanValue = env->GetObjectArrayElement(dataArray, positionData);
                data[position][positionData] = env->CallBooleanMethod(_booleanValue, booleanValue);
            }
        }
        Result = SetProgramSpecializationConstant(_currentProgram, specializationID, sizeData, data);
    } else {
        char *message = (char*)malloc(sizeof(char) * 357);
        strcpy(message, "You cannot use the setProgramSpecializationConstant method because you can only use one-dimensional or ");
        strcat(message, "two-dimensional arrays of primitive data types such as int, short, long, float, double, byte and boolean, ");
        strcat(message, "as well as object type data such as Integer, Short, Long, Float, Double , Byte and Boolean for the ");
        strcat(message, "dataSpecialization variable that you must provide");
        showMessageError(env, message);
        return;
        }
    }
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_Program_buildProgram(JNIEnv *env, jobject program, jobjectArray devices, jstring buildOptions,
                                  jobject callbackBuildProgram) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot build the program because the Program object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBinary") == 0) {
        if (buildOptions != NULL) {
            char *message = (char*)malloc(sizeof(char) * 179);
            strcpy(message, "You cannot build the Program object because the Program object was created with the ");
            strcat(message, "createProgramWithBinary method and therefore you must not set the buildOptions variable to null");
            showMessageError(env, message);
            return;
        }
    }
    if (strcmp(__typeProgram, "createProgramWithBuiltInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 217);
        strcpy(message, "You cannot use the buildProgram method because the Program object you are using was not created with the ");
        strcat(message, "createProgramWithSource method or with the createProgramWithIL method or with the createProgramWithBinary ");
        strcat(message, "method");
        showMessageError(env, message);
        return;
    }
    jfieldID context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jobject _context = env->GetObjectField(program, context);
    jclass Context = env->GetObjectClass(_context);
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devicesContext = (jobjectArray)env->GetObjectField(_context, devicesContext);
    jobjectArray _devices;
    if (devices != NULL) {
        jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
        jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
        jsize sizeListDevices = env->GetArrayLength(devices);
        if (sizeListDevices == 0) {
            char *message = (char*)malloc(sizeof(char) * 78);
            strcpy(message, "You cannot build the program because the list of devices you provided is empty");
            showMessageError(env, message);
            return;
        }
        jsize sizeListDevicesContext = env->GetArrayLength(_devicesContext);
        for (int position1 = 0; position1 < (sizeListDevices - 1); position1++) {
            jobject device1 = env->GetObjectArrayElement(devices, position1);
            for (jint position2 = position1 + 1; position2 < sizeListDevices; position2++) {
                jobject device2 = env->GetObjectArrayElement(devices, position2);
                jint _currentDevice1 = env->GetIntField(device1, currentDevice);
                jint _currentDevice2 = env->GetIntField(device2, currentDevice);
                if (_currentDevice1 == -1 || _currentDevice2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 94);
                    strcpy(message, "You cannot build the program because the list of devices you provided contains invalid devices");
                    showMessageError(env, message);
                    return;
                }
                if (env->IsSameObject(device1, device2)) {
                    char *message = (char*)malloc(sizeof(char) * 134);
                    strcpy(message, "You cannot build the program because the list of devices you provided contains at least 2 ");
                    strcat(message, "times the same device in the list of devices");
                    showMessageError(env, message);
                    return;
                }
            }
        }
        for (jint position1 = 0; position1 < sizeListDevices; position1++) {
            jboolean exist = JNI_FALSE;
            jobject deviceList = env->GetObjectArrayElement(devices, position1);
            jint _currentDevice = env->GetIntField(deviceList, currentDevice);
            if (_currentDevice == -1) {
                char *message = (char*)malloc(sizeof(char) * 106);
                strcpy(message, "You cannot build the program because the list of devices you provided contains at least one invalid device");
                showMessageError(env, message);
                return;
            }
            for (jint position2 = 0; position2 < sizeListDevicesContext; position2++) {
                jobject deviceListContext = env->GetObjectArrayElement(_devicesContext, position2);
                if (env->IsSameObject(deviceList, deviceListContext)) {
                    exist = JNI_TRUE;
                    break;
                }
            }
            if (!exist) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot build the program because the list of devices you provided contains at least 1 device ");
                strcat(message, "that is not within the list of devices that was used to create the context that you used to ");
                strcat(message, "create the Program object you are currently using");
                showMessageError(env, message);
                return;
            }
        }
        _devices = devices;
    } else {
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jobject _devicesProgram = env->GetObjectField(program, devicesProgram);
        if (_devicesProgram == NULL) {
            jfieldID context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
            jobject _context = env->GetObjectField(program, context);
            jclass Context = env->GetObjectClass(_context);
            jfieldID devices = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
            _devices = (jobjectArray)env->GetObjectField(_context, devices);
        } else _devices = (jobjectArray)_devicesProgram;
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jint *listDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    jint *listSubDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        listDevices[position] = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) listSubDevices[position] = env->GetIntField(device, currentSubDevice);
        else listSubDevices[position] = 0;
    }
    char *_buildOptions = NULL;
    if (buildOptions != NULL) _buildOptions = (char*)env->GetStringUTFChars(buildOptions, NULL);
    void **Result = GetBuildProgram(env, _currentProgram, sizeListDevices, listDevices, listSubDevices, _buildOptions, program,
                                    callbackBuildProgram);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID isBuildProgram = env->GetFieldID(Program, "isBuildProgram", "Z");
        env->SetObjectField(program, devicesProgram, _devices);
        env->SetBooleanField(program, isBuildProgram, JNI_TRUE);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_Program_compileProgram(JNIEnv *env, jobject program, jobjectArray devices, jstring compileOptions,
                                    jobjectArray programs, jobjectArray headersFiles,
                                    jobject callbackCompileProgram) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 82);
        strcpy(message, "You cannot compile the program because the Program object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithSource") != 0 && strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 176);
        strcpy(message, "You cannot use the compileProgram method because the Program object you are using was not created with the ");
        strcat(message, "createProgramWithSource method or with the createProgramWithIL method");
        showMessageError(env, message);
        return;
    }
    jint *positionListPrograms;
    jsize sizeListPrograms = 0;
    if (programs != NULL) {
        sizeListPrograms = env->GetArrayLength(programs);
        if (sizeListPrograms == 0) {
            char *message = (char*)malloc(sizeof(char) * 86);
            strcpy(message, "You cannot compile the program because the list of programs you have provided is empty");
            showMessageError(env, message);
            return;
        }
        positionListPrograms = (jint*)malloc(sizeof(jint) * sizeListPrograms);
        for (jint position1 = 0; position1 < (sizeListPrograms - 1); position1++) {
            jobject program1 = env->GetObjectArrayElement(programs, position1);
            for (jint position2 = position1 + 1; position2 < sizeListPrograms; position2++) {
                jobject program2 = env->GetObjectArrayElement(programs, position2);
                jint currentProgram1 = env->GetIntField(program1, currentProgram);
                jint currentProgram2 = env->GetIntField(program2, currentProgram);
                if (currentProgram1 == -1 || currentProgram2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 110);
                    strcpy(message, "You cannot compile the program because the list of programs you have provided contains invalid ");
                    strcat(message, "Program objects");
                    showMessageError(env, message);
                    return;
                }
                if (env->IsSameObject(program1, program2)) {
                    char *message = (char*)malloc(sizeof(char) * 112);
                    strcpy(message, "You cannot compile the program because the list of programs you have provided contains duplicate ");
                    strcat(message, "Program objects");
                    showMessageError(env, message);
                    return;
                }
            }
        }
        for (jint position = 0; position < sizeListPrograms; position++) {
            jobject _program = env->GetObjectArrayElement(programs, position);
            jint _currentProgram = env->GetIntField(_program, currentProgram);
            if (_currentProgram == -1) {
                char *message = (char*)malloc(sizeof(char) * 109);
                strcpy(message, "You cannot compile the program, because the list of programs you provided contains at least 1 invalid ");
                strcat(message, "program");
                showMessageError(env, message);
                return;
            }
            positionListPrograms[position] = env->GetIntField(_program, currentProgram);
        }
    } else {
        if (programs != NULL) {
            char *message = (char*)malloc(sizeof(char) * 87);
            strcpy(message, "You cannot compile the program because the list of programs you provided is set to null");
            showMessageError(env, message);
            return;
        }
    }
    jobjectArray _devices;
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobject _devicesProgram = env->GetObjectField(program, devicesProgram);
    jobjectArray listDevicesProgram;
    if (_devicesProgram != NULL) listDevicesProgram = (jobjectArray)_devicesProgram;
    else {
        jobject context = env->GetObjectField(program, contextProgram);
        listDevicesProgram = (jobjectArray)env->GetObjectField(context, devicesContext);
    }
    if (devices != NULL) {
        jsize sizeListDevices = env->GetArrayLength(devices);
        if (sizeListDevices == 0) {
            char *message = (char*)malloc(sizeof(char) * 80);
            strcpy(message, "You cannot compile the program because the list of devices you provided is empty");
            showMessageError(env, message);
            return;
        }
        for (jint position1 = 0; position1 < (sizeListDevices - 1); position1++) {
            jobject device1 = env->GetObjectArrayElement(devices, position1);
            for (jint position2 = position1 + 1; position2 < sizeListDevices; position2++) {
                jobject device2 = env->GetObjectArrayElement(devices, position2);
                jint currentDevice1 = env->GetIntField(device1, currentDevice);
                jint currentDevice2 = env->GetIntField(device2, currentDevice);
                if (currentDevice1 == -1 || currentDevice2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 96);
                    strcpy(message, "You cannot compile the program because the list of devices you provided contains invalid devices");
                    showMessageError(env, message);
                    return;
                }
                if (env->IsSameObject(device1, device2)) {
                    char *message = (char*)malloc(sizeof(char) * 98);
                    strcpy(message, "You cannot compile the program because the list of devices you provided contains duplicate devices");
                    showMessageError(env, message);
                    return;
                }
            }
        }
        jsize sizeListDevicesProgram = env->GetArrayLength(listDevicesProgram);
        for (jint position1 = 0; position1 < sizeListDevices; position1++) {
            jobject device1 = env->GetObjectArrayElement(devices, position1);
            jint _currentDevice = env->GetIntField(device1, currentDevice);
            if (_currentDevice == -1) {
                char *message = (char*)malloc(sizeof(char) * 107);
                strcpy(message, "You cannot compile the program, because the list of devices you provided contains at least 1 invalid ");
                strcat(message, "device");
                showMessageError(env, message);
                return;
            }
            jboolean exist = JNI_FALSE;
            for (jint position2 = 0; position2 < sizeListDevicesProgram; position2++) {
                jobject device2 = env->GetObjectArrayElement(listDevicesProgram, position2);
                if (env->IsSameObject(device1, device2)) {
                    exist = JNI_TRUE;
                    break;
                }
            }
            if (!exist) {
                char *message = (char*)malloc(sizeof(char) * 365);
                strcpy(message, "You cannot compile the program because the list of devices you provided contains at least one device ");
                strcat(message, "that does not belong to the list of devices that were used to create the Program object you are ");
                strcat(message, "currently using, since when creating the Program object you provided a context and that context ");
                strcat(message, "contains a list of devices that can be used to work only in that context");
                showMessageError(env, message);
                return;
            }
        }
        _devices = devices;
    } else _devices = listDevicesProgram;
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jint *positionListDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    jint *positionListSubDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        positionListDevices[position] = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) positionListSubDevices[position] = env->GetIntField(device, currentSubDevice);
        else positionListSubDevices[position] = 0;
    }
    char *_compileOptions;
    if (compileOptions != NULL) _compileOptions = (char*)env->GetStringUTFChars(compileOptions, NULL);
    void **Result;
    if (headersFiles != NULL) {
        jsize sizeListHeadersFiles = env->GetArrayLength(headersFiles);
        if (sizeListHeadersFiles == 0) {
            char *message = (char*)malloc(sizeof(char) * 90);
            strcpy(message, "You cannot compile the program because the list of header files you have provided is empty");
            showMessageError(env, message);
            return;
        }
        jclass File = env->FindClass("java/io/File");
        jclass String = env->FindClass("java/lang/String");
        jmethodID contains = env->GetMethodID(String, "contains", "(Ljava/lang/CharSequence;)Z");
        jmethodID canRead = env->GetMethodID(File, "canRead", "()Z");
        jmethodID exists = env->GetMethodID(File, "exists", "()Z");
        jmethodID getAbsolutePath = env->GetMethodID(File, "getAbsolutePath", "()Ljava/lang/String;");
        jmethodID getName = env->GetMethodID(File, "getName", "()Ljava/lang/String;");
        jmethodID isFile = env->GetMethodID(File, "isFile", "()Z");
        jstring extension_h = env->NewStringUTF(".h");
        jstring extension_H = env->NewStringUTF(".H");
        for (jint position1 = 0; position1 < (sizeListHeadersFiles - 1); position1++) {
            jobject file1 = env->GetObjectArrayElement(headersFiles, position1);
            for (jint position2 = position1 + 1; position2 < sizeListHeadersFiles; position2++) {
                jobject file2 = env->GetObjectArrayElement(headersFiles, position2);
                if (env->IsSameObject(file1, file2)) {
                    char *message = (char*)malloc(sizeof(char) * 108);
                    strcpy(message, "You cannot compile the program because the list of header files you provided contains identical ");
                    strcat(message, "header files");
                    showMessageError(env, message);
                    return;
                }
                jstring path1 = (jstring)env->CallObjectMethod(file1, getAbsolutePath);
                jstring path2 = (jstring)env->CallObjectMethod(file2, getAbsolutePath);
                const char *_path1 = env->GetStringUTFChars(path1, NULL);
                const char *_path2 = env->GetStringUTFChars(path2, NULL);
                if (strcmp(_path1, _path2) == 0) {
                    char *message = (char*)malloc(sizeof(char) * 125);
                    strcpy(message, "You cannot compile the program because the list of header files that you provided at least 1 file ");
                    strcat(message, "is repeated within the list");
                    showMessageError(env, message);
                    return;
                }
            }
        }
        char **pathHeaderFiles = (char**)malloc(sizeof((cl_char*)malloc(sizeof(char))) * sizeListHeadersFiles);
        for (jint position = 0; position < sizeListHeadersFiles; position++) {
            jobject file = env->GetObjectArrayElement(headersFiles, position);
            if (!env->CallBooleanMethod(file, exists)) {
                char *message = (char*)malloc(sizeof(char) * 110);
                strcpy(message, "You cannot compile the program because the list of header files you provided contains paths to ");
                strcat(message, "files not exist");
                showMessageError(env, message);
                return;
            }
            if (!env->CallBooleanMethod(file, isFile)) {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot compile the program because the list of header files you provided contains non-file paths");
                showMessageError(env, message);
                return;
            }
            if (!env->CallBooleanMethod(file, canRead)) {
                char *message = (char*)malloc(sizeof(char) * 116);
                strcpy(message, "You cannot compile the program because the list of header files you provided contains file paths ");
                strcat(message, "without read access");
                showMessageError(env, message);
                return;
            }
            jstring nameFile = (jstring)env->CallObjectMethod(file, getName);
            jboolean containExtension_h = env->CallBooleanMethod(nameFile, contains, extension_h);
            jboolean containExtension_H = env->CallBooleanMethod(nameFile, contains, extension_H);
            if (!containExtension_h && !containExtension_H) {
                char *message = (char*)malloc(sizeof(char) * 109);
                strcpy(message, "You cannot compile the program because the list of header files you provided should only ");
                strcat(message, "contain header files");
                showMessageError(env, message);
                return;
            }
            jstring pathFile = (jstring)env->CallObjectMethod(file, getAbsolutePath);
            pathHeaderFiles[position] = (char*)env->GetStringUTFChars(pathFile, NULL);
        }
        Result = GetCompileProgram(env, _currentProgram, sizeListDevices, positionListDevices, positionListSubDevices, sizeListPrograms,
        positionListPrograms, _compileOptions, sizeListHeadersFiles, (const char**)pathHeaderFiles, program, callbackCompileProgram);
    } else {
        Result = GetCompileProgram(env, _currentProgram, sizeListDevices, positionListDevices, positionListSubDevices, sizeListPrograms,
        positionListPrograms, _compileOptions, NULL, NULL, program, callbackCompileProgram);
    }
    if (*(jint*)Result[1] == CL_SUCCESS){
        jfieldID isCompileProgram = env->GetFieldID(Program, "isCompileProgram", "Z");
        env->SetObjectField(program, devicesProgram, _devices);
        env->SetBooleanField(program, isCompileProgram, JNI_TRUE);
    } else showMessageError(env, (char*)Result[0]);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_linkProgram(JNIEnv *env, jobject program, jobject context, jobjectArray devices,
                                            jstring linkOptions, jobjectArray programs, jobject callbackLinkProgram){
    if (context == NULL) {
        char *message = (char*)malloc(sizeof(char) * 80);
        strcpy(message, "You cannot link the program because the context you have provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Context = env->GetObjectClass(context);
    jclass Program = env->GetObjectClass(program);
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentContext = env->GetIntField(context, currentContext);
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentContext == -1 || _currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 94);
        strcpy(message, "You cannot link the program because the context or the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithSource") != 0 && strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 173);
        strcpy(message, "You cannot use the linkProgram method because the Program object you are using was not created with the ");
        strcat(message, "createProgramWithSource method or with the createProgramWithIL method");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray _programs;
    jsize sizeListPrograms;
    if (programs != NULL) {
        sizeListPrograms = env->GetArrayLength(programs);
        if (sizeListPrograms == 0) {
            char *message = (char*)malloc(sizeof(char) * 83);
            strcpy(message, "You cannot link the program because the list of programs you have provided is empty");
            showMessageError(env, message);
            return NULL;
        }
        for (jint position1 = 0; position1 < (sizeListPrograms - 1); position1++) {
            jobject program1 = env->GetObjectArrayElement(programs, position1);
            for (jint position2 = position1 + 1; position2 < sizeListPrograms; position2++) {
                jobject program2 = env->GetObjectArrayElement(programs, position2);
                jint currentProgram1 = env->GetIntField(program1, currentProgram);
                jint currentProgram2 = env->GetIntField(program2, currentProgram);
                if (currentProgram1 == -1 || currentProgram2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 95);
                    strcpy(message, "You cannot link the program because the list of programs you provided contains invalid programs");
                    showMessageError(env, message);
                    return NULL;
                }
                if (env->IsSameObject(program1, program2)) {
                    char *message = (char*)malloc(sizeof(char) * 97);
                    strcpy(message, "You cannot link the program because the list of programs you provided contains duplicate programs");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
        for (jint position = 0; position < sizeListPrograms; position++) {
            jobject _program = env->GetObjectArrayElement(programs, position);
            if (env->IsSameObject(program, _program)) {
                char *message = (char*)malloc(sizeof(char) * 176);
                strcpy(message, "You cannot link the program because the program list contains the Program object you are using, ");
                strcat(message, "this Program object will be added internally to the list of programs you provide");
                showMessageError(env, message);
                return NULL;
            }
            jint _currentProgram = env->GetIntField(_program, currentProgram);
            if (_currentProgram == -1) {
                char *message = (char*)malloc(sizeof(char) * 107);
                strcpy(message, "You cannot link the program because the list of programs you provided contains at least one invalid ");
                strcat(message, "program");
                showMessageError(env, message);
                return NULL;
            }
        }
        _programs = env->NewObjectArray(sizeListPrograms + 1, Program, program);
        for (jint position = 0; position < sizeListPrograms; position++) {
            jobject _program = env->GetObjectArrayElement(programs, position);
            env->SetObjectArrayElement(_programs, position + 1, _program);
        }
        sizeListPrograms++;
    } else {
        sizeListPrograms = 1;
        _programs = env->NewObjectArray(sizeListPrograms, Program, program);
    }
    jobjectArray _devices;
    jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devicesContext = (jobjectArray)env->GetObjectField(context, devicesContext);
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    if (devices == NULL) _devices = _devicesContext;
    else {
        jsize sizeListDevices = env->GetArrayLength(devices);
        if (sizeListDevices == 0) {
            char *message = (char*)malloc(sizeof(char) * 77);
            strcpy(message, "You cannot link the program because the list of devices you provided is empty");
            showMessageError(env, message);
            return NULL;
        }
        jsize sizeListDevicesContext = env->GetArrayLength(_devicesContext);
        for (jint position1 = 0; position1 < (sizeListDevices - 1); position1++) {
            jobject device1 = env->GetObjectArrayElement(devices, position1);
            for (jint position2 = position1 + 1; position2 < sizeListDevices; position2++) {
                jobject device2 = env->GetObjectArrayElement(devices, position2);
                jint _currentDevice1 = env->GetIntField(device1, currentDevice);
                jint _currentDevice2 = env->GetIntField(device2, currentDevice);
                if (_currentDevice1 == -1 || _currentDevice2 == -1) {
                    char *message = (char*)malloc(sizeof(char) * 103);
                    strcpy(message, "You cannot link the program because the list of devices you provided contains at least 1 invalid ");
                    strcat(message, "device");
                    showMessageError(env, message);
                    return NULL;
                }
                if (env->IsSameObject(device1, device2)) {
                    char *message = (char*)malloc(sizeof(char) * 95);
                    strcpy(message, "You cannot link the program because the list of devices you provided contains duplicate devices");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
        for (jint position1 = 0; position1 < sizeListDevices; position1++) {
            jobject device = env->GetObjectArrayElement(devices, position1);
            jint _currentDevice = env->GetIntField(device, currentDevice);
            if (_currentDevice == -1) {
                char *message = (char*)malloc(sizeof(char) * 105);
                strcpy(message, "You cannot link the program because the list of devices you provided contains at least one ");
                strcat(message, "invalid device");
                showMessageError(env, message);
                return NULL;
            }
            jboolean exist = JNI_FALSE;
            for (jint position2 = 0; position2 < sizeListDevicesContext; position2++) {
                jobject deviceContext = env->GetObjectArrayElement(_devicesContext, position2);
                if (env->IsSameObject(device, deviceContext)) {
                    exist = JNI_TRUE;
                    break;
                }
            }
            if (!exist) {
                char *message = (char*)malloc(sizeof(char) * 175);
                strcpy(message, "You cannot link the program because the list of devices you provided contains at least 1 device that ");
                strcat(message, "was not used to create the context you provided to try to link the program");
                showMessageError(env, message);
                return NULL;
            }
        }
        _devices = devices;
    }
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jint *_listDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    jint *listSubDevices = (jint*)malloc(sizeof(jint) * sizeListDevices);
    jint *listPrograms = (jint*)malloc(sizeof(jint) * sizeListPrograms);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _listDevices[position] = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) listSubDevices[position] = env->GetIntField(device, currentSubDevice);
        else listSubDevices[position] = 0;
    }
    for (jint position = 0; position < sizeListPrograms; position++) {
        jobject _program = env->GetObjectArrayElement(_programs, position);
        listPrograms[position] = env->GetIntField(_program, currentProgram);
    }
    char *_linkOptions = NULL;
    if (linkOptions != NULL) _linkOptions = (char*)env->GetStringUTFChars(linkOptions, NULL);
    void **Result = GetLinkProgram(env, _currentContext, sizeListDevices, _listDevices, listSubDevices, _linkOptions, sizeListPrograms,
    listPrograms, program, callbackLinkProgram);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID isLinkedProgram = env->GetFieldID(Program, "isLinkedProgram", "Z");
        jobject _program = env->AllocObject(Program);
        env->SetIntField(_program, currentProgram, positionCurrentProgram);
        env->SetObjectField(_program, contextProgram, context);
        env->SetObjectField(_program, devicesProgram, _devices);
        env->SetObjectField(_program, typeProgram, _typeProgram);
        env->SetBooleanField(_program, isLinkedProgram, JNI_TRUE);
        positionCurrentProgram++;
        return _program;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_Program_unloadPlatformCompiler(JNIEnv *env, jobject program, jobject platform) {
    if (platform == NULL) {
        char *message = (char*)malloc(sizeof(char) * 192);
        strcpy(message, "The compiler of the platform to which it was assigned cannot be released by using a Program object using ");
        strcat(message, "the buildProgram or compileProgram method, because the provided platform is set to null");
        showMessageError(env, message);
        return;
    }
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 201);
        strcpy(message, "You cannot release the compiler from the platform to which it was assigned by using a Program object using ");
        strcat(message, "the buildProgram or compileProgram method, because the Program object you are using is invalid");
        showMessageError(env, message);
        return;
    }
    jclass Platform = env->GetObjectClass(platform);
    jfieldID currentPlatform = env->GetFieldID(Platform, "currentPlatform", "I");
    jint _currentPlatform = env->GetIntField(platform, currentPlatform);
    void **Result = UnloadPlatformCompiler(_currentPlatform);
    if (*(jint*)Result[1] != CL_SUCCESS) showMessageError(env, (char*)Result[0]);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Program_getContext(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the context of the Program object because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    return env->GetObjectField(program, context);
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Program_getDevices(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the devices of the Program object because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobject _devices = env->GetObjectField(program, devices);
    jobjectArray devicesList;
    if (_devices == NULL) {
        jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
        jfieldID devicesContext = env->GetFieldID(Context, "devices", "[Lcom/draico/asvappra/opencl/Device;");
        jfieldID context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
        jobject _context = env->GetObjectField(program, context);
        devicesList = (jobjectArray)env->GetObjectField(_context, devicesContext);
    } else devicesList = (jobjectArray)_devices;
    return devicesList;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getFilesProgramSource(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 167);
        strcpy(message, "You cannot get the source code that you used to create the Program object using the createProgramWithSource ");
        strcat(message, "method, because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithSource") != 0 && strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 183);
        strcpy(message, "You cannot use the getFilesProgramSource method because the Program object you are using was not created ");
        strcat(message, "with the createProgramWithSource method or with the createProgramWithIL method");
        showMessageError(env, message);
        return NULL;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_SOURCE, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
        jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
        const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
        if (dataFile != NULL && strcmp(__typeProgram, "createProgramWithSource") == 0) return env->NewStringUTF(dataFile);
        else return NULL;
    }
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getProgramIL(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    jvm->AttachCurrentThread(&env, NULL);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 104);
        strcpy(message, "You cannot get the SPIR-V code of the Program object because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 191);
        strcpy(message, "You cannot get the SPIR-V code using the getProgramIL method of the Program object you are using because the ");
        strcat(message, "version of OpenCL that your android device has installed is lower than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "You cannot get the SPIR-V code of the Program object because this Program object was not created using the ");
        strcat(message, "createProgramWithIL method");
        showMessageError(env, message);
        return NULL;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_IL, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return env->NewStringUTF(dataFile);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Program_getSizeFileProgramBinaries(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "You cannot get the length of the binary program (size in bytes) that is in the Program object because it ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 231);
        strcpy(message, "You cannot use the getSizeFileProgramBinaries method because the Program object you are using was not created ");
        strcat(message, "with the createProgramWithSource method or with the createProgramWithIL method or with the ");
        strcat(message, "createProgramWithBinary method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isBuildProgram = env->GetFieldID(Program, "isBuildProgram", "Z");
    jfieldID isLinkedProgram = env->GetFieldID(Program, "isLinkedProgram", "Z");
    jfieldID isCompileProgram = env->GetFieldID(Program, "isCompileProgram", "Z");
    jboolean _isBuildProgram = env->GetBooleanField(program, isBuildProgram);
    jboolean _isLinkedProgram = env->GetBooleanField(program, isLinkedProgram);
    jboolean _isCompileProgram = env->GetBooleanField(program, isCompileProgram);
    if (!_isBuildProgram && !_isLinkedProgram && !_isCompileProgram) {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "You cannot get the binary files of the Program object of the Program object you are using because this ");
        strcat(message, "Program object has not yet been builded, linked or compiled");
        showMessageError(env, message);
        return NULL;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_BINARY_SIZES, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        if (sizeData == 0) return NULL;
        jintArray listSizeArrays = env->NewIntArray(sizeData);
        jint *data = (jint*)malloc(sizeof(jint) * sizeData);
        for (jint position  = 0; position < sizeData; position++) data[position] = sizeFiles[position];
        env->SetIntArrayRegion(listSizeArrays, 0, sizeData, data);
        return listSizeArrays;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Program_getFilesProgramBinaries(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 226);
        strcpy(message, "You cannot get the content of the binary programs (which were created and run on each of the devices you ");
        strcat(message, "provided in the buildProgram, compileProgram and linkProgram methods) because the Program object you are ");
        strcat(message, "using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    size_t sizeData;
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 223);
        strcpy(message, "You cannot get the binary files of the Program object you are using because this Program object was created ");
        strcat(message, "with the createProgramWithBuildInKernels constructor and therefore there are no binary files in this ");
        strcat(message, "Program object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isBuildProgram = env->GetFieldID(Program, "isBuildProgram", "Z");
    jfieldID isLinkedProgram = env->GetFieldID(Program, "isLinkedProgram", "Z");
    jfieldID isCompileProgram = env->GetFieldID(Program, "isCompileProgram", "Z");
    jboolean _isBuildProgram = env->GetBooleanField(program, isBuildProgram);
    jboolean _isLinkedProgram = env->GetBooleanField(program, isLinkedProgram);
    jboolean _isCompileProgram = env->GetBooleanField(program, isCompileProgram);
    if (!_isBuildProgram && !_isLinkedProgram && !_isCompileProgram) {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "You cannot get the binary files of the Program object of the Program object you are using because this ");
        strcat(message, "Program object has not yet been builded, linked or compiled");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getSizeFileProgramBinaries = env->GetMethodID(Program, "getSizeFileProgramBinaries", "()[I");
    jobject sizeFileProgramBinaries = env->CallObjectMethod(program, getSizeFileProgramBinaries);
    if (sizeFileProgramBinaries == NULL) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "You cannot get the data from the binary files you used to create and build the Program object you are using");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_BINARIES, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jint *_sizeFileProgramBinaries;
        jsize numberFilesProgramBinaries;
        _sizeFileProgramBinaries = env->GetIntArrayElements((jintArray)sizeFileProgramBinaries, NULL);
        numberFilesProgramBinaries = env->GetArrayLength((jintArray)sizeFileProgramBinaries);
        jclass byteArrayClass = env->FindClass("[B");
        jobjectArray data = env->NewObjectArray(numberFilesProgramBinaries, byteArrayClass, NULL);
        for (jint position = 0; position < numberFilesProgramBinaries; position++) {
            char *dataBinary = (char*)dataBinaryFiles[position];
            jbyte *_dataBinary = (jbyte*)dataBinary;
            jsize sizeArray = _sizeFileProgramBinaries[position];
            jbyteArray binaryArray = env->NewByteArray(sizeArray);
            env->SetByteArrayRegion(binaryArray, 0, sizeArray, _dataBinary);
            env->SetObjectArrayElement(data, position, binaryArray);
        }
        return data;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Program_getNumberKernels(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 96);
        strcpy(message, "You cannot get the number of kernels with the Program object you are using because it is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithSource") != 0 && strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 172);
        strcpy(message, "You cannot get the number of kernels because the Program object you are using was not created with the ");
        strcat(message, "createProgramWithSource method or with the createProgramWithIL method");
        showMessageError(env, message);
        return 0;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_NUM_KERNELS, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return numKernels;
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Program_getProgramKernelName(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "You cannot get the name of the kernels that are working with the Program object you are using because ");
        strcat(message, "it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithSource") != 0 && strcmp(__typeProgram, "createProgramWithIL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 169);
        strcpy(message, "You cannot get the kernel name(s) because the Program object you are using was not created with the ");
        strcat(message, "createProgramWithSource method or with the createProgramWithIL method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isBuildProgram = env->GetFieldID(Program, "isBuildProgram", "Z");
    jboolean _isBuildProgram = env->GetBooleanField(program, isBuildProgram);
    if (!_isBuildProgram) {
        char *message = (char*)malloc(sizeof(char) * 194);
        strcpy(message, "You cannot get the kernel name because the Program object you are using has not yet been build, so you ");
        strcat(message, "will have to use the buildProgram method first, so you can try again to get the kernel name");
        showMessageError(env, message);
        return NULL;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_KERNEL_NAMES, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jclass Pattern = env->FindClass("java/util/regex/Pattern");
        jclass String = env->FindClass("java/lang/String");
        jmethodID quote = env->GetStaticMethodID(Pattern, "quote", "(Ljava/lang/String;)Ljava/lang/String;");
        jmethodID split = env->GetMethodID(String, "split", "(Ljava/lang/String;)[Ljava/lang/String;");
        jstring _nameKernels = env->NewStringUTF(dataFile);
        jstring pattern = env->NewStringUTF(";");
        jstring _pattern = (jstring)env->CallStaticObjectMethod(Pattern, quote, pattern);
        jobjectArray kernelNames = (jobjectArray)env->CallObjectMethod(_nameKernels, split, _pattern);
        return kernelNames;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Program_isScopeGlobalConstructorsPresent(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 129);
        strcpy(message, "You cannot determine if the Program object contains non-trivial constructors, because the Program ");
        strcat(message, "object you are using is invalid");
        showMessageError(env, message);
        return false;
    }
    if (VersionOpenCL < 2.2) {
        char *message = (char*)malloc(sizeof(char) * 275);
        strcpy(message, "You cannot determine if the Program object contains non-trivial constructors using the ");
        strcat(message, "isScopeGlobalConstructorsPresentmethod, because this feature is only available for versions of OpenCL ");
        strcat(message, "greater than or equal to 2.2, and your device has a lower version of OpenCL installed");
        showMessageError(env, message);
        return false;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataProgramPresent;
    else {
        showMessageError(env, (char*)Result[0]);
        return false;
    }
}
JNICALL jboolean Java_com_draico_asvappra_opencl_Program_isScopeGlobalDestructorsPresent(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 128);
        strcpy(message, "You cannot determine if the Program object contains non-trivial destructors, because the Program object ");
        strcat(message, "you are using is invalid");
        showMessageError(env, message);
        return false;
    }
    if (VersionOpenCL < 2.2) {
        char *message = (char*)malloc(sizeof(char) * 273);
        strcpy(message, "You cannot determine if the Program object contains non-trivial destructors using the ");
        strcat(message, "isScopeGlobalDestructorsPresent method, because this feature is only available for versions of OpenCL ");
        strcat(message, "greater than or equal to 2.2, and your device has a lower version of OpenCL installed");
        showMessageError(env, message);
        return false;
    }
    size_t sizeData;
    void **Result = GetProgramInfo(_currentProgram, CL_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataProgramPresent;
    else {
        showMessageError(env, (char*)Result[0]);
        return false;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getBuildStatus(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 98);
        strcpy(message, "You cannot get the build status of the program because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 215);
        strcpy(message, "You cannot obtain the program build status because the Program object you are using was created with the ");
        strcat(message, "createProgramWithBuildInKernels method and therefore this Program object cannot be builded, linked or ");
        strcat(message, "compiled");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("");
    jint _currentDevice, _currentSubDevice;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _currentDevice = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
        else _currentSubDevice = 0;
        size_t sizeData;
        void **Result = GetProgramBuildInfo(_currentProgram, _currentDevice, _currentSubDevice, CL_PROGRAM_BUILD_STATUS, &sizeData);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            jstring __currentDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentDevice);
            jstring __currentSubDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentSubDevice);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("#device: "));
            toString = (jstring)env->CallObjectMethod(toString, concat, __currentDevice);
            if (env->GetBooleanField(device, isDevicePartition)) {
                toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  #subDevice: "));
                toString = (jstring)env->CallObjectMethod(toString, concat, __currentSubDevice);
            }
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  state: "));
            switch(buildStatus) {
                case CL_BUILD_NONE: toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("without build\n")); break;
                case CL_BUILD_ERROR: toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("build error\n")); break;
                case CL_BUILD_SUCCESS: toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("build success\n")); break;
                case CL_BUILD_IN_PROGRESS: toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("build in progress")); break;
            }
            if (position == (sizeListDevices - 1)) return toString;
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getBuildOptions(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 133);
        strcpy(message, "You cannot get the build options (compile, link, or build options) of the program because the Program ");
        strcat(message, "object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 149);
        strcpy(message, "You cannot get to use the getBuildOptions method because the Program object you are using was created ");
        strcat(message, "with the createProgramWithBuildInKernels method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("");
    jint _currentDevice, _currentSubDevice;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _currentDevice = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
        else _currentSubDevice = 0;
        size_t sizeData;
        void **Result = GetProgramBuildInfo(_currentProgram, _currentDevice, _currentSubDevice, CL_PROGRAM_BUILD_OPTIONS, &sizeData);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            jstring __currentDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentDevice);
            jstring __currentSubDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentSubDevice);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("#device: "));
            toString = (jstring)env->CallObjectMethod(toString, concat, __currentDevice);
            if (env->GetBooleanField(device, isDevicePartition)) {
                toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  #subDevice: "));
                toString = (jstring)env->CallObjectMethod(toString, concat, __currentSubDevice);
            }
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  options: "));
            if (sizeData > 0) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(dataBuildProgram));
            else toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(" none\n"));
            if (position == (sizeListDevices - 1)) return toString;
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getBuildLog(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 88);
        strcpy(message, "You cannot get the program build log because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 145);
        strcpy(message, "You cannot get to use the getBuildLog method because the Program object you are using was created with the ");
        strcat(message, "createProgramWithBuildInKernels method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("");
    jint _currentDevice, _currentSubDevice;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _currentDevice = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
        else _currentSubDevice = 0;
        size_t sizeData;
        void **Result = GetProgramBuildInfo(_currentProgram, _currentDevice, _currentSubDevice, CL_PROGRAM_BUILD_LOG, &sizeData);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            jstring __currentDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentDevice);
            jstring __currentSubDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentSubDevice);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("#device: "));
            toString = (jstring)env->CallObjectMethod(toString, concat, __currentDevice);
            if (env->GetBooleanField(device, isDevicePartition)) {
                toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  #subDevice: "));
                toString = (jstring)env->CallObjectMethod(toString, concat, __currentSubDevice);
            }
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  build log: "));
            if (sizeData > 0) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(dataBuildProgram));
            else toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(" none\n"));
            if (position == (sizeListDevices - 1)) return toString;
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_getBinaryType(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the type of binary loaded on each device assigned to the Program object because the ");
        strcat(message, "Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("");
    jint _currentDevice, _currentSubDevice;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _currentDevice = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
        else _currentSubDevice = 0;
        size_t sizeData;
        void **Result = GetProgramBuildInfo(_currentProgram, _currentDevice, _currentSubDevice, CL_PROGRAM_BINARY_TYPE, &sizeData);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            jstring _binaryType;
            switch(programBinaryType) {
                case CL_PROGRAM_BINARY_TYPE_NONE: _binaryType = env->NewStringUTF("no binary\n"); break;
                case CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT: _binaryType = env->NewStringUTF("compile binary\n"); break;
                case CL_PROGRAM_BINARY_TYPE_LIBRARY: _binaryType = env->NewStringUTF("library binary\n"); break;
                case CL_PROGRAM_BINARY_TYPE_EXECUTABLE: _binaryType = env->NewStringUTF("executable binary\n");
            }
            jstring __currentDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentDevice);
            jstring __currentSubDevice = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, _currentSubDevice);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("#device: "));
            toString = (jstring)env->CallObjectMethod(toString, concat, __currentDevice);
            if (env->GetBooleanField(device, isDevicePartition)) {
                toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  #subDevice: "));
                toString = (jstring)env->CallObjectMethod(toString, concat, __currentSubDevice);
            }
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("  binary type: "));
            toString = (jstring)env->CallObjectMethod(toString, concat, _binaryType);
            if (position == (sizeListDevices - 1)) return toString;
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Program_getSize(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 176);
        strcpy(message, "You cannot get the size in bytes of each compiled and builded program that was assigned to each device ");
        strcat(message, "of the Program object because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 218);
        strcpy(message, "You cannot get the size in bytes of each compiled and builded program that was assigned to each device ");
        strcat(message, "of the Program object because the version of OpenCL that your android device has installed is less than ");
        strcat(message, "version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID typeProgram = env->GetFieldID(Program, "typeProgram", "Ljava/lang/String;");
    jstring _typeProgram = (jstring)env->GetObjectField(program, typeProgram);
    const char *__typeProgram = env->GetStringUTFChars(_typeProgram, NULL);
    if (strcmp(__typeProgram, "createProgramWithBuildInKernels") == 0) {
        char *message = (char*)malloc(sizeof(char) * 141);
        strcpy(message, "You cannot get to use the getSize method because the Program object you are using was created with the ");
        strcat(message, "createProgramWithBuildInKernels method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jintArray listSizePrograms = env->NewIntArray(sizeListDevices);
    jint *_listSizePrograms = (jint*)malloc(sizeof(jint) * sizeListDevices);
    jint _currentDevice, _currentSubDevice;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        _currentDevice = env->GetIntField(device, currentDevice);
        if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
        else _currentSubDevice = 0;
        size_t sizeData;
        void **Result = GetProgramBuildInfo(_currentProgram, _currentDevice, _currentSubDevice, CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE,
                                            &sizeData);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            _listSizePrograms[position] = sizeProgramVariables;
            if (position == (sizeListDevices - 1)) {
                env->SetIntArrayRegion(listSizePrograms, 0, sizeListDevices, _listSizePrograms);
                return listSizePrograms;
            }
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Program_toString(JNIEnv *env, jobject program) {
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 180);
        strcpy(message, "You cannot get the size in bytes of each compiled and constructed program that was assigned to each device of ");
        strcat(message, "the Program object because the Program object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return programToString(env, program);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_createKernel(JNIEnv *env, jclass Kernel, jobject program, jstring kernelName) {
    if (program == NULL || kernelName == NULL) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "You cannot create the kernel because because the Program object and/or the kernel name are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 87);
        strcpy(message, "You cannot create the kernel because because the Program object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCreateKernel(_currentProgram, env->GetStringUTFChars(kernelName, NULL));
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
        jfieldID programKernel = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
        jobject kernel = env->AllocObject(Kernel);
        env->SetIntField(kernel, currentKernel, positionCurrentKernel);
        env->SetObjectField(kernel, programKernel, program);
        positionCurrentKernel++;
        return kernel;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobjectArray Java_com_draico_asvappra_opencl_Kernel_createKernelsInProgram(JNIEnv *env, jclass Kernel, jobject program) {
    if (program == NULL) {
        char *message = (char*)malloc(sizeof(char) * 164);
        strcpy(message, "You cannot create the kernel list for all methods or functions that are declared with the __kernel ");
        strcat(message, "qualifier, because the Program object you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Program = env->GetObjectClass(program);
    jfieldID currentProgram = env->GetFieldID(Program, "currentProgram", "I");
    jint _currentProgram = env->GetIntField(program, currentProgram);
    if (_currentProgram == -1) {
        char *message = (char*)malloc(sizeof(char) * 160);
        strcpy(message, "You cannot create the kernel list for all methods or functions that are declared with the __kernel ");
        strcat(message, "qualifier, because the Program object you provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    cl_uint sizeArray;
    void **Result = GetCreateKernelsInProgram(_currentProgram, &sizeArray);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
        jfieldID programKernel = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
        jobjectArray kernelList = env->NewObjectArray(sizeArray, Kernel, NULL);
        for (jint position = 0; position < sizeArray; position++) {
        jobject kernel = env->AllocObject(Kernel);
        env->SetIntField(kernel, currentKernel, positionCurrentKernel);
        env->SetObjectField(kernel, programKernel, program);
        env->SetObjectArrayElement(kernelList, position, kernel);
        positionCurrentKernel++;
    }
    return kernelList;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_NDRangeKernel(JNIEnv *env, jobject kernel, jobject commandQueue, jint workNumberDimensions,
                                           jintArray globalWorkOffset, jintArray globalWorkSize, jintArray localWorkSize) {
    if (commandQueue == NULL || globalWorkOffset == NULL || globalWorkSize == NULL || localWorkSize == NULL) {
        char *message = (char*)malloc(sizeof(char) * 213);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method because the CommandQueue object and/or the ");
        strcat(message, "globalWorkOffset array and/or the globalWorkSize array and/or the localWorkSize array you provided ");
        strcat(message, "are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentKernel == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 127);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method because CommandQueue object and/or the kernel ");
        strcat(message, "you are using are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    jboolean _isSetArguments = env->GetBooleanField(kernel, isSetArguments);
    if (!_isSetArguments) {
        char *message = (char*)malloc(sizeof(char) * 400);
        strcpy(message, "You cannot run the kernel you are using with the CommandQueue object that you provided, because you ");
        strcat(message, "have not yet adjusted the kernel method arguments that you wrote in a c file, so you will have to use ");
        strcat(message, "the setKernelArguments method to adjust the list of kernel method arguments that you wrote in the c ");
        strcat(message, "file, which you used to create the Program object that you used to create the kernel you are using");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextProgram = env->GetObjectField(_program, contextProgram);
    if (!env->IsSameObject(_contextCommandQueue, _contextProgram)) {
        char *message = (char*)malloc(sizeof(char) * 264);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method, because the Program object that you used to ");
        strcat(message, "create the kernel (which you are using), was not created in the same context that you used to create ");
        strcat(message, "the CommandQueue object, with which you want to run the kernel");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeGlobalWorkdOffset = env->GetArrayLength(globalWorkOffset);
    jsize sizeGlobalWorkSize = env->GetArrayLength(globalWorkSize);
    jsize sizeLocalWorkSize = env->GetArrayLength(localWorkSize);
    if (sizeGlobalWorkdOffset != 3 || sizeGlobalWorkSize == 0 || sizeLocalWorkSize == 0) {
        char *message = (char*)malloc(sizeof(char) * 220);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method because the globalWorkOffset array does not ");
        strcat(message, "have a length of 3 data, the problem can also be caused because the globalWorkSize and/or localWorkSize ");
        strcat(message, "arrays are empty");
        showMessageError(env, message);
        return NULL;
    }
    if (sizeGlobalWorkSize != sizeLocalWorkSize) {
        char *message = (char*)malloc(sizeof(char) * 134);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method, because the size of the globalWorkSize and ");
        strcat(message, "localWorkSize arrays are not equal");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getBuildOptions = env->GetMethodID(Program, "getBuildOptions", "()Ljava/lang/String;");
    jobject buildOptions = env->CallObjectMethod(_program, getBuildOptions);
    if (buildOptions == NULL) {
        char *message = (char*)malloc(sizeof(char) * 203);
        strcpy(message, "You cannot run the kernel with the NDRangeKernel method because the Program object that you provided ");
        strcat(message, "when you created in kernel does not allow you to get the build options with the getBuildOptions method");
        showMessageError(env, message);
        return NULL;
    }
    jclass String = env->FindClass("java/lang/String");
    jmethodID contains = env->GetMethodID(String, "contains", "(Ljava/lang/CharSequence;)Z");
    jstring option = env->NewStringUTF("-cl-uniform-work-group-size");
    jboolean isWorkGroupsUniforms = env->CallBooleanMethod((jstring)buildOptions, contains, option);
    jint *dataGlobalWorkOffset = env->GetIntArrayElements(globalWorkOffset, NULL);
    jint *dataGlobalWorkSize = env->GetIntArrayElements(globalWorkSize, NULL);
    jint *dataLocalWorkSize = env->GetIntArrayElements(localWorkSize, NULL);
    jint totalGlobalWorkSize = 1;
    jint totalLocalWorkSize = 1;
    jint sumTotalLocalWorkSize = 0;
    for (jint position = 0; position < sizeGlobalWorkSize; position++) {
        if (isWorkGroupsUniforms) {
            if (dataGlobalWorkSize[position] < 0 || dataLocalWorkSize[position] < 0) {
                char *message = (char*)malloc(sizeof(char) * 138);
                strcpy(message, "You cannot run the kernel with the NDRangeKernel method because the globalWorkSize and ");
                strcat(message, "localWorkSize arrays contain values set less than 0");
                showMessageError(env, message);
                return NULL;
            }
            if (dataLocalWorkSize[position] > 0) {
                if (dataLocalWorkSize[position] > 0 && (dataGlobalWorkSize[position] % dataLocalWorkSize[position]) != 0) {
                    char *message = (char*)malloc(sizeof(char) * 173);
                    strcpy(message, "You cannot run the kernel with the NDRangeKernel method, because some of the data in ");
                    strcat(message, "the globalWorkSize array is not multiple of the same position in the localWorkSize array");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
        totalGlobalWorkSize *= dataGlobalWorkSize[position];
        totalLocalWorkSize *= dataLocalWorkSize[position];
        sumTotalLocalWorkSize += dataLocalWorkSize[position];
    }
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jmethodID getMaxWorkItemDimensions = env->GetMethodID(Device, "getMaxWorkItemDimensions", "()I");
    jmethodID getMaxWorkGroupSize = env->GetMethodID(Device, "getMaxWorkGroupSize", "()I");
    jmethodID getMaxWorkItemSizes = env->GetMethodID(Device, "getMaxWorkItemSizes", "()[I");
    jmethodID getWorkGroupSize = env->GetMethodID(Kernel, "getWorkGroupSize", "(Lcom/draico/asvappra/opencl/Device;)I");
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devices, position);
        jint maxWorkItemDimensions = env->CallIntMethod(device, getMaxWorkItemDimensions);
        if (workNumberDimensions < 0 || workNumberDimensions > maxWorkItemDimensions) {
            char *message = (char*)malloc(sizeof(char) * 457);
            strcpy(message, "You cannot run the kernel with the NDRangeKernel method because the value you set to the ");
            strcat(message, "workNumberDimensions variable is less than 0, it may also be that the value of the workNumberDimensions ");
            strcat(message, "variable is greater than the value returned by the getMaxWorkItemDimensions method, the previous method ");
            strcat(message, "can be used any of the devices in the list of devices you used to create, compile, link and build the ");
            strcat(message, "Program object you used to create the kernel you are using");
            showMessageError(env, message);
            return NULL;
        }
        jint deviceWorkGroupSize = env->CallIntMethod(kernel, getWorkGroupSize, device);
        jint maxWorkGroupSize = env->CallIntMethod(device, getMaxWorkGroupSize);
        if (totalGlobalWorkSize > maxWorkGroupSize) {
            char *message = (char*)malloc(sizeof(char) * 348);
            strcpy(message, "You cannot run the kernel with the NDRangeKernel method because multiplied all the values that you set in ");
            strcat(message, "the globalWorkSize array, exceed the value returned by the getMaxWorkGroupSize method of any of the ");
            strcat(message, "devices in the list of devices you used to create, compile, link and build the Program object that you ");
            strcat(message, "used to create the kernel you are using");
            showMessageError(env, message);
            return NULL;
        }
        jintArray deviceMaxWorkItemSizes = (jintArray)env->CallObjectMethod(device, getMaxWorkItemSizes);
        jint *dataDeviceMaxItemSizes = env->GetIntArrayElements(deviceMaxWorkItemSizes, NULL);
        jsize sizeDeviceMaxWorkItemSizes = env->GetArrayLength(deviceMaxWorkItemSizes);
        if (totalLocalWorkSize > deviceWorkGroupSize) {
            char *message = (char*)malloc(sizeof(char) * 487);
            strcpy(message, "You cannot run the kernel with the NDRangeKernel method because all the values that you provided in the ");
            strcat(message, "localWorkSize array, multiplying all of your array values exceed the value returned by the ");
            strcat(message, "getWorkGroupSize method of the kernel you are using, the getWorkGroupSize method requires the use of a ");
            strcat(message, "device, so you have to use the devices that were used to create the Program object you used to create ");
            strcat(message, "the kernel you are using or the devices you used to compile, link and build the program");
            showMessageError(env, message);
            return NULL;
        }
        if (dataLocalWorkSize[0] > dataDeviceMaxItemSizes[0]) {
            if (dataDeviceMaxItemSizes[sizeDeviceMaxWorkItemSizes - 1] > 0) {
                if (dataLocalWorkSize[sizeLocalWorkSize - 1] > dataDeviceMaxItemSizes[sizeDeviceMaxWorkItemSizes - 1]) {
                    char *message = (char *) malloc(sizeof(char) * 651);
                    strcpy(message, "You cannot run the kernel with the NDRangeKernel method, because the size that you set in the ");
                    strcat(message, "localWorkSize, array exceeds the size allowed by the values returned by the getMaxWorkItemSizes ");
                    strcat(message, "method, of the devices you provided when you created the Program object you used to create the ");
                    strcat(message, "kernel that is using, the specified size of the first position of the localWorkSize array, must ");
                    strcat(message, "be less than or equal to the data of the first position of the array returned by the ");
                    strcat(message, "getMaxWorkItemSizes method, and the last position of the localWorkSize array must be less than or ");
                    strcat(message, "equal to the data of the last array position returned by the getMaxWorkItemSizes method");
                    showMessageError(env, message);
                    return NULL;
                }
            }
        }
    }
    size_t *_globalWorkOffset = (size_t*)malloc(sizeof(size_t) * sizeGlobalWorkdOffset);
    size_t *_globalWorkSize = (size_t*)malloc(sizeof(size_t) * sizeGlobalWorkSize);
    size_t *_localWorkSize = (size_t*)malloc(sizeof(size_t) * sizeLocalWorkSize);
    for (jint position = 0; position < sizeGlobalWorkdOffset; position++) {
        _globalWorkOffset[position] = dataGlobalWorkOffset[position];
    }
    for (jint position = 0; position < sizeGlobalWorkSize; position++) {
        _globalWorkSize[position] = dataGlobalWorkSize[position];
        _localWorkSize[position] = dataLocalWorkSize[position];
    }
    void **Result = GetEnqueueNDRangeKernel(_currentKernel, _currentCommandQueue, workNumberDimensions, _globalWorkOffset, _globalWorkSize,
                                            _localWorkSize);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID isKernelExecuted = env->GetFieldID(Kernel, "isKernelExecuted", "Z");
        env->SetBooleanField(kernel, isKernelExecuted, JNI_TRUE);
        return newEvent(env, NULL, commandQueue);
    }
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_nativeKernel(JNIEnv *env, jclass Kernel, jobject commandQueue,
                                          jobject functionNativeKernel, jobjectArray argsFunctionNativeKernel) {
    if (commandQueue == NULL || functionNativeKernel == NULL || argsFunctionNativeKernel == NULL) {
        char *message = (char*)malloc(sizeof(char) * 180);
        strcpy(message, "You cannot run the kernel with the nativeKernel method because the CommandQueue object and/or the kernel's ");
        strcat(message, "native function and/or the list of arguments you provided are set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 111);
        strcpy(message, "You cannot run the kernel with the nativeKernel method because the CommandQueue object you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID device = env->GetFieldID(CommandQueue, "currentDevice", "Lcom/draico/asvappra/opencl/Device;");
    jobject _device = env->GetObjectField(commandQueue, device);
    jclass Device = env->GetObjectClass(_device);
    jmethodID getExecutionCapabilities = env->GetMethodID(Device, "getExecutionCapabilities", "()Ljava/lang/String;");
    jstring executionCapabilities = (jstring)env->CallObjectMethod(_device, getExecutionCapabilities);
    const char *_executionCapabilities = env->GetStringUTFChars(executionCapabilities, NULL);
    if (strcmp(_executionCapabilities, "EXECUTION_NATIVE_KERNEL") != 0) {
        char *message = (char*)malloc(sizeof(char) * 422);
        strcpy(message, "You cannot use the nativeKernel method to execute the functionNativeKernel method because the device ");
        strcat(message, "associated with the CommandQueue object can only execute external kernels, to verify it use the device ");
        strcat(message, "associated with the CommandQueue object and use the getExecutionCapabilities method of that device, the ");
        strcat(message, "resulting name returned by the method above must be EXECUTION_NATIVE_KERNEL so you can use the ");
        strcat(message, "nativeKernel method");
        showMessageError(env, message);
        return NULL;
    }
    jsize sizeListArgs = env->GetArrayLength(argsFunctionNativeKernel);
    if (sizeListArgs == 0) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments provided is empty");
        showMessageError(env, message);
        return NULL;
    }
    jclass Object = env->FindClass("java/lang/Object");
    jclass Class = env->FindClass("java/lang/Class");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Long = env->FindClass("java/lang/Long");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Boolean = env->FindClass("java/lang/Boolean");
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass Character = env->FindClass("java/lang/Character");
    jclass String = env->FindClass("java/lang/String");
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    jclass Image = env->FindClass("com/draico/asvappra/opencl/image/Image");
    jclass Pipe = env->FindClass("com/draico/asvappra/opencl/pipe/Pipe");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jclass Sample = env->FindClass("com/draico/asvappra/opencl/image/sample/Sample");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
    jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
    jmethodID booleanValue = env->GetMethodID(Boolean, "booleanValue", "()Z");
    jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
    jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jsize sizeListObjectMem = 0;
    for (jint position = 0; position < sizeListArgs; position++) {
        jobject argument = env->GetObjectArrayElement(argsFunctionNativeKernel, position);
        jobject objectClass = env->CallObjectMethod(argument, getClass);
        if (!env->CallBooleanMethod(objectClass, isArray)) {
            if (env->IsInstanceOf(argument, Buffer)) {
                jint _currentBuffer = env->GetIntField((jobject)argument, currentBuffer);
                if (_currentBuffer == -1) {
                    char *message = (char*)malloc(sizeof(char) * 125);
                    strcpy(message, "You cannot run the kernel with the nativeKernel method because the argument list you provided ");
                    strcat(message, "contains invalid Buffer objects");
                    showMessageError(env, message);
                    return NULL;
                }
                sizeListObjectMem++;
            } else if (env->IsInstanceOf(argument, Image)) {
                jint _currentImage = env->GetIntField((jobject)argument, currentImage);
                if (_currentImage == -1) {
                    char *message = (char*)malloc(sizeof(char) * 124);
                    strcpy(message, "You cannot run the kernel with the nativeKernel method because the argument list you provided ");
                    strcat(message, "contains invalid Image objects");
                    showMessageError(env, message);
                    return NULL;
                }
                sizeListObjectMem++;
            } else if (env->IsInstanceOf(argument, Pipe)) {
                jint _currentPipe = env->GetIntField((jobject)argument, currentPipe);
                if (_currentPipe == -1) {
                    char *message = (char*)malloc(sizeof(char) * 100);
                    strcpy(message, "You cannot run the kernel with the nativeKernel method because the argument list you provided ");
                    strcat(message, "contains invalid Pipe objects");
                    showMessageError(env, message);
                    return NULL;
                }
                sizeListObjectMem++;
            }
        } else {
            jsize sizeList = env->GetArrayLength((jobjectArray)argument);
            jstring name = (jstring)env->CallObjectMethod(objectClass, getName);
            const char *_name = env->GetStringUTFChars(name, NULL);
            if (strcmp(_name, "[Lcom.draico.asvappra.opencl.memory.buffer.Buffer;") == 0) {
                for (jint positionData = 0; positionData < sizeList; positionData++) {
                    jobject buffer = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (buffer == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 220);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you provided ");
                        strcat(message, "contains objects which are lists of Buffers objects, but this list of Buffers objects contains ");
                        strcat(message, "Buffers objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    jint _currentBuffer = env->GetIntField((jobject)buffer, currentBuffer);
                    if (_currentBuffer == -1) {
                        char *message = (char*)malloc(sizeof(char) * 216);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you provided ");
                        strcat(message, "contains objects which are lists of Buffers objects, but this list of Buffers objects contains ");
                        strcat(message, "Buffers objects invalid");
                        showMessageError(env, message);
                        return NULL;
                    }
                }
                sizeListObjectMem += sizeList;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.image.Image;") == 0) {
                for (jint positionData = 0; positionData < sizeList; positionData++) {
                    jobject image = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (image == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 214);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you provided ");
                        strcat(message, "contains objects which are lists of Image objects, but this list of Image objects contains Image ");
                        strcat(message, "objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    jint _currentImage = env->GetIntField((jobject)image, currentImage);
                    if (_currentImage == -1) {
                        char *message = (char*)malloc(sizeof(char) * 210);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you provided ");
                        strcat(message, "contains objects which are lists of Image objects, but this list of Image objects contains Image ");
                        strcat(message, "objects invalid");
                        showMessageError(env, message);
                        return NULL;
                    }
                }
                sizeListObjectMem += sizeList;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.pipe.Pipe;") == 0) {
                for (jint positionData = 0; positionData < sizeList; positionData++) {
                    jobject pipe = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (pipe == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 211);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Pipe objects, but this list of Pipe objects ");
                        strcat(message, "contains Pipe objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    jint _currentPipe = env->GetIntField((jobject)pipe, currentPipe);
                    if (_currentPipe == -1) {
                        char *message = (char*)malloc(sizeof(char) * 207);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Pipe objects, but this list of Pipe objects ");
                        strcat(message, "contains Pipe objects invalid");
                        showMessageError(env, message);
                        return NULL;
                    }
                }
                sizeListObjectMem += sizeList;
            }
        }
    }
    void *dataArguments[sizeListArgs];
    cl_mem *listObjectsMem = NULL;
    cl_mem **listObjectsMemAddress = NULL;
    if (sizeListObjectMem > 0) {
        listObjectsMem = (cl_mem*)malloc(sizeof(cl_mem) * sizeListObjectMem);
        listObjectsMemAddress = (cl_mem**)malloc(sizeof((cl_mem*)malloc(sizeof(cl_mem))) * sizeListObjectMem);
    }
    jsize sizeInBytesAllArguments = 0;
    jint positionListObjectMem = 0;
    for (jint position = 0; position < sizeListArgs; position++) {
        jobject argument = env->GetObjectArrayElement(argsFunctionNativeKernel, position);
        jobject objectClass = env->CallObjectMethod((jobject)argument, getClass);
        if (!env->CallBooleanMethod(objectClass, isArray)) {
            if (env->IsInstanceOf((jobject)argument, Integer)) {
                cl_int data = env->CallIntMethod((jobject)argument, intValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_int);
            } else if (env->IsInstanceOf((jobject)argument, Short)) {
                cl_short data = env->CallShortMethod((jobject)argument, shortValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_short);
            } else if (env->IsInstanceOf((jobject)argument, Long)) {
                cl_long data = env->CallLongMethod((jobject)argument, longValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_long);
            } else if (env->IsInstanceOf((jobject)argument, Float)) {
                cl_float data = env->CallFloatMethod((jobject)argument, floatValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_float);
            } else if (env->IsInstanceOf((jobject)argument, Double)) {
                cl_double data = env->CallDoubleMethod((jobject)argument, doubleValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_double);
            } else if (env->IsInstanceOf((jobject)argument, Boolean)) {
                cl_double data = env->CallBooleanMethod((jobject)argument, booleanValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_bool);
            } else if (env->IsInstanceOf((jobject)argument, Byte)) {
                cl_uchar data = env->CallByteMethod((jobject)argument, byteValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_uchar);
            } else if (env->IsInstanceOf((jobject)argument, Character)) {
                cl_char data = env->CallCharMethod((jobject)argument, charValue);
                dataArguments[position] = &data;
                sizeInBytesAllArguments += sizeof(cl_char);
            } else if (env->IsInstanceOf((jobject)argument, String)) {
                dataArguments[position] = (char*)env->GetStringUTFChars((jstring)argument, NULL);
                sizeInBytesAllArguments += env->GetStringLength((jstring)argument);
            } else if (env->IsInstanceOf((jobject)argument, Buffer)) {
                jint _currentBuffer = env->GetIntField((jobject)argument, currentBuffer);
                dataArguments[position] = &listBuffers[_currentBuffer];
                listObjectsMem[positionListObjectMem] = *listBuffers[_currentBuffer];
                listObjectsMemAddress[positionListObjectMem] = listBuffers[_currentBuffer];
                sizeInBytesAllArguments += sizeof(cl_mem);
                positionListObjectMem++;
            } else if (env->IsInstanceOf((jobject)argument, Image)) {
                jint _currentImage = env->GetIntField((jobject)argument, currentImage);
                dataArguments[position] = &listImage[_currentImage];
                listObjectsMem[positionListObjectMem] = *listImage[_currentImage];
                listObjectsMemAddress[positionListObjectMem] = listImage[_currentImage];
                sizeInBytesAllArguments += sizeof(cl_mem);
                positionListObjectMem++;
            } else if (env->IsInstanceOf((jobject)argument, Pipe)) {
                jint _currentPipe = env->GetIntField((jobject)argument, currentPipe);
                dataArguments[position] = &listPipes[_currentPipe];
                listObjectsMem[positionListObjectMem] = *listPipes[_currentPipe];
                listObjectsMemAddress[positionListObjectMem] = listPipes[_currentPipe];
                sizeInBytesAllArguments += sizeof(cl_mem);
                positionListObjectMem++;
            } else if (env->IsInstanceOf((jobject)argument, Memory)) {
                jint _currentMemory = env->GetIntField((jobject)argument, currentMemory);
                if (_currentMemory == -1) {
                    char *message = (char*)malloc(sizeof(char) * 125);
                    strcpy(message, "You cannot run the kernel with the nativeKernel method because the argument list you provided ");
                    strcat(message, "contains invalid Memory objects");
                    showMessageError(env, message);
                    return NULL;
                }
                jint _sizeBlockMemory = env->GetIntField((jobject)argument, sizeBlockMemory);
                dataArguments[position] = listDataMemory[_currentMemory];
                sizeInBytesAllArguments += sizeof(jbyte) * _sizeBlockMemory;
            } else if (env->IsInstanceOf(argument, Sample)) {
                jint _currentSample = env->GetIntField((jobject)argument, currentSample);
                if (_currentSample == -1) {
                    char *message = (char*)malloc(sizeof(char) * 125);
                    strcpy(message, "You cannot run the kernel with the nativeKernel method because the argument list you provided ");
                    strcat(message, "contains invalid Sample objects");
                    showMessageError(env, message);
                    return NULL;
                }
                dataArguments[position] = listSamplers[_currentSample];
                sizeInBytesAllArguments += sizeof(cl_sampler);
            } else {
                char *message = (char*)malloc(sizeof(char) * 372);
                strcpy(message, "You cannot run the kernel with the nativeKernel method because within the list of arguments you ");
                strcat(message, "provided there are arguments that are not of the allowed data types, you can only use the following ");
                strcat(message, "data types: int, short, long, float, double, boolean , byte, char, Integer, Short, Long, Float, ");
                strcat(message, "Double, Boolean, Byte, Character, String, Buffer, Image, Pipe, Memory and Sample");
                showMessageError(env, message);
                return NULL;
            }
        } else {
            jstring name = (jstring)env->CallObjectMethod(objectClass, getName);
            const char *_name = env->GetStringUTFChars(name, NULL);
            jobjectArray listArguments = (jobjectArray)argument;
            jsize sizeListArguments = env->GetArrayLength(listArguments);
            if (strcmp(_name, "[I") == 0) {
                cl_int *data = env->GetIntArrayElements((jintArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_int) * sizeListArguments;
            } else if (strcmp(_name, "[S") == 0) {
                cl_short *data = env->GetShortArrayElements((jshortArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_short) * sizeListArguments;
            } else if (strcmp(_name, "[J") == 0) {
                cl_long *data = env->GetLongArrayElements((jlongArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_long) * sizeListArguments;
            } else if (strcmp(_name, "[F") == 0) {
                cl_float *data = env->GetFloatArrayElements((jfloatArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_float) * sizeListArguments;
            } else if (strcmp(_name, "[D") == 0) {
                cl_double *data = env->GetDoubleArrayElements((jdoubleArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_double) * sizeListArguments;
            } else if (strcmp(_name, "[Z") == 0) {
                jboolean *data = env->GetBooleanArrayElements((jbooleanArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(jboolean) * sizeListArguments;
            } else if (strcmp(_name, "[B") == 0) {
                jbyte *data = env->GetByteArrayElements((jbyteArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_uchar) * sizeListArguments;
            } else if (strcmp(_name, "[C") == 0) {
                cl_char *data = (cl_char*)env->GetCharArrayElements((jcharArray)listArguments, NULL);
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_char) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Integer;") == 0) {
                cl_int *data = (cl_int*)malloc(sizeof(cl_int) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject integer = env->GetObjectArrayElement(listArguments, positionData);
                    if (integer == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 220);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Integer objects, but this list of Integer ");
                        strcat(message, "objects contains Integer objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallIntMethod(integer, intValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_int) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Short;") == 0) {
                cl_short *data = (cl_short*)malloc(sizeof(cl_short) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _short = env->GetObjectArrayElement(listArguments, positionData);
                    if (_short == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 214);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Short objects, but this list of Short objects ");
                        strcat(message, "contains Short objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallShortMethod(_short, shortValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_short) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Long;") == 0) {
                cl_long *data = (cl_long*)malloc(sizeof(cl_long) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _long = env->GetObjectArrayElement(listArguments, positionData);
                    if (_long == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 211);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Long objects, but this list of Long objects ");
                        strcat(message, "contains Long objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallLongMethod(_long, longValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_long) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Float;") == 0) {
                cl_float *data = (cl_float*)malloc(sizeof(cl_float) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _float = env->GetObjectArrayElement(listArguments, positionData);
                    if (_float == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 214);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Float objects, but this list of Float objects ");
                        strcat(message, "contains Float objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallFloatMethod(_float, floatValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_float) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Double;") == 0) {
                cl_double *data = (cl_double*)malloc(sizeof(cl_double) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _double = env->GetObjectArrayElement(listArguments, positionData);
                    if (_double == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 217);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Double objects, but this list of Double ");
                        strcat(message, "objects contains Double objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallDoubleMethod(_double, doubleValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_double) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Boolean;") == 0) {
                cl_bool *data = (cl_bool*)malloc(sizeof(cl_bool) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _boolean = env->GetObjectArrayElement(listArguments, positionData);
                    if (_boolean == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 220);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Boolean objects, but this list of Boolean ");
                        strcat(message, "objects contains Boolean objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallBooleanMethod(_boolean, booleanValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_bool) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Character;") == 0) {
                cl_char *data = (cl_char*)malloc(sizeof(cl_char) * sizeListArguments);
                for (int positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _char = env->GetObjectArrayElement(listArguments, positionData);
                    if (_char == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 226);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Character objects, but this list of Character ");
                        strcat(message, "objects contains Character objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallCharMethod(_char, charValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_char) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.Byte;") == 0) {
                cl_uchar *data = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject _byte = env->GetObjectArrayElement(listArguments, positionData);
                    if (_byte == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 211);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Byte objects, but this list of Byte objects ");
                        strcat(message, "contains Byte objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = env->CallByteMethod(_byte, byteValue);
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_uchar) * sizeListArguments;
            } else if (strcmp(_name, "[Ljava.lang.String;") == 0) {
                char **data = (char**)malloc(sizeof((char*)malloc(sizeof(char))) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject string = env->GetObjectArrayElement(listArguments, positionData);
                    if (string == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 217);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of String objects, but this list of String ");
                        strcat(message, "objects contains String objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = (char*)env->GetStringUTFChars((jstring)string, NULL);
                    sizeInBytesAllArguments += env->GetStringLength((jstring)string);
                }
                dataArguments[position] = data;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.memory.buffer.Buffer;") == 0) {
                cl_mem *data = (cl_mem*)malloc(sizeof(cl_mem) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++, positionListObjectMem++) {
                    jobject buffer = env->GetObjectArrayElement(listArguments, positionData);
                    jint _currentBuffer = env->GetIntField(buffer, currentBuffer);
                    data[positionData] = *listBuffers[_currentBuffer];
                    listObjectsMem[positionListObjectMem] = *listBuffers[_currentBuffer];
                    listObjectsMemAddress[positionListObjectMem] = listBuffers[_currentBuffer];
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_mem) * sizeListArguments;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.image.Image;") == 0) {
                cl_mem *data = (cl_mem*)malloc(sizeof(cl_mem) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++, positionListObjectMem++) {
                    jobject image = env->GetObjectArrayElement(listArguments, positionData);
                    jint _currentImage = env->GetIntField(image, currentImage);
                    data[positionData] = *listImage[_currentImage];
                    listObjectsMem[positionListObjectMem] = *listImage[_currentImage];
                    listObjectsMemAddress[positionListObjectMem] = listImage[_currentImage];
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_mem) * sizeListArguments;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.pipe.Pipe;") == 0) {
                cl_mem *data = (cl_mem*)malloc(sizeof(cl_mem) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++, positionListObjectMem++) {
                    jobject pipe = env->GetObjectArrayElement(listArguments, positionData);
                    jint _currentPipe = env->GetIntField(pipe, currentPipe);
                    data[positionData] = *listPipes[_currentPipe];
                    listObjectsMem[positionListObjectMem] = *listPipes[_currentPipe];
                    listObjectsMemAddress[positionListObjectMem] = listPipes[_currentPipe];
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_mem) * sizeListArguments;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.memory.Memory;") == 0) {
                jbyte **data = (jbyte**)malloc(sizeof((jbyte*)malloc(sizeof(jbyte))) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject memory = env->GetObjectArrayElement(listArguments, positionData);
                    if (memory == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 2171);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Memory objects, but this list of Memory ");
                        strcat(message, "objects contains Memory objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    jint _currentMemory = env->GetIntField(memory, currentMemory);
                    if (_currentMemory == -1) {
                        char *message = (char*)malloc(sizeof(char) * 213);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Memory objects, but this list of Memory objects ");
                        strcat(message, "contains Memory objects invalid");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = listDataMemory[_currentMemory];
                    sizeInBytesAllArguments += sizeof(jbyte) * env->GetIntField(memory, sizeBlockMemory);
                }
                dataArguments[position] = data;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.image.sample.Sample;") == 0) {
                cl_sampler *data = (cl_sampler*)malloc(sizeof(cl_sampler) * sizeListArguments);
                for (jint positionData = 0; positionData < sizeListArguments; positionData++) {
                    jobject sample = env->GetObjectArrayElement(listArguments, positionData);
                    if (sample == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 217);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Sample objects, but this list of Sample ");
                        strcat(message, "objects contains Sample objects set to null");
                        showMessageError(env, message);
                        return NULL;
                    }
                    jint _currentSample = env->GetIntField(sample, currentSample);
                    if (_currentSample == -1) {
                        char *message = (char*)malloc(sizeof(char) * 213);
                        strcpy(message, "You cannot run the kernel with the nativeKernel method because the list of arguments you ");
                        strcat(message, "provided contains objects which are lists of Sample objects, but this list of Sample objects ");
                        strcat(message, "contains Sample objects invalid");
                        showMessageError(env, message);
                        return NULL;
                    }
                    data[positionData] = *listSamplers[_currentSample];
                }
                dataArguments[position] = data;
                sizeInBytesAllArguments += sizeof(cl_sampler) * sizeListArguments;
            } else {
                char *message = (char*)malloc(sizeof(char) * 100);
                strcpy(message, "You cannot run the kernel with the nativeKernel method because within the list of arguments you ");
                strcat(message, "provided there are arguments that are lists of arguments, which are not of the allowed data types, ");
                strcat(message, "you can only use the following data types: int, short, long, float, double, boolean, byte, char, ");
                strcat(message, "Integer, Short, Long, Float, Double, Boolean, Byte, Character, String, Buffer, Image, Pipe, Memory ");
                strcat(message, "and Sample");
                showMessageError(env, message);
                return NULL;
            }
        }
    }
    void **Result = GetEnqueueNativeKernel(env, _currentCommandQueue, dataArguments, sizeInBytesAllArguments, sizeListObjectMem,
                                           listObjectsMem,
    (const void**)listObjectsMemAddress, functionNativeKernel, argsFunctionNativeKernel);
    if (*(jint*)Result[1] == CL_SUCCESS) return newEvent(env, NULL, commandQueue);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL void Java_com_draico_asvappra_opencl_Kernel_releaseKernel(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 73);
        strcpy(message, "You cannot release the kernel because the kernel you are using is invalid");
        showMessageError(env, message);
        return;
    }
    void **Result = GetReleaseKernel(_currentKernel);
    if (*(jint*)Result[1] == CL_SUCCESS) env->SetIntField(kernel, currentKernel, -1);
    else showMessageError(env, (char*)Result[0]);
}
JNICALL void Java_com_draico_asvappra_opencl_Kernel_setKernelArguments(JNIEnv *env, jobject kernel, jobject commandQueue, jobjectArray arguments) {
    if (commandQueue == NULL || arguments == NULL) {
        char *message = (char*)malloc(sizeof(char) * 459);
        strcpy(message, "You cannot adjust the kernel arguments because the CommandQueue object or the argument list is set to null, ");
        strcat(message, "the only data allowed for the argument list are as follows:\nAllowed primitive data values\nint, short, ");
        strcat(message, "long, float, double , boolean, byte and char\nValues of type allowed objects\nInteger, Short, Long, Float, ");
        strcat(message, "Double, Boolean, Byte, Character, String, Buffer, Memory, Image, Pipe and Sample\nYou can also enter data ");
        strcat(message, "arrays of types of data mentioned above");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel","I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentCommandQueue == -1 || _currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 114);
        strcpy(message, "You cannot adjust the kernel arguments because the CommandQueue object and/or the kernel you are using are ");
        strcat(message, "invalid");
        showMessageError(env, message);
        return;
    }
    void **Result;
    jclass Device = env->FindClass("com/draico/asvappra/opencl/Device");
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    jclass Image = env->FindClass("com/draico/asvappra/opencl/image/Image");
    jclass Pipe = env->FindClass("com/draico/asvappra/opencl/pipe/Pipe");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jclass Sample = env->FindClass("com/draico/asvappra/opencl/image/sample/Sample");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass Character = env->FindClass("java/lang/Character");
    jclass Boolean = env->FindClass("java/lang/Boolean");
    jclass Long = env->FindClass("java/lang/Long");
    jclass String = env->FindClass("java/lang/String");
    jclass Object = env->FindClass("java/lang/Object");
    jclass Class = env->FindClass("java/lang/Class");
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jclass Program = env->FindClass("com/draico/asvappra/opencl/Program");
    jmethodID byteValue = env->GetMethodID(Byte, "byteValue", "()B");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jmethodID shortValue = env->GetMethodID(Short, "shortValue", "()S");
    jmethodID floatValue = env->GetMethodID(Float, "floatValue", "()F");
    jmethodID doubleValue = env->GetMethodID(Double, "doubleValue", "()D");
    jmethodID longValue = env->GetMethodID(Long, "longValue", "()J");
    jmethodID booleanValue = env->GetMethodID(Boolean, "booleanValue", "()Z");
    jmethodID charValue = env->GetMethodID(Character, "charValue", "()C");
    jmethodID getClass = env->GetMethodID(Object, "getClass", "()Ljava/lang/Class;");
    jmethodID getName = env->GetMethodID(Class, "getName", "()Ljava/lang/String;");
    jmethodID isArray = env->GetMethodID(Class, "isArray", "()Z");
    jmethodID getDoubleFPConfig = env->GetMethodID(Device, "getDoubleFPConfig", "()Ljava/lang/String;");
    jmethodID getMaxConstantBufferSize = env->GetMethodID(Device, "getMaxConstantBufferSize", "()J");
    jmethodID getMaxConstantArgs = env->GetMethodID(Device, "getMaxConstantArgs", "()I");
    jfieldID programKernel = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID devicesProgram = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _programKernel = env->GetObjectField(kernel, programKernel);
    jobject _contextProgram = env->GetObjectField(_programKernel, contextProgram);
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    if (!env->IsSameObject(_contextProgram, _contextCommandQueue)) {
        char *message = (char*)malloc(sizeof(char) * 229);
        strcpy(message, "You cannot adjust the kernel arguments you are using because the CommandQueue object you provided was ");
        strcat(message, "created with a different context than the one you used to create the Program object you used to create ");
        strcat(message, "the kernel you are using");
        showMessageError(env, message);
        return;
    }
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jint _currentContext = env->GetIntField(_contextProgram, currentContext);
    jsize sizeArray = env->GetArrayLength(arguments);
    jobjectArray _devicesProgram = (jobjectArray)env->GetObjectField(_programKernel, devicesProgram);
    jsize sizeListDevices = env->GetArrayLength(_devicesProgram);
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject device = env->GetObjectArrayElement(_devicesProgram, position);
        jlong maxConstantBufferSize = env->CallLongMethod(device, getMaxConstantBufferSize);
        jint maxConstantArgs = env->CallIntMethod(device, getMaxConstantArgs);
        if (sizeArray > maxConstantArgs || sizeArray > maxConstantBufferSize) {
            char *message = (char*)malloc(sizeof(char) * 479);
            strcpy(message, "You cannot adjust the argument list to the kernel you are using, because the size of the argument list ");
            strcat(message, "exceeds the limit of arguments allowed by the devices in the device list, which you used to create, ");
            strcat(message, "compile, link and build the Program object that used to create the kernel you are using, to know the ");
            strcat(message, "maximum size allowed for the argument list, you must use the getMaxConstantArgs and ");
            strcat(message, "getMaxConstantBufferSize method of the devices in the list of devices in the Program object");
            showMessageError(env, message);
            return;
        }
    }
    jobject device = env->GetObjectArrayElement(_devicesProgram, 0);
    jstring doubleFPConfig = (jstring)env->CallObjectMethod(device, getDoubleFPConfig);
    const char *_doubleFPConfig = env->GetStringUTFChars(doubleFPConfig, NULL);
    typeDataKernelArguments = (int*)malloc(sizeof(int) * sizeArray);
    sizeArraysKernelArguments = (int*)malloc(sizeof(int) * sizeArray);
    sizeArraysDataKernelArguments = (int**)malloc(sizeof((int*)malloc(sizeof(int))) * sizeArray);
    sizeArrayKernelArguments = sizeArray;
    for (jint position = 0; position < sizeArray; position++) {
        jobject argument = env->GetObjectArrayElement(arguments, position);
        if (argument == NULL) {
            char *message = (char*)malloc(sizeof(char) * 149);
            strcpy(message, "You cannot adjust the arguments to the kernel you are using because at least some of the arguments you ");
            strcat(message, "provided in the argument array are set to null");
            showMessageError(env, message);
            return;
        }
        jobject objectClass = env->CallObjectMethod(argument, getClass);
        jboolean _isArray = env->CallBooleanMethod(objectClass, isArray);
        if (!_isArray) {
            if (env->IsInstanceOf((jobject)argument, Integer)) {
                cl_int value = env->CallIntMethod((jobject)argument, intValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_int), &value);
                typeDataKernelArguments[position] = 0;
            } else if (env->IsInstanceOf((jobject)argument, Short)) {
                cl_short value = env->CallShortMethod((jobject)argument, shortValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_short), &value);
                typeDataKernelArguments[position] = 1;
            } else if (env->IsInstanceOf((jobject)argument, Float)) {
                cl_float value = env->CallFloatMethod((jobject)argument, floatValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_float), &value);
                typeDataKernelArguments[position] = 2;
            } else if (env->IsInstanceOf((jobject)argument, Double)) {
                if (strcmp(_doubleFPConfig, "None") == 0) {
                    char *message = (char*)malloc(sizeof(char) * 283);
                    strcpy(message, "You cannot adjust double type data to the kernel method of the c script that you used to create the ");
                    strcat(message, "Program object, which you used to create the kernel you are using, because the gpu of your android ");
                    strcat(message, "device does not support the double type data you want use as kernel method arguments");
                    return;
                }
                cl_double value = env->CallDoubleMethod((jobject)argument, doubleValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_double), &value);
                typeDataKernelArguments[position] = 3;
            } else if (env->IsInstanceOf((jobject)argument, Long)) {
                cl_long value = env->CallLongMethod((jobject)argument, longValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_long), &value);
                typeDataKernelArguments[position] = 4;
            } else if (env->IsInstanceOf((jobject)argument, Byte)) {
                cl_uchar value = env->CallByteMethod((jobject)argument, byteValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_uchar), &value);
                typeDataKernelArguments[position] = 5;
            } else if (env->IsInstanceOf((jobject)argument, Boolean)) {
                cl_bool value = env->CallBooleanMethod((jobject)argument, booleanValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_bool), &value);
                typeDataKernelArguments[position] = 6;
            } else if (env->IsInstanceOf((jobject)argument, Character)) {
                char value = env->CallCharMethod((jobject)argument, charValue);
                dataKernelArguments[position] = &value;
                Result = SetKernelArg(_currentKernel, position, sizeof(char), &value);
                typeDataKernelArguments[position] = 7;
            } else if (env->IsInstanceOf((jobject)argument, String)) {
                jsize size = env->GetStringLength((jstring)argument);
                char *value = (char*)env->GetStringUTFChars((jstring)argument, NULL);
                dataKernelArguments[position] = value;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, value, sizeof(char) * size);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], value, sizeof(char) * size);
                sizeArraysDataKernelArguments[position] = &size;
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 8;
            } else if (env->IsInstanceOf((jobject)argument, Buffer)) {
                jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
                jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
                jfieldID flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
                jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
                jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
                jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
                jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
                jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
                jint _currentBuffer = env->GetIntField((jobject)argument, currentBuffer);
                if (_currentBuffer == -1) {
                    char *message = (char*)malloc(sizeof(char) * 121);
                    strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is of the Buffer type ");
                    strcat(message, "and it is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextBuffer = env->GetObjectField((jobject)argument, contextBuffer);
                if (!env->IsSameObject(_contextProgram, _contextBuffer)) {
                    char *message = (char*)malloc(sizeof(char) * 183);
                    strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is of the ");
                    strcat(message, "Buffer type and was not created in the same context that you used to create the kernel");
                    showMessageError(env, message);
                    return;
                }
                jint _currentBufferRegion = env->GetIntField((jobject)argument, currentBufferRegion);
                jint _flagMapBuffer = env->GetLongField((jobject)argument, flagMapBuffer);
                jint _sizeBlockMemorySubBuffer = env->GetIntField((jobject)argument, sizeBlockMemorySubBuffer);
                jboolean _isSubBuffer = env->GetBooleanField((jobject)argument, isSubBuffer);
                jobject _bufferData = env->GetObjectField((jobject)argument, bufferData);
                jstring typeData = (jstring)env->GetObjectField((jobject)argument, typeDataBuffer);
                //dataBufferKernelArguments[position] = createBuffer(_currentContext, &listBuffers[_currentBuffer], sizeof(cl_mem));
                //writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], &listBuffers[_currentBuffer], sizeof(cl_mem));
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &listBuffers[_currentBuffer]);
                dataKernelArguments[position] = &_currentBuffer;
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * 3);
                dataExtraTypeBoolKernelArguments[position] = (cl_bool*)malloc(sizeof(cl_bool));
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * 3);
                dataExtraTypeIntKernelArguments[position][0] = _currentBufferRegion;
                dataExtraTypeIntKernelArguments[position][1] = _flagMapBuffer;
                dataExtraTypeIntKernelArguments[position][2] = _sizeBlockMemorySubBuffer;
                dataExtraTypeBoolKernelArguments[position][0] = _isSubBuffer;
                dataExtraTypeObjectKernelArguments[position][0] = env->NewGlobalRef(_contextBuffer);
                dataExtraTypeObjectKernelArguments[position][1] = env->NewGlobalRef(_bufferData);
                dataExtraTypeObjectKernelArguments[position][2] = env->NewGlobalRef(typeData);
                typeDataKernelArguments[position] = 9;
            } else if (env->IsInstanceOf((jobject)argument, Memory)) {
                jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
                jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
                jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
                jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
                jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
                jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
                jint _currentMemory = env->GetIntField((jobject)argument, currentMemory);
                if (_currentMemory == -1) {
                    char *message = (char*)malloc(sizeof(char) * 121);
                    strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is of the Memory ");
                    strcat(message, "type and it is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextMemory = env->GetObjectField((jobject)argument, contextMemory);
                if (!env->IsSameObject(_contextProgram, _contextMemory)) {
                    char *message = (char*)malloc(sizeof(char) * 183);
                    strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is of the ");
                    strcat(message, "Memory type and was not created in the same context that you used to create the kernel");
                    showMessageError(env, message);
                    return;
                }
                jint _sizeBlockMemory = env->GetIntField((jobject)argument, sizeBlockMemory);
                jint _flagsBlockMemory = env->GetIntField((jobject)argument, flagsBlockMemory);
                jint _flagsMapMemory = env->GetIntField((jobject)argument, flagsMapMemory);
                jobject _dataMemory = env->GetObjectField((jobject)argument, dataMemory);
                cl_uchar *dataBlockMemory = (cl_uchar*)listDataMemory[_currentMemory];
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataBlockMemory, sizeof(cl_uchar) * _sizeBlockMemory);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataBlockMemory, sizeof(cl_uchar) * _sizeBlockMemory);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = &_currentMemory;
                sizeArraysDataKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int));
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * 2);
                *sizeArraysDataKernelArguments[position] = _sizeBlockMemory;
                dataExtraTypeIntKernelArguments[position][0] = _flagsBlockMemory;
                dataExtraTypeIntKernelArguments[position][1] = _flagsMapMemory;
                dataExtraTypeObjectKernelArguments[position][0] = env->NewGlobalRef(_dataMemory);
                dataExtraTypeObjectKernelArguments[position][1] = env->NewGlobalRef(_contextMemory);
                typeDataKernelArguments[position] = 10;
            } else if (env->IsInstanceOf((jobject)argument, Pipe)) {
                jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
                jfieldID packetSize = env->GetFieldID(Pipe, "packetSize", "I");
                jfieldID numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
                jfieldID contextPipe = env->GetFieldID(Pipe, "context", "Lcom/draico/asvappra/opencl/Context;");
                jint _currentPipe = env->GetIntField((jobject)argument, currentPipe);
                if (_currentPipe == -1) {
                    char *message = (char*)malloc(sizeof(char) * 119);
                    strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is of the Pipe ");
                    strcat(message, "type and it is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextPipe = env->GetObjectField((jobject)argument, contextPipe);
                if (!env->IsSameObject(_contextProgram, _contextPipe)) {
                    char *message = (char*)malloc(sizeof(char) * 181);
                    strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is of the ");
                    strcat(message, "Pipe type and was not created in the same context that you used to create the kernel");
                    showMessageError(env, message);
                    return;
                }
                jint _packetSize = env->GetIntField((jobject)argument, packetSize);
                jint _numberPackets = env->GetIntField((jobject)argument, numberPackets);
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listPipes[_currentPipe], sizeof(cl_mem));
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listPipes[_currentPipe], sizeof(cl_mem));
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = &_currentPipe;
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject));
                dataExtraTypeIntKernelArguments[position][0] = _packetSize;
                dataExtraTypeIntKernelArguments[position][1] = _numberPackets;
                dataExtraTypeObjectKernelArguments[position][0] = env->NewGlobalRef(_contextPipe);
                typeDataKernelArguments[position] = 11;
            } else if (env->IsInstanceOf((jobject)argument, Image)) {
                jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
                jfieldID flags = env->GetFieldID(Image, "flags", "I");
                jfieldID flagMap = env->GetFieldID(Image, "flagMap", "I");
                jfieldID contextImage = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
                jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
                jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
                jfieldID buffer = env->GetFieldID(Image, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
                jfieldID dataImage = env->GetFieldID(Image, "dataImage", "[B");
                jint _currentImage = env->GetIntField((jobject)argument, currentImage);
                if (_currentImage == -1) {
                    char *message = (char*)malloc(sizeof(char) * 116);
                    strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is of type ");
                    strcat(message, "Image and it is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextImage = env->GetObjectField((jobject)argument, contextImage);
                if (!env->IsSameObject(_contextProgram, _contextImage)) {
                    char *message = (char*)malloc(sizeof(char) * 182);
                    strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is of the ");
                    strcat(message, "Image type and was not created in the same context that you used to create the kernel");
                    showMessageError(env, message);
                    return;
                }
                jint _flags = env->GetIntField((jobject)argument, flags);
                jint _flagMap = env->GetIntField((jobject)argument, flagMap);
                jobject _imageFormat = env->GetObjectField((jobject)argument, imageFormat);
                jobject _imageDescriptor = env->GetObjectField((jobject)argument, imageDescriptor);
                jobject _buffer = env->GetObjectField((jobject)argument, buffer);
                jobject _dataImage = env->GetObjectField((jobject)argument, dataImage);
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listImage[_currentImage], sizeof(cl_mem));
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listImage[_currentImage], sizeof(cl_mem));
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = &_currentImage;
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * 5);
                dataExtraTypeIntKernelArguments[position][0] = _flags;
                dataExtraTypeIntKernelArguments[position][1] = _flagMap;
                dataExtraTypeObjectKernelArguments[position][0] = env->NewGlobalRef(_imageFormat);
                dataExtraTypeObjectKernelArguments[position][1] = env->NewGlobalRef(_imageDescriptor);
                dataExtraTypeObjectKernelArguments[position][2] = env->NewGlobalRef(_buffer);
                dataExtraTypeObjectKernelArguments[position][3] = env->NewGlobalRef(_contextImage);
                dataExtraTypeObjectKernelArguments[position][4] = env->NewGlobalRef(_dataImage);
                typeDataKernelArguments[position] = 12;
            } else if (env->IsInstanceOf((jobject)argument, Sample)) {
                jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
                jfieldID addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
                jfieldID filterMode = env->GetFieldID(Sample, "filterMode", "I");
                jfieldID isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
                jfieldID contextSample = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
                jint _currentSample = env->GetIntField((jobject)argument, currentSample);
                if (_currentSample == -1) {
                    char *message = (char*)malloc(sizeof(char) * 112);
                    strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is of type Sample ");
                    strcat(message, "and it is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextSample = env->GetObjectField((jobject)argument, contextSample);
                if (!env->IsSameObject(_contextProgram, _contextSample)) {
                    char *message = (char*)malloc(sizeof(char) * 183);
                    strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is of the Sample type ");
                    strcat(message, "and was not created in the same context that you used to create the kernel");
                    showMessageError(env, message);
                    return;
                }
                jint _addressingMode = env->GetIntField((jobject)argument, addressingMode);
                jint _filterMode = env->GetIntField((jobject)argument, filterMode);
                jboolean _isNormalizedCoords = env->GetBooleanField((jobject)argument, isNormalizedCoords);
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listSamplers[_currentSample], sizeof(cl_sampler));
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listSamplers[_currentSample], sizeof(cl_sampler));
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = &_currentSample;
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * 2);
                dataExtraTypeBoolKernelArguments[position] = (cl_bool*)malloc(sizeof(cl_bool));
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject));
                dataExtraTypeIntKernelArguments[position][0] = _addressingMode;
                dataExtraTypeIntKernelArguments[position][1] = _filterMode;
                dataExtraTypeBoolKernelArguments[position][0] = _isNormalizedCoords;
                dataExtraTypeObjectKernelArguments[position][0] = env->NewGlobalRef(_contextSample);
                typeDataKernelArguments[position] = 13;
            } else {
                char *message = (char*)malloc(sizeof(char) * 407);
                strcpy(message, "You cannot adjust the arguments to the kernel you are using because at least some of the arguments ");
                strcat(message, "you provided in the array of arguments are not of a permitted data type, the only data allowed is of ");
                strcat(message, "the int, char, boolean, float, double type , byte, long, short and of the object types are Integer, ");
                strcat(message, "Character, Boolean, Float, Double, Byte, Long, Short, String, Buffer, Memory, Image, Pipe, and Sample");
                showMessageError(env, message);
                return;
            }
        } else {
            jsize sizeDataArray = env->GetArrayLength((jobjectArray)argument);
            if (sizeDataArray == 0) {
                char *message = (char*)malloc(sizeof(char) * 129);
                strcpy(message, "You cannot adjust the kernel arguments because one of the arguments you have provided is a data list, ");
                strcat(message, "but this data list is empty");
                showMessageError(env, message);
                return;
            }
            sizeArraysKernelArguments[position] = sizeDataArray;
            jstring name = (jstring)env->CallObjectMethod(objectClass, getName);
            const char *_name = env->GetStringUTFChars(name, NULL);
            if (strcmp(_name, "[I") == 0) {
                cl_int *dataArray = env->GetIntArrayElements((jintArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_int) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_int) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 14;
            } else if (strcmp(_name, "[S") == 0) {
                cl_short *dataArray = env->GetShortArrayElements((jshortArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_short) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_short) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 15;
            } else if (strcmp(_name, "[F") == 0) {
                cl_float *dataArray = env->GetFloatArrayElements((jfloatArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_float) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_float) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 16;
            } else if (strcmp(_name, "[D") == 0) {
                if (strcmp(_doubleFPConfig, "None") == 0) {
                    char *message = (char*)malloc(sizeof(char) * 292);
                    strcpy(message, "You cannot adjust arrays of the double type to the kernel method of the c script that you used ");
                    strcat(message, "to create the Program object, which you used to create the kernel you are using, because the gpu ");
                    strcat(message, "of your android device does not support the double type data you want use as kernel method arguments");
                    return;
                }
                cl_double *dataArray = env->GetDoubleArrayElements((jdoubleArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_double) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_double) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 17;
            } else if (strcmp(_name, "[J") == 0) {
                cl_long *dataArray = env->GetLongArrayElements((jlongArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_double) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_long) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 18;
            } else if (strcmp(_name, "[B") == 0) {
                cl_uchar *dataArray = (cl_uchar*)env->GetByteArrayElements((jbyteArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_uchar) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_uchar) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 19;
            } else if (strcmp(_name, "[C") == 0) {
                char *dataArray = (char*)env->GetCharArrayElements((jcharArray)argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(char) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(char) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 20;
            } else if (strcmp(_name, "[Z") == 0) {
                jboolean *dataArray = env->GetBooleanArrayElements((jbooleanArray) argument, NULL);
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_bool) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_bool) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 21;
            } else if (strcmp(_name, "[Ljava/lang/Integer;") == 0) {
                cl_int *dataArray = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _intValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_intValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 195);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Integer object list, of which at least 1 of the Integer ");
                        strcat(message, "objects is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallIntMethod(_intValue, intValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_int) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_int) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 22;
            } else if (strcmp(_name, "[Ljava.lang.Short;") == 0) {
                cl_short *dataArray = (cl_short*)malloc(sizeof(cl_short) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _shortValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_shortValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 191);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Short object list, of which at least 1 of the Short ");
                        strcat(message, "objects is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallShortMethod(_shortValue, shortValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_short) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_short) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 23;
            } else if (strcmp(_name, "[Ljava.lang.Float;") == 0) {
                cl_float *dataArray = (cl_float*)malloc(sizeof(cl_float) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _floatValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_floatValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 191);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Float object list, of which at least 1 of the Float objects ");
                        strcat(message, "is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallFloatMethod(_floatValue, floatValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_float) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_float) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 24;
            } else if (strcmp(_name, "[Ljava.lang.Double;") == 0) {
                if (strcmp(_doubleFPConfig, "None") == 0) {
                    char *message = (char*)malloc(sizeof(char) * 292);
                    strcpy(message, "You cannot adjust arrays of the Double type to the kernel method of the c script that you used ");
                    strcat(message, "to create the Program object, which you used to create the kernel you are using, because the ");
                    strcat(message, "gpu of your android device does not support the Double type data you want use as kernel method ");
                    strcat(message, "arguments");
                    return;
                }
                cl_double *dataArray = (cl_double*)malloc(sizeof(cl_double) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _doubleValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_doubleValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 193);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Double object list, of which at least 1 of the Double ");
                        strcat(message, "objects is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallDoubleMethod(_doubleValue, doubleValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_double) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_double) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 25;
            } else if (strcmp(_name, "[Ljava.lang.Long;") == 0) {
                cl_long *dataArray = (cl_long*)malloc(sizeof(cl_long) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _longValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_longValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 189);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Long object list, of which at least 1 of the Long objects ");
                        strcat(message, "is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallLongMethod(_longValue, longValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_long) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_long) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 26;
            } else if (strcmp(_name, "[Ljava.lang.Byte;") == 0) {
                cl_uchar *dataArray = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _byteValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_byteValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 189);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Byte object list, of which at least 1 of the Byte objects ");
                        strcat(message, "is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallByteMethod(_byteValue, byteValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_uchar) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_uchar) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 27;
            } else if (strcmp(_name, "[Ljava.lang.Character;") == 0) {
                cl_char *dataArray = (cl_char*)malloc(sizeof(cl_char) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _charValue = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (_charValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 199);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Character object list, of which at least 1 of the ");
                        strcat(message, "Character objects is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallCharMethod(_charValue, charValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_char) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_char) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 28;
            } else if (strcmp(_name, "[Ljava.lang.Boolean;") == 0) {
                cl_bool *dataArray = (cl_bool*)malloc(sizeof(cl_bool) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject _booleanValue = env->GetObjectArrayElement((jobjectArray) argument, positionData);
                    if (_booleanValue == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 195);
                        strcpy(message, "You cannot adjust the list of arguments in the kernel you are using, because the list of ");
                        strcat(message, "arguments you provided contains an Boolean object list, of which at least 1 of the Boolean ");
                        strcat(message, "objects is null");
                        showMessageError(env, message);
                        return;
                    }
                    dataArray[positionData] = env->CallBooleanMethod(_booleanValue, booleanValue);
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(cl_bool) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(cl_bool) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 29;
            } else if (strcmp(_name, "[Ljava.lang.String;") == 0) {
                jsize sizeArray = 0;
                sizeArraysDataKernelArguments[position] = (int*)malloc(sizeof(int) * sizeDataArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject string = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (string == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 136);
                        strcpy(message, "You cannot adjust the kernel argument list you are using because the argument list you ");
                        strcat(message, "provided contains at least one String set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jsize sizeString = env->GetStringLength((jstring)string);
                    if (sizeString == 0) {
                        char *message = (char*)malloc(sizeof(char) * 138);
                        strcpy(message, "You cannot adjust the kernel argument list you are using because the argument list you ");
                        strcat(message, "provided contains at least one String that is empty");
                        showMessageError(env, message);
                        return;
                    }
                    sizeArray += sizeString;
                    sizeArraysDataKernelArguments[position][positionData] = sizeString;
                }
                jint positionString = 0;
                char *dataArray = (char*)malloc(sizeof(char) * sizeArray);
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jstring string = (jstring)env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    jsize sizeString = env->GetStringLength(string);
                    const char *dataString = env->GetStringUTFChars(string, NULL);
                    for (jint positionStringSource = 0; positionStringSource < sizeString; positionStringSource++, positionString++) {
                        dataArray[positionString] = dataString[positionStringSource];
                    }
                }
                dataKernelArguments[position] = dataArray;
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataArray, sizeof(char) * sizeArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataArray, sizeof(char) * sizeArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                typeDataKernelArguments[position] = 30;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.memory.buffer.Buffer;") == 0) {
                jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
                jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
                jfieldID flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
                jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
                jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
                jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
                jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
                jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
                cl_mem *bufferArray = (cl_mem*)malloc(sizeof(cl_mem) * sizeDataArray);
                cl_int *positionBuffers = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray * 3);
                dataExtraTypeBoolKernelArguments[position] = (cl_bool*)malloc(sizeof(cl_bool) * sizeDataArray);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * sizeDataArray * 3);
                jsize sizeList = 0;
                for (jint positionData = 0; positionData < sizeDataArray; positionData++, sizeList++) {
                    jobject buffer = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (buffer == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 162);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Buffer ");
                        strcat(message, "type list and some of the Buffer objects it contains are set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentBuffer = env->GetIntField((jobject)buffer, currentBuffer);
                    if (_currentBuffer == -1) {
                        char *message = (char*)malloc(sizeof(char) * 164);
                        strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is a ");
                        strcat(message, "Buffer type list and some of the Buffer objects it contains are invalids");
                        showMessageError(env, message);
                        return;
                    }
                    jobject _contextBuffer = env->GetObjectField((jobject)buffer, contextBuffer);
                    if (!env->IsSameObject(_contextProgram, _contextBuffer)) {
                        char *message = (char*)malloc(sizeof(char) * 218);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Buffer ");
                        strcat(message, "type list and some of the Buffer objects it contains were not created in the same context that ");
                        strcat(message, "you used to create the kernel");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentBufferRegion = env->GetIntField((jobject)buffer, currentBufferRegion);
                    jint _flagMapBuffer = env->GetLongField((jobject)buffer, flagMapBuffer);
                    jint _sizeBlockMemorySubBuffer = env->GetIntField((jobject)buffer, sizeBlockMemorySubBuffer);
                    jboolean _isSubBuffer = env->GetBooleanField((jobject)buffer, isSubBuffer);
                    jobject _bufferData = env->GetObjectField((jobject)buffer, bufferData);
                    jstring typeData = (jstring)env->GetObjectField((jobject)buffer, typeDataBuffer);
                    dataExtraTypeIntKernelArguments[position][positionData * 3] = _currentBufferRegion;
                    dataExtraTypeIntKernelArguments[position][positionData * 3 + 1] = _flagMapBuffer;
                    dataExtraTypeIntKernelArguments[position][positionData * 3 + 2] = _sizeBlockMemorySubBuffer;
                    dataExtraTypeBoolKernelArguments[position][positionData] = _isSubBuffer;
                    dataExtraTypeObjectKernelArguments[position][positionData * 3] = env->NewGlobalRef(_contextBuffer);
                    dataExtraTypeObjectKernelArguments[position][positionData * 3 + 1] = env->NewGlobalRef(_bufferData);
                    dataExtraTypeObjectKernelArguments[position][positionData * 3 + 2] = env->NewGlobalRef(typeData);
                    bufferArray[positionData] = *listBuffers[_currentBuffer];
                    positionBuffers[positionData] = _currentBuffer;
                }
                dataBufferKernelArguments[position] = createBuffer(_currentContext, bufferArray, sizeof(cl_mem) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], bufferArray, sizeof(cl_mem) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = positionBuffers;
                typeDataKernelArguments[position] = 31;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.memory.Memory;") == 0) {
                jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
                jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
                jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
                jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
                jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
                jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
                cl_int *positionMemory = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                sizeArraysDataKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * sizeDataArray * 2);
                jsize sizeList = 0;
                for (jint positionData = 0; positionData < sizeDataArray; positionData++) {
                    jobject memory = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (memory == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 162);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Memory type list ");
                        strcat(message, "and some of the Memory objects it contains are set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentMemory = env->GetIntField(memory, currentMemory);
                    if (_currentMemory == -1) {
                        char *message = (char*)malloc(sizeof(char) * 164);
                        strcpy(message, "You cannot adjust the kernel arguments that you are using because one of the arguments is a Memory type ");
                        strcat(message, "list and some of the Memory objects it contains are invalids");
                        showMessageError(env, message);
                        return;
                    }
                    jobject _contextMemory = env->GetObjectField(memory, contextMemory);
                    if (!env->IsSameObject(_contextProgram, _contextMemory)) {
                        char *message = (char*)malloc(sizeof(char) * 218);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Memory type list ");
                        strcat(message, "and some of the Memory objects it contains were not created in the same context that you used to create ");
                        strcat(message, "the kernel");
                        showMessageError(env, message);
                        return;
                    }
                    positionMemory[positionData] = _currentMemory;
                    jsize _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
                    jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
                    jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
                    jobject _dataMemory = env->GetObjectField(memory, dataMemory);
                    dataExtraTypeIntKernelArguments[position][positionData * 2] = _flagsBlockMemory;
                    dataExtraTypeIntKernelArguments[position][positionData * 2 + 1] = _flagsMapMemory;
                    dataExtraTypeObjectKernelArguments[position][positionData * 2] = env->NewGlobalRef(_dataMemory);
                    dataExtraTypeObjectKernelArguments[position][positionData * 2 + 1] = env->NewGlobalRef(_contextMemory);
                    sizeArraysDataKernelArguments[position][positionData] = _sizeBlockMemory;
                    sizeList += _sizeBlockMemory;
                }
                jint positionBlockMemory = 0;
                cl_uchar *dataBlocksMemory = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeList);
                for (jint positionMemory = 0; positionMemory < sizeDataArray; positionMemory++) {
                    cl_uchar *dataMemory = (cl_uchar*)listDataMemory[positionMemory];
                    jsize _sizeBlockMemory = sizeArraysDataKernelArguments[position][positionMemory];
                    for (jint positionBlockMemorySource = 0; positionBlockMemorySource < _sizeBlockMemory; positionBlockMemorySource++) {
                    dataMemory[positionBlockMemory] = dataMemory[positionBlockMemorySource];
                    positionBlockMemory++;
                    }
                }
                dataBufferKernelArguments[position] = createBuffer(_currentContext, dataBlocksMemory, sizeof(cl_uchar) * sizeList);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], dataBlocksMemory, sizeof(cl_uchar) * sizeList);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = positionMemory;
                typeDataKernelArguments[position] = 32;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.image.Image;") == 0) {
                jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
                jfieldID flags = env->GetFieldID(Image, "flags", "I");
                jfieldID flagMap = env->GetFieldID(Image, "flagMap", "I");
                jfieldID dataImage = env->GetFieldID(Image, "dataImage", "[B");
                jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
                jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
                jfieldID buffer = env->GetFieldID(Image, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
                jfieldID contextImage = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
                cl_mem *listArrayImages = (cl_mem*)malloc(sizeof(cl_mem) * sizeDataArray);
                cl_int *positionImages = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * sizeDataArray * 5);
                jsize sizeList = 0;
                for (jint positionData = 0; positionData < sizeDataArray; positionData++, sizeList++) {
                    jobject image = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (image == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 160);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Image ");
                        strcat(message, "type list and some of the Image objects it contains are set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentImage = env->GetIntField(image, currentImage);
                    if (_currentImage == -1) {
                        char *message = (char*)malloc(sizeof(char) * 154);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list ");
                        strcat(message, "of type Image and at least one object of type Image is invalid");
                        showMessageError(env, message);
                        return;
                    }
                    jobject _contextImage = env->GetObjectField(image, contextImage);
                    if (!env->IsSameObject(_contextProgram, _contextImage)) {
                        char *message = (char*)malloc(sizeof(char) * 225);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list ");
                        strcat(message, "of the Image type and at least one object of the Image type was not created using the same ");
                        strcat(message, "context that you used to create the kernel");
                        showMessageError(env, message);
                        return;
                    }
                    jint _flags = env->GetIntField(image, flags);
                    jint _flagMap = env->GetIntField(image, flagMap);
                    jobject _dataImage = env->GetObjectField(image, dataImage);
                    jobject _imageFormat = env->GetObjectField(image, imageFormat);
                    jobject _imageDescriptor = env->GetObjectField(image, imageDescriptor);
                    jobject _buffer = env->GetObjectField(image, buffer);
                    dataExtraTypeIntKernelArguments[position][positionData * 2] = _flags;
                    dataExtraTypeIntKernelArguments[position][positionData * 2 + 1] = _flagMap;
                    dataExtraTypeObjectKernelArguments[position][positionData * 5] = env->NewGlobalRef(_dataImage);
                    dataExtraTypeObjectKernelArguments[position][positionData * 5 + 1] = env->NewGlobalRef(_imageFormat);
                    dataExtraTypeObjectKernelArguments[position][positionData * 5 + 2] = env->NewGlobalRef(_imageDescriptor);
                    dataExtraTypeObjectKernelArguments[position][positionData * 5 + 3] = env->NewGlobalRef(_buffer);
                    dataExtraTypeObjectKernelArguments[position][positionData * 5 + 4] = env->NewGlobalRef(_contextImage);
                    listArrayImages[positionData] = *listImage[_currentImage];
                    positionImages[positionData] = _currentImage;
                }
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listArrayImages, sizeof(cl_mem) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listArrayImages, sizeof(cl_mem) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = positionImages;
                typeDataKernelArguments[position] = 33;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.pipe.Pipe;") == 0) {
                jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
                jfieldID packetSize = env->GetFieldID(Pipe, "packetSize", "I");
                jfieldID numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
                jfieldID contextPipe = env->GetFieldID(Pipe, "context", "Lcom/draico/asvappra/opencl/Context;");
                cl_mem *listArrayPipes = (cl_mem*)malloc(sizeof(cl_mem) * sizeDataArray);
                cl_int *positionPipes = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray * 2);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * sizeDataArray);
                jsize sizeList = 0;
                for (jint positionData = 0; positionData < sizeDataArray; positionData++, sizeList++) {
                    jobject pipe = env->GetObjectArrayElement((jobjectArray)argument, positionData);
                    if (pipe == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 158);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Pipe ");
                        strcat(message, "type list and some of the Pipe objects it contains are set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentPipe = env->GetIntField(pipe, currentPipe);
                    if (_currentPipe == -1) {
                        char *message = (char*)malloc(sizeof(char) * 152);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list of ");
                        strcat(message, "type Pipe and at least one object of type Pipe is invalid");
                        showMessageError(env, message);
                        return;
                    }
                    jobject _contextPipe = env->GetObjectField(pipe, contextPipe);
                    if (!env->IsSameObject(_contextProgram, _contextPipe)) {
                        char *message = (char*)malloc(sizeof(char) * 223);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list ");
                        strcat(message, "of the Pipe type and at least one object of the Pipe type was not created using the same ");
                        strcat(message, "context that you used to create the kernel");
                        showMessageError(env, message);
                        return;
                    }
                    jint _packetSize = env->GetIntField(pipe, packetSize);
                    jint _numberPackets = env->GetIntField(pipe, numberPackets);
                    dataExtraTypeIntKernelArguments[position][positionData * 2] = _packetSize;
                    dataExtraTypeIntKernelArguments[position][positionData * 2 + 1] = _numberPackets;
                    dataExtraTypeObjectKernelArguments[position][positionData] = env->NewGlobalRef(_contextPipe);
                    listArrayPipes[positionData] = *listPipes[_currentPipe];
                    positionPipes[positionData] = _currentPipe;
                }
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listArrayPipes, sizeof(cl_mem) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listArrayPipes, sizeof(cl_mem) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = positionPipes;
                typeDataKernelArguments[position] = 34;
            } else if (strcmp(_name, "[Lcom.draico.asvappra.opencl.image.sample.Sample;") == 0) {
                jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
                jfieldID addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
                jfieldID filterMode = env->GetFieldID(Sample, "filterMode", "I");
                jfieldID isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
                jfieldID contextSample = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
                cl_sampler *listArraySample = (cl_sampler*)malloc(sizeof(cl_sampler) * sizeDataArray);
                cl_int *positionSamples = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray);
                dataExtraTypeIntKernelArguments[position] = (cl_int*)malloc(sizeof(cl_int) * sizeDataArray * 2);
                dataExtraTypeBoolKernelArguments[position] = (cl_bool*)malloc(sizeof(cl_bool) * sizeDataArray);
                dataExtraTypeObjectKernelArguments[position] = (jobject*)malloc(sizeof(jobject) * sizeDataArray);
                jsize sizeList = 0;
                for (jint positionData = 0; positionData < sizeDataArray; positionData++, sizeList++) {
                    jobject sample = env->GetObjectArrayElement((jobjectArray) argument, positionData);
                    if (sample == NULL) {
                        char *message = (char*)malloc(sizeof(char) * 160);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a Sample ");
                        strcat(message, "type list and some of the Sample objects it contains are set to null");
                        showMessageError(env, message);
                        return;
                    }
                    jint _currentSample = env->GetIntField(sample, currentSample);
                    if (_currentSample == -1) {
                        char *message = (char*)malloc(sizeof(char) * 154);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list ");
                        strcat(message, "of type Sample and at least one object of type Sample is invalid");
                        showMessageError(env, message);
                        return;
                    }
                    jobject _contextSample = env->GetObjectField(sample, contextSample);
                    if (!env->IsSameObject(_contextProgram, _contextSample)) {
                        char *message = (char*)malloc(sizeof(char) * 225);
                        strcpy(message, "You cannot adjust the kernel arguments you are using because one of the arguments is a list ");
                        strcat(message, "of the Sample type and at least one object of the Sample type was not created using the ");
                        strcat(message, "same context that you used to create the kernel");
                        showMessageError(env, message);
                        return;
                    }
                    jint _addressingMode = env->GetIntField(sample, addressingMode);
                    jint _filterMode = env->GetIntField(sample, filterMode);
                    jboolean _isNormalizedCoords = env->GetBooleanField(sample, isNormalizedCoords);
                    dataExtraTypeIntKernelArguments[position][positionData * 2] = _addressingMode;
                    dataExtraTypeIntKernelArguments[position][positionData * 2 + 1] = _filterMode;
                    dataExtraTypeBoolKernelArguments[position][positionData] = _isNormalizedCoords;
                    dataExtraTypeObjectKernelArguments[position][positionData] = env->NewGlobalRef(_contextSample);
                    listArraySample[positionData] = *listSamplers[_currentSample];
                    positionSamples[positionData] = _currentSample;
                }
                dataBufferKernelArguments[position] = createBuffer(_currentContext, listArraySample, sizeof(cl_sampler) * sizeDataArray);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[position], listArraySample, sizeof(cl_sampler) * sizeDataArray);
                Result = SetKernelArg(_currentKernel, position, sizeof(cl_mem), &dataBufferKernelArguments[position]);
                dataKernelArguments[position] = positionSamples;
                typeDataKernelArguments[position] = 35;
            } else {
                char *message = (char*)malloc(sizeof(char) * 423);
                strcpy(message, "You cannot adjust the arguments to the kernel you are using because at least some of the arguments you ");
                strcat(message, "provided in the array of arguments are not of a permitted data type, the only data allowed are ");
                strcat(message, "one-dimensional arrays of type int, char, boolean, float , double, byte, long, short and of the object ");
                strcat(message, "types are Integer, Character, Boolean, Float, Double, Byte, Long, Short, String, Buffer, Memory, Image, ");
                strcat(message, "Pipe and Sample");
                showMessageError(env, message);
                return;
            }
        }
        if (*(jint*)Result[1] != CL_SUCCESS) {
            showMessageError(env, (char*)Result[0]);
            return;
        }
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    env->SetBooleanField(kernel, isSetArguments, JNI_TRUE);
}
JNICALL void Java_com_draico_asvappra_opencl_Kernel_setKernelArgumentsSVMPointer(JNIEnv *env, jobject kernel, jobject commandQueue,
                                                 jobjectArray arguments) {
    if (commandQueue == NULL || arguments == NULL) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the CommandQueue object and/or the list of ");
        strcat(message, "arguments you provided is set to null");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 151);
        strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the version of OpenCL that is installed on ");
        strcat(message, "your android device is lower than version 2.0");
        showMessageError(env, message);
        return;
    }
    jsize sizeArray = env->GetArrayLength(arguments);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "You cannot use the setKernelArgumentSVMPointer method because the list of arguments you provided is empty");
        showMessageError(env, message);
        return;
    }
    if ((sizeArray % 2) != 0) {
        char *message = (char*)malloc(sizeof(char) * 99);
        strcpy(message, "You cannot use the setKernelArgumentSVMPointer method because the size of the argument list you provided is ");
        strcat(message, "not a multiple of 2");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentCommandQueue == -1 || _currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the CommandQueue object and/or the kernel ");
        strcat(message, "you are using are invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    jboolean _isSetArguments = env->GetBooleanField(kernel, isSetArguments);
    if (!_isSetArguments) {
        char *message = (char*)malloc(sizeof(char) * 282);
        strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because you have not yet used the setKernelArguments ");
        strcat(message, "method to adjust all other arguments that the kernel function will take, because with the ");
        strcat(message, "setKernelArgumentsSVMPointer method you can only enter or update data of type Memory");
        showMessageError(env, message);
        return;
    }
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextProgram = env->GetObjectField(_program, contextProgram);
    if (!env->IsSameObject(_contextCommandQueue, _contextProgram)) {
        char *message = (char*)malloc(sizeof(char) * 231);
        strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the CommandQueue object you provided was ");
        strcat(message, "created with a different context than the one you used to create the Program object you used to create the ");
        strcat(message, "kernel you are using");
        showMessageError(env, message);
        return;
    }
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jobjectArray memoryBlocks = env->NewObjectArray(sizeArray / 2, Memory, NULL);
    jint *positionBlocksMemory = (jint*)malloc(sizeof(jint) * (sizeArray / 2));
    jint positionArgumentMemory = 0;
    jint positionArgumentInt = 0;
    for (jint position = 0; position < sizeArray; position++) {
        jobject object = env->GetObjectArrayElement(arguments, position);
        if (!env->IsInstanceOf((jobject)object, Integer) && !env->IsInstanceOf((jobject)object, Memory)) {
            char *message = (char*)malloc(sizeof(char) * 153);
            strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the arguments you provided in the argument ");
            strcat(message, "list can only be of the Memory and Integer type");
            showMessageError(env, message);
            return;
        }
        if ((position % 2) == 0) {
            if (env->IsInstanceOf((jobject)object, Memory)) {
                if (object == NULL) {
                    char *message = (char*)malloc(sizeof(char) * 118);
                    strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because some of the Memory objects you ");
                    strcat(message, "provided are set to null");
                    showMessageError(env, message);
                    return;
                }
                jint _currentMemory = env->GetIntField((jobject)object, currentMemory);
                if (_currentMemory == -1) {
                    char *message = (char*)malloc(sizeof(char) * 101);
                    strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because some of the Memory objects are invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextMemory = env->GetObjectField((jobject)object, contextMemory);
                if (!env->IsSameObject(_contextMemory, _contextProgram)) {
                    char *message = (char*)malloc(sizeof(char) * 222);
                    strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because some of the Memory objects were ");
                    strcat(message, "created with a different context than the one you used to create the Program object you used to ");
                    strcat(message, "create the kernel you are using");
                    showMessageError(env, message);
                    return;
                }
                env->SetObjectArrayElement(memoryBlocks, positionArgumentMemory, (jobject)object);
                positionArgumentMemory++;
            } else {
                char *message = (char*)malloc(sizeof(char) * 127);
                strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the even positions in the argument list ");
                strcat(message, "are for Memory type data");
                showMessageError(env, message);
                return;
            }
        } else {
            if (env->IsInstanceOf((jobject)object, Integer)) {
                int value = env->CallIntMethod((jobject)object, intValue);
                positionBlocksMemory[positionArgumentInt] = value;
                positionArgumentInt++;
            } else {
                char *message = (char*)malloc(sizeof(char) * 126);
                strcpy(message, "You cannot use the setKernelArgumentsSVMPointer method because the odd positions in the argument ");
                strcat(message, "list are for Memory type data");
                showMessageError(env, message);
                return;
            }
        }
    }
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    sizeArray = env->GetArrayLength(memoryBlocks);
    void **Result;
    for (jint position = 0; position < sizeArray; position++, numberSVMPointer++) {
        jobject memory = env->GetObjectArrayElement(memoryBlocks, position);
        jint _currentMemory = env->GetIntField(memory, currentMemory);
        jsize _sizeBlockMemory = env->GetIntField(memory, sizeBlockMemory);
        jint positionArgument = positionBlocksMemory[position];
        Result = SetKernelArgumentsSVMPointer(_currentKernel, positionArgument, listDataMemory[_currentMemory]);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            jint _flagsBlockMemory = env->GetIntField(memory, flagsBlockMemory);
            jint _flagsMapMemory = env->GetIntField(memory, flagsMapMemory);
            jobject _dataMemory = env->GetObjectField(memory, dataMemory);
            jobject _contextMemory = env->GetObjectField(memory, contextMemory);
            dataKernelArguments[positionArgument] = &_currentMemory;
            sizeArraysDataKernelArguments[positionArgument] = (cl_int*)malloc(sizeof(cl_int));
            dataExtraTypeIntKernelArguments[positionArgument] = (cl_int*)malloc(sizeof(cl_int) * 2);
            dataExtraTypeObjectKernelArguments[positionArgument] = (jobject*)malloc(sizeof(jobject) * 2);
            *sizeArraysDataKernelArguments[positionArgument] = _sizeBlockMemory;
            dataExtraTypeIntKernelArguments[positionArgument][0] = _flagsBlockMemory;
            dataExtraTypeIntKernelArguments[positionArgument][1] = _flagsMapMemory;
            dataExtraTypeObjectKernelArguments[positionArgument][0] = env->NewGlobalRef(_dataMemory);
            dataExtraTypeObjectKernelArguments[positionArgument][1] = env->NewGlobalRef(_contextMemory);
            typeDataKernelArguments[positionArgument] = 10;
        } else {
            for (jint positionError = 0; positionError < position; positionError++) {
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[positionBlocksMemory[positionError]][0]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[positionBlocksMemory[positionError]][1]);
                dataExtraTypeIntKernelArguments[positionBlocksMemory[positionError]] = NULL;
                dataExtraTypeObjectKernelArguments[positionBlocksMemory[positionError]] = NULL;
            }
            showMessageError(env, (char*)Result[0]);
            return;
        }
    }
}
JNICALL void Java_com_draico_asvappra_opencl_Kernel_setKernelExecInfoSVM(JNIEnv *env, jobject kernel, jobject commandQueue, jint execInfo, jobjectArray arguments) {
    if (commandQueue == NULL || arguments == NULL) {
        char *message = (char*)malloc(sizeof(char) * 136);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the CommandQueue object and/or the list of arguments ");
        strcat(message, "you provided are set to null");
        showMessageError(env, message);
        return;
    }
    if (VersionOpenCL < 2.0) {
        char *message = (char*)malloc(sizeof(char) * 143);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.0");
        showMessageError(env, message);
        return;
    }
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentCommandQueue == -1 || _currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the CommandQueue object and/or the kernel you are ");
        strcat(message, "using are invalid");
        showMessageError(env, message);
        return;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 308);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because you have not yet used the setKernelArguments method ");
        strcat(message, "to adjust all the other arguments that the kernel function will take, because with the setKernelExecInfoSVM ");
        strcat(message, "method you can only enter or update data of type Memory and values of type boolean or Boolean");
        showMessageError(env, message);
        return;
    }
    jint _execInfo = execInfo;
    if ((_execInfo & 0x11B6) == 0x11B6) _execInfo -= 0x11B6;
    if ((_execInfo & 0x11B7) == 0x11B7) _execInfo -= 0x11B7;
    if (_execInfo != 0) {
        char *message = (char*)malloc(sizeof(char) * 477);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because you can only adjust the following values for the ");
        strcat(message, "execInfo variable:\nKernel.EXEC_INFO_SVM_PTRS\nKernel.EXEC_INFO_SVM_FINE_GRAIN_SYSTEM\nThe first value is ");
        strcat(message, "to provide values of the Memory type and the second is to provide Boolean or Boolean values if the kernel ");
        strcat(message, "function that you designed requires the use of both types of data you have to combine and adjust them in ");
        strcat(message, "the execInfo variable of the setKernelExecInfoSVM method");
        showMessageError(env, message);
        return;
    }
    jsize sizeListArguments = env->GetArrayLength(arguments);
    if (sizeListArguments == 0) {
        char *message = (char*)malloc(sizeof(char) * 98);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the list of arguments you provided is empty");
        showMessageError(env, message);
        return;
    }
    if ((sizeListArguments % 2) != 0) {
        char *message = (char*)malloc(sizeof(char) * 261);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the size of the argument list you provided must be ");
        strcat(message, "a multiple of 2 in order that for each argument you adjust in the list you also provide the corresponding ");
        strcat(message, "position for that argument in the kernel function");
        showMessageError(env, message);
        return;
    }
    jclass Boolean = env->FindClass("java/lang/Boolean");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Context = env->FindClass("com/draico/asvappra/opencl/Context");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jclass Program = env->FindClass("com/draico/asvappra/opencl/Program");
    jfieldID currentContext = env->GetFieldID(Context, "currentContext", "I");
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
    jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
    jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
    jfieldID contextMemory = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
    jmethodID booleanValue = env->GetMethodID(Boolean, "booleanValue", "()Z");
    jmethodID intValue = env->GetMethodID(Integer, "intValue", "()I");
    jobject _program = env->GetObjectField(kernel, program);
    jobject _contextProgram = env->GetObjectField(_program, contextProgram);
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    jint _currentContext = env->GetIntField(_contextProgram, currentContext);
    if (!env->IsSameObject(_contextCommandQueue, _contextProgram)) {
        char *message = (char*)malloc(sizeof(char) * 227);
        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the CommandQueue object you provided was created with a context ");
        strcat(message, "different from the context you used to create the Program object you used to create the kernel you are using");
        showMessageError(env, message);
        return;
    }
    jint numberArguments = 0;
    void **Result;
    for (jint position = 0; position < sizeListArguments; position += 2) {
        jobject object = env->GetObjectArrayElement(arguments, position);
        if (!env->IsInstanceOf((jobject)object, Memory) && !env->IsInstanceOf(object, Boolean) &&
            !env->IsInstanceOf((jobject)object, Integer)) {
            char *message = (char*)malloc(sizeof(char) * 156);
            strcpy(message, "You cannot use the setKernelExecInfoSVM method because the arguments in the argument list you provided can only contain ");
            strcat(message, "data of type Memory, boolean and int");
            showMessageError(env, message);
            return;
        }
        if (env->IsInstanceOf((jobject)object, Boolean)) {
            if ((execInfo & 0x11B7) == 0x11B7) {
                jboolean value = env->CallBooleanMethod((jobject)object, booleanValue);
                jint positionArgument;
                if ((position + 1) < sizeListArguments) {
                    jobject obj = env->GetObjectArrayElement(arguments, position + 1);
                    if (!env->IsInstanceOf((jobject)obj, Integer)) {
                        char *message = (char*)malloc(sizeof(char) * 100);
                        strcpy(message, "You cannot use the setKernelExecInfoSVM method because you provided a value of type boolean or ");
                        strcat(message, "Boolean but did not provide a value for the position corresponding to this argument in the ");
                        strcat(message, "kernel function");
                        showMessageError(env, message);
                        return;
                    }
                    positionArgument = env->CallIntMethod((jobject)obj, intValue);
                } else {
                    char *message = (char*)malloc(sizeof(char) * 260);
                    strcpy(message, "You cannot use the setKernelExecInfoSVM method because the last value you provided in the argument ");
                    strcat(message, "list is a boolean or Boolean type but it is missing that you will provide an int value which ");
                    strcat(message, "indicates the position corresponding to the kernel function argument");
                    showMessageError(env, message);
                    return;
                }
                Result = SetKernelExecInfo(_currentKernel, CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM, sizeof(cl_bool), &value);
                if (*(jint*)Result[1] == CL_SUCCESS) {
                    dataKernelArguments[positionArgument] = &value;
                    typeDataKernelArguments[positionArgument] = 6;
                    numberArguments++;
                } else {
                    showMessageError(env, (char*)Result[0]);
                    return;
                }
            } else {
                char *message = (char*)malloc(sizeof(char) * 232);
                strcpy(message, "You cannot use the setKernelExecInfoSVM method because in the argument list it provided a boolean ");
                strcat(message, "value but did not provide the Kernel.EXEC_INFO_SVM_FINE_GRAIN_SYSTEM value to the execInfo variable ");
                strcat(message, "of the setKernelExecInfoSVM method");
                showMessageError(env, message);
                return;
            }
        }
        if (env->IsInstanceOf((jobject)object, Memory)) {
            if ((execInfo & 0x11B6) == 0x11B6) {
                jint _currentMemory = env->GetIntField((jobject)object, currentMemory);
                if (_currentMemory == -1) {
                    char *message = (char*)malloc(sizeof(char) * 120);
                    strcpy(message, "You cannot use the setKernelExecInfoSVM method because at least one of the memory blocks in the ");
                    strcat(message, "argument list is invalid");
                    showMessageError(env, message);
                    return;
                }
                jobject _contextMemory = env->GetObjectField((jobject)object, contextMemory);
                if (!env->IsSameObject(_contextMemory, _contextProgram)) {
                    char *message = (char*)malloc(sizeof(char) * 245);
                    strcpy(message, "You cannot use the setKernelExecInfoSVM method because at least some of the memory blocks in ");
                    strcat(message, "the argument list were created in a context different from the context you used to create the ");
                    strcat(message, "Program object you used to create the kernel you are using");
                    showMessageError(env, message);
                    return;
                }
                jint positionArgument;
                if ((position + 1) < sizeListArguments) {
                    jobject _positionArgument = env->GetObjectArrayElement(arguments, position + 1);
                    if (!env->IsInstanceOf(_positionArgument, Integer)) {
                        char *message = (char*)malloc(sizeof(char) * 335);
                        strcpy(message, "You cannot use the setKernelExecInfoSVM method because the argument list you provided must be ");
                        strcat(message, "organized as follows:\nWhen you provide a Memory object at the following position in the ");
                        strcat(message, "argument list you must provide a value of type int or Integer to specify the argument number ");
                        strcat(message, "that corresponds to the Memory object in the kernel function");
                        showMessageError(env, message);
                        return;
                    }
                    positionArgument = env->CallIntMethod((jobject)_positionArgument, intValue);
                } else {
                    char *message = (char*)malloc(sizeof(char) * 281);
                    strcpy(message, "You cannot use the setKernelExecInfoSVM method because the list of arguments you provided must ");
                    strcat(message, "have the same number of Memory objects as int data to specify the position of those arguments in ");
                    strcat(message, "the kernel, each time you provide a Memory object the following data must be an int value");
                    showMessageError(env, message);
                    return;
                }
                jint _sizeBlockMemory = env->GetIntField((jobject)object, sizeBlockMemory);
                jint _flagsBlockMemory = env->GetIntField((jobject)object, flagsBlockMemory);
                jint _flagsMapMemory = env->GetIntField((jobject)object, flagsMapMemory);
                jobject _dataMemory = env->GetObjectField((jobject)object, dataMemory);
                cl_uchar *dataBlockMemory = (cl_uchar*)listDataMemory[_currentMemory];
                dataBufferKernelArguments[positionArgument] = createBuffer(_currentContext, dataBlockMemory, sizeof(cl_uchar) * _sizeBlockMemory);
                writeBuffer(_currentCommandQueue, &dataBufferKernelArguments[positionArgument], dataBlockMemory, sizeof(cl_uchar) * _sizeBlockMemory);
                Result = SetKernelExecInfo(_currentKernel, CL_KERNEL_EXEC_INFO_SVM_PTRS, sizeof(cl_mem), &dataBufferKernelArguments[positionArgument]);
                if (*(jint*)Result[1] == CL_SUCCESS) {
                    dataKernelArguments[positionArgument] = &_currentMemory;
                    sizeArraysDataKernelArguments[positionArgument] = (cl_int*)malloc(sizeof(cl_int));
                    dataExtraTypeIntKernelArguments[positionArgument] = (cl_int*)malloc(sizeof(cl_int) * 2);
                    dataExtraTypeObjectKernelArguments[positionArgument] = (jobject*)malloc(sizeof(jobject) * 2);
                    *sizeArraysDataKernelArguments[positionArgument] = _sizeBlockMemory;
                    dataExtraTypeIntKernelArguments[positionArgument][0] = _flagsBlockMemory;
                    dataExtraTypeIntKernelArguments[positionArgument][1] = _flagsMapMemory;
                    dataExtraTypeObjectKernelArguments[positionArgument][0] = env->NewGlobalRef(_dataMemory);
                    dataExtraTypeObjectKernelArguments[positionArgument][1] = env->NewGlobalRef(_contextMemory);
                    typeDataKernelArguments[positionArgument] = 10;
                    numberArguments++;
                } else {
                    showMessageError(env, (char*)Result[0]);
                    return;
                }
            } else {
                char *message = (char*)malloc(sizeof(char) * 308);
                strcpy(message, "You cannot use the setKernelExecInfoSVM method because in the list of arguments you provided you ");
                strcat(message, "set at least one Memory object together with its int value to indicate its kernel function position ");
                strcat(message, "but did not set the value Kernel.EXEC_INFO_SVM_PTRS to the execInfo variable of the ");
                strcat(message, "setKernelExecInfoSVM method");
                showMessageError(env, message);
                return;
            }
        }
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_cloneKernel(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 63);
        strcpy(message, "You cannot clone the kernel you are using because it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 138);
        strcpy(message, "You cannot clone the kernel you are using because the version of OpenCL that is installed on your android ");
        strcat(message, "device is lower than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetCloneKernel(_currentKernel);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jfieldID programKernel = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
        jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
        jfieldID isKernelExecuted = env->GetFieldID(Kernel, "isKernelExecuted", "Z");
        jobject kernelCloned = env->AllocObject(Kernel);
        env->SetIntField(kernelCloned, currentKernel, positionCurrentKernel);
        env->SetObjectField(kernelCloned, programKernel, env->GetObjectField(kernel, programKernel));
        env->SetBooleanField(kernelCloned, isSetArguments, env->GetBooleanField(kernel, isSetArguments));
        env->SetBooleanField(kernelCloned, isKernelExecuted, env->GetBooleanField(kernel, isKernelExecuted));
        positionCurrentKernel++;
        return kernelCloned;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getFunctionName(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 79);
        strcpy(message, "You cannot get the function name because the kernel you are using it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetKernelInfo(_currentKernel, CL_KERNEL_FUNCTION_NAME);
    if (*(jint*)Result[1] == CL_SUCCESS) return env->NewStringUTF(dataKernel);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getNumberArguments(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 75);
        strcpy(message, "You cannot get the arguments because the kernel you are using it is invalid");
        showMessageError(env, message);
        return 0;
    }
    void **Result = GetKernelInfo(_currentKernel, CL_KERNEL_NUM_ARGS);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataIntKernel;
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_getContext(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 69);
        strcpy(message, "You cannot get context because the kernel you are using it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID context = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    return env->GetObjectField(_program, context);
}
JNICALL jobject Java_com_draico_asvappra_opencl_Kernel_getProgram(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 69);
        strcpy(message, "You cannot get program because the kernel you are using it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    return env->GetObjectField(kernel, program);
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getAtributes(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 72);
        strcpy(message, "You cannot get attributes because the kernel you are using it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    void **Result = GetKernelInfo(_currentKernel, CL_KERNEL_ATTRIBUTES);
    if (*(jint*)Result[1] == CL_SUCCESS) return env->NewStringUTF(dataKernel);
    else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Kernel_getGlobalWorkSize(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 90);
        strcpy(message, "You cannot use the getGlobalWorkSize method because the device you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jmethodID getType = env->GetMethodID(Device, "getType", "()Ljava/lang/String;");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 115);
        strcpy(message, "You cannot use the getGlobalWorkSize method of the kernel you are using, because the device you provided ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 87);
        strcpy(message, "You cannot use the getGlobalWorkSize method because the kernel you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jfieldID isBuildProgram = env->GetFieldID(Program, "isBuildProgram", "Z");
    jfieldID isCompileProgram = env->GetFieldID(Program, "isCompileProgram", "Z");
    jfieldID isLinkedProgram = env->GetFieldID(Program, "isLinkedProgram", "Z");
    jboolean _isBuildProgram = env->GetBooleanField(_program, isBuildProgram);
    jboolean _isCompileProgram = env->GetBooleanField(_program, isCompileProgram);
    jboolean _isLinkedProgram = env->GetBooleanField(_program, isLinkedProgram);
    jstring typeDevice = (jstring)env->CallObjectMethod(device, getType);
    const char *_typeDevice = env->GetStringUTFChars(typeDevice, NULL);
    if (strcmp(_typeDevice, "Custom") != 0 || (!_isBuildProgram && !_isCompileProgram && !_isLinkedProgram)) {
        char *message = (char*)malloc(sizeof(char) * 230);
        strcpy(message, "You cannot use the getGlobalWorkSize method because the device you provided is not a custom device and/or ");
        strcat(message, "the kernel you are using was created with a Program object which was created with the ");
        strcat(message, "createProgramWithBuiltInKernels method");
        showMessageError(env, message);
        return NULL;
    }
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 316);
        strcpy(message, "You cannot use the getGlobalWorkSize method because the device you provided does not belong to the list of ");
        strcat(message, "devices you used to create the Program object you used to create the kernel you are using, so the device ");
        strcat(message, "does not belong to the list of devices you provided when compiling , linked and built the Program object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_GLOBAL_WORK_SIZE);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jint *data = (jint*)malloc(sizeof(jint) * 3);
        for (jint position = 0; position < 2; position++) {
            data[position] = dataSizeTKernel[position];
        }
        jintArray dataArray = env->NewIntArray(3);
        env->SetIntArrayRegion(dataArray, 0, 3, data);
        return dataArray;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getWorkGroupSize(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 102);
        strcpy(message, "You cannot get the size of the kernel workgroup you are using, because the device you provided is null");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 105);
        strcpy(message, "You cannot get the size of the kernel workgroup you are using, because the device you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "You cannot get the size of the kernel workgroup you are using, because the kernel is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 366);
        strcpy(message, "You cannot get the size of the kernel workgroup that you are using, because the device you provided does ");
        strcat(message, "not belong to the list of devices you provided when I created the Program object that I used to create the ");
        strcat(message, "kernel, the device also does not correspond to the list of devices you provided when you executed the ");
        strcat(message, "buildProgram, linkProgram and compileProgram methods");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_WORK_GROUP_SIZE);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Kernel_getCompileWorkGroupSize(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 125);
        strcpy(message, "You cannot use the getCompileWorkGroupSize method of the kernel you are using, because the device you ");
        strcat(message, "provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot use the getCompileWorkGroupSize method of the kernel you are using, because the device you ");
        strcat(message, "provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot use the getCompileWorkGroupSize method of the kernel you are using, because the kernel you ");
        strcat(message, "are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 328);
        strcpy(message, "You cannot use the getCompileWorkGroupSize method of the kernel you are using, because the device ");
        strcat(message, "you provided not belong to the list of devices you used to create the Program object you used to ");
        strcat(message, "create the kernel you are using, the device also not belong to the list of devices used to compile, ");
        strcat(message, "link and build the Program object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_COMPILE_WORK_GROUP_SIZE);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        jint *dataArray = (jint*)malloc(sizeof(jint) * 3);
        for (jint position = 0; position < 3; position++) {
            dataArray[position] = dataSizeTKernel[position];
        }
        jintArray _dataArray = env->NewIntArray(3);
        env->SetIntArrayRegion(_dataArray, 0, 3, dataArray);
        return _dataArray;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jlong Java_com_draico_asvappra_opencl_Kernel_getLocalMemorySize(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot get the size of the local memory used by the kernel you are using, because the device you ");
        strcat(message, "provided is set to null");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 120);
        strcpy(message, "You cannot get the size of the local memory used by the kernel you are using, because the device you ");
        strcat(message, "provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 107);
        strcpy(message, "You cannot get the size of the local memory used by the kernel you are using, because the kernel is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 392);
        strcpy(message, "You cannot get the size of the local memory used by the kernel you are using, because the device you ");
        strcat(message, "provided does not belongto the list of devices you provided when you created the Program object you ");
        strcat(message, "used to create the kernel, as well as provided alist of devices when you compiled, linked and built ");
        strcat(message, "the Program object and the device you provided does not belong to any of the device lists");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_LOCAL_MEM_SIZE);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataLongKernel;
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getPreferredWorkSizeMultiple(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "You cannot use the getPreferredWorkSizeMultiple method of the kernel you are using, because the device ");
        strcat(message, "you provided is set to null");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot use the getPreferredWorkSizeMultiple method of the kernel you are using, because the device ");
        strcat(message, "you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 113);
        strcpy(message, "You cannot use the getPreferredWorkSizeMultiple method of the kernel you are using, because the kernel ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 370);
        strcpy(message, "You cannot use the getPreferredWorkSizeMultiple method of the kernel you are using, because the ");
        strcat(message, "device you provided does not belong to the list of devices you used to create the Program object you ");
        strcat(message, "used to create the kernel you are using, also thedevice you provided does not belong to the list of ");
        strcat(message, "devices you used when compiling, linking and building the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jlong Java_com_draico_asvappra_opencl_Kernel_getPrivateMemorySize(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 139);
        strcpy(message, "You cannot get the minimum amount of private memory for each kernel work item you are using, because ");
        strcat(message, "the device you provided is set to null");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 135);
        strcpy(message, "You cannot get the minimum amount of private memory for each kernel work item you are using, because ");
        strcat(message, "the device you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot get the minimum amount of private memory for each kernel work item you are using, because ");
        strcat(message, "the kernel is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 363);
        strcpy(message, "You cannot get the minimum amount of private memory for each kernel work item you are using, because ");
        strcat(message, "the device you provided does not belong to the list of devices you used to create the Program object ");
        strcat(message, "that was to create the kernel you are using, so which also not belong to the list of devices that you ");
        strcat(message, "used when you compiled, linked and built the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    void **Result = GetKernelWorkGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_PRIVATE_MEM_SIZE);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataLongKernel;
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getMaxSubGroupSizeForNDRange(JNIEnv *env, jobject kernel, jobject device, jintArray sizeSubGroups) {
    if (device == NULL || sizeSubGroups == NULL) {
        char *message = (char*)malloc(sizeof(char) * 186);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method of the kernel you are using because the device ");
        strcat(message, "is set to null and/or has not provided any data of the size of the current workgroup");
        return 0;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 151);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method because the version of OpenCL that is installed ");
        strcat(message, "on your android device is lower than version 2.1");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 125);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method of the kernel you are using because the device ");
        strcat(message, "you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jsize sizeArray = env->GetArrayLength(sizeSubGroups);
    if (sizeArray == 0) {
        char *message = (char*)malloc(sizeof(char) * 158);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method of the kernel you are using, because you has ");
        strcat(message, "not provided any data of the size of the current workgroup");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 112);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method of the kernel you are using because the kernel ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 351);
        strcpy(message, "You cannot use the getMaxSubGroupSizeForNDRange method of the kernel you are using because the device you ");
        strcat(message, "provided not belong to the list of devices you used to create the Program object you used to create the ");
        strcat(message, "kernel you are using, likewise the device not belong to the list of devices you used when compiling, ");
        strcat(message, "linking, and building the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jboolean _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    jint *dataSizeSubGroup = env->GetIntArrayElements(sizeSubGroups, NULL);
    size_t sizeData;
    void **Result = GetKernelSubGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE,
    sizeof(jint) * sizeArray, dataSizeSubGroup, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getSubGroupCountForNDRange(JNIEnv *env, jobject kernel, jobject device, jintArray localWorkSize) {
    if (device == NULL || localWorkSize == NULL) {
        char *message = (char*)malloc(sizeof(char) * 234);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method of the kernel you are using, because the device you ");
        strcat(message, "provided is set to null, or has not provided the size of the workstation to determine the number of ");
        strcat(message, "subgroups for the workstation");
        showMessageError(env, message);
        return 0;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 149);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method because the version of OpenCL that is installed on ");
        strcat(message, "your android device is lower than version 2.1");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 124);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method of the kernel you are using, because the device you ");
        strcat(message, "provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jsize sizeLocalWorkSize = env->GetArrayLength(localWorkSize);
    if (sizeLocalWorkSize == 0) {
        char *message = (char*)malloc(sizeof(char) * 191);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method of the kernel you are using, because has not provided ");
        strcat(message, "the size of the workstation to determine the number of subgroups for the workstation");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 111);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method of the kernel you are using, because the kernel ");
        strcat(message, "is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 335);
        strcpy(message, "You cannot use the getSubGroupCountForNDRange method of the kernel you are using, because the device you ");
        strcat(message, "provided not belong to the list of devices you used to create the Program object you used to create the ");
        strcat(message, "kernel you are using, likewise the device not belong to the list of devices used to compile, link and ");
        strcat(message, "build the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    jint *dataLocalWorkSize = env->GetIntArrayElements(localWorkSize, NULL);
    size_t sizeData;
    void **Result = GetKernelSubGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE,
                                          sizeof(jint)*sizeLocalWorkSize, dataLocalWorkSize, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jintArray Java_com_draico_asvappra_opencl_Kernel_getLocalSizeForSubGroupCount(JNIEnv *env, jobject kernel, jobject device, jint numberSubGroups) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 130);
        strcpy(message, "You cannot use the getLocalSizeForSubGroupCount method of the kernel you are using, because the device you ");
        strcat(message, "provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 150);
        strcpy(message, "You cannot use the getLocaSizeForSubGroupCount method because the version of OpenCL that is installed on ");
        strcat(message, "your android device is lower than version 2.1");
        showMessageError(env, message);
        return NULL;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 126);
        strcpy(message, "You cannot use the getLocalSizeForSubGroupCount method of the kernel you are using, because the device you ");
        strcat(message, "provided is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 113);
        strcpy(message, "You cannot use the getLocalSizeForSubGroupCount method of the kernel you are using, because the kernel is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 352);
        strcpy(message, "You cannot use the getLocalSizeForSubGroupCount method of the kernel you are using, because the device you ");
        strcat(message, "provided not belong to the list of devices you used to create the Program object you used to create the ");
        strcat(message, "kernel you are using, likewise the device not belong to the list of devices you used when compiling, ");
        strcat(message, "linking, and building the Program object");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    size_t sizeData;
    void **Result = GetKernelSubGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT,
                                          sizeof(jint),
    &numberSubGroups, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) {
        sizeData /= sizeof(size_t);
        jint *dataArray = (jint*)malloc(sizeof(jint) * sizeData);
        for (jint position = 0; position < sizeData; position++) {
            dataArray[position] = dataSizeTKernel[position];
        }
        jintArray _dataArray = env->NewIntArray(sizeData);
        env->SetIntArrayRegion(_dataArray, 0, sizeData, dataArray);
        return _dataArray;
    } else {
        showMessageError(env, (char*)Result[0]);
        return NULL;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getMaxNumberSubGroups(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 156);
        strcpy(message, "You cannot get the maximum number of subgroups for each workstation that can run in the kernel you are ");
        strcat(message, "using, because the device you provided is set to null");
        showMessageError(env, message);
        return 0;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 144);
        strcpy(message, "You cannot use the getMaxNumberSubGroups method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.1");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 152);
        strcpy(message, "You cannot get the maximum number of subgroups for each workstation that can run in the kernel you are ");
        strcat(message, "using, because the device you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 139);
        strcpy(message, "You cannot get the maximum number of subgroups for each workstation that can run in the kernel you are using, ");
        strcat(message, "because the kernel is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 339);
        strcpy(message, "You cannot get the maximum number of subgroups of each workstation available to the kernel you are using, ");
        strcat(message, "because the deviceyou provided not belong to the list of devices you provided when you created the Program ");
        strcat(message, "object, likewise the device not belong to the list of devices you used when you compiled, linked and built ");
        strcat(message, "the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    size_t sizeData;
    void **Result = GetKernelSubGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_MAX_NUM_SUB_GROUPS, NULL, NULL,
                                          &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNICALL jint Java_com_draico_asvappra_opencl_Kernel_getCompileNumSubGroups(JNIEnv *env, jobject kernel, jobject device) {
    if (device == NULL) {
        char *message = (char*)malloc(sizeof(char) * 261);
        strcpy(message, "You cannot use the getCompileNumSubGroups method to obtain the number of subgroups specified in the c or ");
        strcat(message, "SPIRV source code that you provided to create the Program object you used to create the kernel you are ");
        strcat(message, "using, because the device you provided is set to null");
        showMessageError(env, message);
        return 0;
    }
    if (VersionOpenCL < 2.1) {
        char *message = (char*)malloc(sizeof(char) * 145);
        strcpy(message, "You cannot use the getCompileNumSubGroups method because the version of OpenCL that is installed on your ");
        strcat(message, "android device is lower than version 2.1");
        showMessageError(env, message);
        return 0;
    }
    jclass Device = env->GetObjectClass(device);
    jfieldID currentDevice = env->GetFieldID(Device, "currentDevice", "I");
    jint _currentDevice = env->GetIntField(device, currentDevice);
    if (_currentDevice == -1) {
        char *message = (char*)malloc(sizeof(char) * 257);
        strcpy(message, "You cannot use the getCompileNumSubGroups method to obtain the number of subgroups specified in the c or ");
        strcat(message, "SPIRV source code that you provided to create the Program object you used to create the kernel you are ");
        strcat(message, "using, because the device you provided is invalid");
        showMessageError(env, message);
        return 0;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 244);
        strcpy(message, "You cannot use the getCompileNumSubGroups method to obtain the number of subgroups specified in the c or ");
        strcat(message, "SPIRV source code that you provided to create the Program object you used to create the kernel you are ");
        strcat(message, "using, because the kernel is invalid");
        showMessageError(env, message);
        return 0;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID devices = env->GetFieldID(Program, "devices", "[Lcom/draico/asvappra/opencl/Device;");
    jobjectArray _devices = (jobjectArray)env->GetObjectField(_program, devices);
    jsize sizeListDevices = env->GetArrayLength(_devices);
    jboolean foundDevice = JNI_FALSE;
    for (jint position = 0; position < sizeListDevices; position++) {
        jobject deviceProgram = env->GetObjectArrayElement(_devices, position);
        if (env->IsSameObject(device, deviceProgram)) {
            foundDevice = JNI_TRUE;
            break;
        }
    }
    if (!foundDevice) {
        char *message = (char*)malloc(sizeof(char) * 494);
        strcpy(message, "You cannot use the getCompileNumSubGroups method to obtain the number of subgroups specified in the SPIRV co ");
        strcat(message, "source code that you provided to create the Program object you used to create the kernel you are using, because ");
        strcat(message, "the device you provided not belong to the list of devices that you used to create the Program object that you ");
        strcat(message, "used to create the kernelyou are using, likewise the device not belong to the list of devices that you used ");
        strcat(message, "when you compiled, linked and built the Program object");
        showMessageError(env, message);
        return 0;
    }
    jfieldID currentSubDevice = env->GetFieldID(Device, "currentSubDevice", "I");
    jfieldID isDevicePartition = env->GetFieldID(Device, "isDevicePartition", "Z");
    jint _currentSubDevice;
    if (env->GetBooleanField(device, isDevicePartition)) _currentSubDevice = env->GetIntField(device, currentSubDevice);
    else _currentSubDevice = 0;
    size_t sizeData;
    void **Result = GetKernelSubGroupInfo(_currentKernel, _currentDevice, _currentSubDevice, CL_KERNEL_COMPILE_NUM_SUB_GROUPS,
                                          NULL, NULL, &sizeData);
    if (*(jint*)Result[1] == CL_SUCCESS) return dataSizeTKernel[0];
    else {
        showMessageError(env, (char*)Result[0]);
        return 0;
    }
}
JNIEXPORT jobjectArray JNICALL Java_com_draico_asvappra_opencl_Kernel_getArgumentsKernel(JNIEnv *env, jobject kernel, jobject commandQueue) {
    if (commandQueue == NULL) {
        char *message = (char*)malloc(sizeof(char) * 95);
        strcpy(message, "You cannot get the kernel arguments because the CommandQueue object you provided is set to null");
        showMessageError(env, message);
        return NULL;
    }
    jclass Kernel = env->GetObjectClass(kernel);
    jclass CommandQueue = env->GetObjectClass(commandQueue);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jfieldID currentCommandQueue = env->GetFieldID(CommandQueue, "currentCommandQueue", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    jint _currentCommandQueue = env->GetIntField(commandQueue, currentCommandQueue);
    if (_currentKernel == -1 || _currentCommandQueue == -1) {
        char *message = (char*)malloc(sizeof(char) * 111);
        strcpy(message, "You cannot get the kernel arguments because the CommandQueue object and/or the kernel you are using ");
        strcat(message, "are invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isKernelExecuted = env->GetFieldID(Kernel, "isKernelExecuted", "Z");
    jboolean _isKernelExecuted = env->GetBooleanField(kernel, isKernelExecuted);
    if (!_isKernelExecuted) {
        char *message = (char*)malloc(sizeof(char) * 110);
        strcpy(message, "You cannot get the kernel argument list because you have not yet run the kernel using the NDRangeKernel ");
        strcat(message, "method");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID program = env->GetFieldID(Kernel, "program", "Lcom/draico/asvappra/opencl/Program;");
    jobject _program = env->GetObjectField(kernel, program);
    jclass Program = env->GetObjectClass(_program);
    jfieldID contextProgram = env->GetFieldID(Program, "context", "Lcom/draico/asvappra/opencl/Context;");
    jfieldID contextCommandQueue = env->GetFieldID(CommandQueue, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
    jobject _contextProgram = env->GetObjectField(_program, contextProgram);
    jobject _contextCommandQueue = env->GetObjectField(commandQueue, contextCommandQueue);
    if (!env->IsSameObject(_contextProgram, _contextCommandQueue)) {
        char *message = (char*)malloc(sizeof(char) * 210);
        strcpy(message, "You cannot get the kernel arguments because the CommandQueue object you provided was created in a context ");
        strcat(message, "other than the context you used to create the Program object you used to create the kernel you are using");
        showMessageError(env, message);
        return NULL;
    }
    jclass Object = env->FindClass("java/lang/Object");
    jclass String = env->FindClass("java/lang/String");
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass Short = env->FindClass("java/lang/Short");
    jclass Long = env->FindClass("java/lang/Long");
    jclass Float = env->FindClass("java/lang/Float");
    jclass Double = env->FindClass("java/lang/Double");
    jclass Character = env->FindClass("java/lang/Character");
    jclass Boolean = env->FindClass("java/lang/Boolean");
    jclass Byte = env->FindClass("java/lang/Byte");
    jclass HashMap = env->FindClass("java/util/HashMap");
    jclass Buffer = env->FindClass("com/draico/asvappra/opencl/memory/buffer/Buffer");
    jclass Memory = env->FindClass("com/draico/asvappra/opencl/memory/Memory");
    jclass Image = env->FindClass("com/draico/asvappra/opencl/image/Image");
    jclass Sample = env->FindClass("com/draico/asvappra/opencl/image/sample/Sample");
    jclass Pipe = env->FindClass("com/draico/asvappra/opencl/pipe/Pipe");
    jmethodID constructorInteger = env->GetMethodID(Integer, "<init>", "(I)V");
    jmethodID constructorShort = env->GetMethodID(Short, "<init>", "(S)V");
    jmethodID constructorLong = env->GetMethodID(Long, "<init>", "(J)V");
    jmethodID constructorFloat = env->GetMethodID(Float, "<init>", "(F)V");
    jmethodID constructorDouble = env->GetMethodID(Double, "<init>", "(D)V");
    jmethodID constructorBoolean = env->GetMethodID(Boolean, "<init>", "(Z)V");
    jmethodID constructorByte = env->GetMethodID(Byte, "<init>", "(B)V");
    jmethodID constructorCharacter = env->GetMethodID(Character, "<init>", "(C)V");
    jmethodID clearHashMap = env->GetMethodID(HashMap, "clear", "()V");
    jmethodID putDataHashMap = env->GetMethodID(HashMap, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    jfieldID currentBuffer = env->GetFieldID(Buffer, "currentBuffer", "I");
    jfieldID currentMemory = env->GetFieldID(Memory, "currentMemory", "I");
    jfieldID currentImage = env->GetFieldID(Image, "currentImage", "I");
    jfieldID currentSample = env->GetFieldID(Sample, "currentSample", "I");
    jfieldID currentPipe = env->GetFieldID(Pipe, "currentPipe", "I");
    jobjectArray arguments = env->NewObjectArray(sizeArrayKernelArguments, Object, NULL);
    for (jint position = 0; position < sizeArrayKernelArguments; position++) {
        if (typeDataKernelArguments[position] == 0) {
            jobject number = env->NewObject(Integer, constructorInteger, *(jint*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 1) {
            jobject number = env->NewObject(Short, constructorShort, *(jshort*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 2) {
            jobject number = env->NewObject(Float, constructorFloat, *(jfloat*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 3) {
            jobject number = env->NewObject(Double, constructorDouble, *(jdouble*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 4) {
            jobject number = env->NewObject(Long, constructorLong, *(jlong*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 5) {
            jobject number = env->NewObject(Byte, constructorByte, *(jchar*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 6) {
            jobject number = env->NewObject(Boolean, constructorBoolean, *(jboolean*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, number);
        } else if (typeDataKernelArguments[position] == 7) {
            jobject data = env->NewObject(Character, constructorCharacter, *(char*)dataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, data);
        } else if (typeDataKernelArguments[position] == 8) {
            char *data = (char*)malloc(sizeof(char) * *sizeArraysDataKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(char) * *sizeArraysDataKernelArguments[position]);
            env->SetObjectArrayElement(arguments, position, env->NewStringUTF(data));
        } else if (typeDataKernelArguments[position] == 9) {
            jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
            jfieldID flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
            jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
            jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
            jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
            jfieldID contextBuffer = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
            jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
            cl_mem *data = (cl_mem*)malloc(sizeof(cl_mem));
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_mem));
            jobject buffer = env->AllocObject(Buffer);
            env->SetIntField(buffer, currentBuffer, *(jint*)dataKernelArguments[position]);
            env->SetIntField(buffer, currentBufferRegion, dataExtraTypeIntKernelArguments[position][0]);
            env->SetLongField(buffer, flagMapBuffer, (jlong)dataExtraTypeIntKernelArguments[position][1]);
            env->SetIntField(buffer, sizeBlockMemorySubBuffer, dataExtraTypeIntKernelArguments[position][2]);
            env->SetBooleanField(buffer, isSubBuffer, (jboolean)dataExtraTypeBoolKernelArguments[position][0]);
            env->SetObjectField(buffer, contextBuffer, dataExtraTypeObjectKernelArguments[position][0]);
            env->SetObjectField(buffer, bufferData, dataExtraTypeObjectKernelArguments[position][1]);
            env->SetObjectField(buffer, typeDataBuffer, dataExtraTypeObjectKernelArguments[position][2]);
            env->SetObjectArrayElement(arguments, position, buffer);
            listBuffers[*(cl_int*)dataKernelArguments[position]] = data;
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][0]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][1]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][2]);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeBoolKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 10) {
            jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
            jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
            jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
            jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
            jfieldID context = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
            jsize sizeBlock = sizeArraysDataKernelArguments[position][0];
            cl_uchar *data = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeBlock);
            cl_int _currentBlockMemory = *(cl_int*)dataKernelArguments[position];
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_uchar) * sizeBlock);
            int *dataInt = dataExtraTypeIntKernelArguments[position];
            jobject *dataObject = dataExtraTypeObjectKernelArguments[position];
            cl_int _flagsBlockMemory = dataInt[0];
            cl_int _flagsMapMemory = dataInt[1];
            jobject hashMap = dataObject[0];
            jobject _context = dataObject[1];
            jbyteArray byteArray = env->NewByteArray(sizeBlock);
            env->SetByteArrayRegion(byteArray, 0, sizeBlock, (jbyte*)data);
            jstring dataByte = env->NewStringUTF("byteArrayMemory");
            env->CallVoidMethod(hashMap, clearHashMap);
            env->CallObjectMethod(hashMap, putDataHashMap, dataByte, byteArray);
            jobject memory = env->AllocObject(Memory);
            env->SetIntField(memory, currentMemory, (jint)_currentBlockMemory);
            env->SetIntField(memory, sizeBlockMemory, sizeBlock);
            env->SetIntField(memory, flagsBlockMemory, (jint)_flagsBlockMemory);
            env->SetIntField(memory, flagsMapMemory, (jint)_flagsMapMemory);
            env->SetObjectField(memory, dataMemory, hashMap);
            env->SetObjectField(memory, context, _context);
            env->SetObjectArrayElement(arguments, position, memory);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][0]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][1]);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 11) {
            jfieldID packetSize = env->GetFieldID(Pipe, "packetSize", "I");
            jfieldID numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
            jfieldID context = env->GetFieldID(Pipe, "context", "Lcom/draico/asvappra/opencl/Context;");
            cl_mem data;
            cl_int _currentPipe = *(cl_int*)dataKernelArguments[position];
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], &data, sizeof(cl_mem));
            jobject pipe = env->AllocObject(Pipe);
            env->SetIntField(pipe, currentPipe, (jint)_currentPipe);
            env->SetIntField(pipe, packetSize, dataExtraTypeIntKernelArguments[position][0]);
            env->SetIntField(pipe, numberPackets, dataExtraTypeIntKernelArguments[position][1]);
            env->SetObjectField(pipe, context, dataExtraTypeObjectKernelArguments[position][0]);
            env->SetObjectArrayElement(arguments, position, pipe);
            *listPipes[_currentPipe] = data;
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][0]);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 12) {
            jfieldID flags = env->GetFieldID(Image, "flags", "I");
            jfieldID flagMap = env->GetFieldID(Image, "flagMap", "I");
            jfieldID context = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
            jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
            jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
            jfieldID buffer = env->GetFieldID(Image, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
            jfieldID dataImage = env->GetFieldID(Image, "dataImage", "[B");
            cl_mem data;
            cl_int _currentImage = *(cl_int*)dataKernelArguments[position];
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], &data, sizeof(cl_mem));
            jobject image = env->AllocObject(Image);
            env->SetIntField(image, currentImage, (jint)_currentImage);
            env->SetIntField(image, flags, dataExtraTypeIntKernelArguments[position][0]);
            env->SetIntField(image, flagMap, dataExtraTypeIntKernelArguments[position][1]);
            env->SetObjectField(image, imageFormat, dataExtraTypeObjectKernelArguments[position][0]);
            env->SetObjectField(image, imageDescriptor, dataExtraTypeObjectKernelArguments[position][1]);
            env->SetObjectField(image, buffer, dataExtraTypeObjectKernelArguments[position][2]);
            env->SetObjectField(image, context, dataExtraTypeObjectKernelArguments[position][3]);
            env->SetObjectField(image, dataImage, dataExtraTypeObjectKernelArguments[position][4]);
            env->SetObjectArrayElement(arguments, position, image);
            *listImage[_currentImage] = data;
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][0]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][1]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][2]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][3]);
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][4]);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 13) {
            jfieldID addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
            jfieldID filterMode = env->GetFieldID(Sample, "filterMode", "I");
            jfieldID isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
            jfieldID context = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
            cl_sampler data;
            cl_int _currentSample = *(cl_int*)dataKernelArguments[position];
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], &data, sizeof(cl_sampler));
            jobject sample = env->AllocObject(Sample);
            env->SetIntField(sample, currentSample, (jint)_currentSample);
            env->SetIntField(sample, addressingMode, dataExtraTypeIntKernelArguments[position][0]);
            env->SetIntField(sample, filterMode, dataExtraTypeIntKernelArguments[position][1]);
            env->SetBooleanField(sample, isNormalizedCoords, (jboolean)dataExtraTypeBoolKernelArguments[position][0]);
            env->SetObjectField(sample, context, dataExtraTypeObjectKernelArguments[position][0]);
            env->SetObjectArrayElement(arguments, position, sample);
            *listSamplers[_currentSample] = data;
            env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][0]);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeBoolKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 14 || typeDataKernelArguments[position] == 22) {
            cl_int *data = (cl_int*)malloc(sizeof(cl_int) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_int) * sizeArraysKernelArguments[position]);
            jintArray numbers = env->NewIntArray(sizeArraysKernelArguments[position]);
            env->SetIntArrayRegion(numbers, 0, sizeArraysKernelArguments[position], data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 15 || typeDataKernelArguments[position] == 23) {
            cl_short *data = (cl_short*)malloc(sizeof(cl_short) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_short) * sizeArraysKernelArguments[position]);
            jshortArray numbers = env->NewShortArray(sizeArraysKernelArguments[position]);
            env->SetShortArrayRegion(numbers, 0, sizeArraysKernelArguments[position], data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 16 || typeDataKernelArguments[position] == 24) {
            cl_float *data = (cl_float*)malloc(sizeof(cl_float) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_float) * sizeArraysKernelArguments[position]);
            jfloatArray numbers = env->NewFloatArray(sizeArraysKernelArguments[position]);
            env->SetFloatArrayRegion(numbers, 0, sizeArraysKernelArguments[position], data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 17 || typeDataKernelArguments[position] == 25) {
            cl_double *data = (cl_double*)malloc(sizeof(cl_double) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_double) * sizeArraysKernelArguments[position]);
            jdoubleArray numbers = env->NewDoubleArray(sizeArraysKernelArguments[position]);
            env->SetDoubleArrayRegion(numbers, 0, sizeArraysKernelArguments[position], data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 18 || typeDataKernelArguments[position] == 26) {
            cl_long *data = (cl_long*)malloc(sizeof(cl_long) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_long) * sizeArraysKernelArguments[position]);
            jlongArray numbers = env->NewLongArray(sizeArraysKernelArguments[position]);
            env->SetLongArrayRegion(numbers, 0, sizeArraysKernelArguments[position], data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 19 || typeDataKernelArguments[position] == 27) {
            cl_uchar *data = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_uchar) * sizeArraysKernelArguments[position]);
            jbyteArray numbers = env->NewByteArray(sizeArraysKernelArguments[position]);
            env->SetByteArrayRegion(numbers, 0, sizeArraysKernelArguments[position], (jbyte*)data);
            env->SetObjectArrayElement(arguments, position, numbers);
        } else if (typeDataKernelArguments[position] == 20 || typeDataKernelArguments[position] == 28) {
            char *data = (char*)malloc(sizeof(char) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(char) * sizeArraysKernelArguments[position]);
            jcharArray dataChar = env->NewCharArray(sizeArraysKernelArguments[position]);
            env->SetCharArrayRegion(dataChar, 0, sizeArraysKernelArguments[position], (jchar*)data);
            env->SetObjectArrayElement(arguments, position, dataChar);
        } else if (typeDataKernelArguments[position] == 21 || typeDataKernelArguments[position] == 29) {
            cl_bool *data = (cl_bool*)malloc(sizeof(cl_bool) * sizeArraysKernelArguments[position]);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_bool) * sizeArraysKernelArguments[position]);
            jbooleanArray dataBoolean = env->NewBooleanArray(sizeArraysKernelArguments[position]);
            env->SetBooleanArrayRegion(dataBoolean, 0, sizeArraysKernelArguments[position], (jboolean*)data);
            env->SetObjectArrayElement(arguments, position, dataBoolean);
        } else if (typeDataKernelArguments[position] == 30) {
            jsize sizeArray = sizeArraysKernelArguments[position];
            jsize sizeData = 0;
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                sizeData += sizeArraysDataKernelArguments[position][positionArray];
            }
            char *dataString = (char*)malloc(sizeof(char) * sizeData);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], dataString, sizeData);
            jobjectArray strings = env->NewObjectArray(sizeArray, String, NULL);
            char *_dataString = NULL;
            jint limitString = 0;
            jint positionString = 0;
            jint positionArray = 0;
            for (jint positionData = 0; positionData < sizeData; positionData++) {
                if (_dataString == NULL) {
                jsize sizeString = sizeArraysDataKernelArguments[position][positionArray];
                _dataString = (char*)malloc(sizeof(char) * sizeString);
                limitString += sizeString;
                }
                _dataString[positionString] = dataString[positionData];
                if ((positionData + 1) == limitString) {
                    jstring string = env->NewStringUTF(_dataString);
                    env->SetObjectArrayElement(strings, positionArray, string);
                    positionString = 0;
                    positionArray++;
                    _dataString = NULL;
                } else positionString++;
            }
            env->SetObjectArrayElement(arguments, position, strings);
        } else if (typeDataKernelArguments[position] == 31) {
            jfieldID currentBufferRegion = env->GetFieldID(Buffer, "currentBufferRegion", "I");
            jfieldID flagMapBuffer = env->GetFieldID(Buffer, "flagMapBuffer", "J");
            jfieldID isSubBuffer = env->GetFieldID(Buffer, "isSubBuffer", "Z");
            jfieldID sizeBlockMemorySubBuffer = env->GetFieldID(Buffer, "sizeBlockMemorySubBuffer", "I");
            jfieldID bufferData = env->GetFieldID(Buffer, "bufferData", "Lcom/draico/asvappra/opencl/memory/Memory;");
            jfieldID context = env->GetFieldID(Buffer, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
            jfieldID typeDataBuffer = env->GetFieldID(Buffer, "typeData", "Ljava/lang/String;");
            jsize sizeArray = sizeArraysKernelArguments[position];
            jobjectArray buffers = env->NewObjectArray(sizeArray, Buffer, NULL);
            cl_mem *listBuffers = (cl_mem*)malloc(sizeof(cl_mem) * sizeArray);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], listBuffers, sizeof(cl_mem) * sizeArray);
            jint *positionBuffers = (jint*)dataKernelArguments[position];
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                jobject buffer = env->AllocObject(Buffer);
                env->SetIntField(buffer, currentBuffer, (jint)positionBuffers[positionArray]);
                env->SetIntField(buffer, currentBufferRegion, dataExtraTypeIntKernelArguments[position][positionArray * 3]);
                env->SetLongField(buffer, flagMapBuffer, (jlong)dataExtraTypeIntKernelArguments[position][positionArray * 3 + 1]);
                env->SetIntField(buffer, sizeBlockMemorySubBuffer, dataExtraTypeIntKernelArguments[position][positionArray * 3 + 2]);
                env->SetBooleanField(buffer, isSubBuffer, (jboolean)dataExtraTypeBoolKernelArguments[position][positionArray]);
                env->SetObjectField(buffer, context, dataExtraTypeObjectKernelArguments[position][positionArray * 3]);
                env->SetObjectField(buffer, bufferData, dataExtraTypeObjectKernelArguments[position][positionArray * 3 + 1]);
                env->SetObjectField(buffer, typeDataBuffer, dataExtraTypeObjectKernelArguments[position][positionArray * 3 + 2]);
                env->SetObjectArrayElement(buffers, positionArray, buffer);
                listBuffers[positionBuffers[positionArray]] = listBuffers[positionArray];
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 3]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 3 + 1]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 3 + 2]);
            }
            env->SetObjectArrayElement(arguments, position, buffers);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeBoolKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 32) {
            jfieldID sizeBlockMemory = env->GetFieldID(Memory, "sizeBlockMemory", "I");
            jfieldID flagsBlockMemory = env->GetFieldID(Memory, "flagsBlockMemory", "I");
            jfieldID flagsMapMemory = env->GetFieldID(Memory, "flagsMapMemory", "I");
            jfieldID context = env->GetFieldID(Memory, "currentContext", "Lcom/draico/asvappra/opencl/Context;");
            jfieldID dataMemory = env->GetFieldID(Memory, "dataMemory", "Ljava/util/HashMap;");
            jsize sizeArray = sizeArraysKernelArguments[position];
            jsize *listSizeBlockMemorys = sizeArraysDataKernelArguments[position];
            jobjectArray memorys = env->NewObjectArray(sizeArray, Memory, NULL);
            jint *positionMemorys = (jint*)dataKernelArguments[position];
            jsize sizeTotalBlockMemorys = 0;
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                sizeTotalBlockMemorys += listSizeBlockMemorys[positionArray];
            }
            cl_uchar *data = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeTotalBlockMemorys);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], data, sizeof(cl_uchar) * sizeTotalBlockMemorys);
            jint positionBlockMemorySource = 0;
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                jsize sizeBlock = listSizeBlockMemorys[positionArray];
                cl_uchar *dataBlock = (cl_uchar*)malloc(sizeof(cl_uchar) * sizeBlock);
                for (jint positionBlockMemory = 0; positionBlockMemory < sizeBlock; positionBlockMemory++, positionBlockMemorySource++) {
                    dataBlock[positionBlockMemory] = data[positionBlockMemorySource];
                }
                jstring dataKey = env->NewStringUTF("byteArrayMemory");
                jbyteArray dataBlockMemory = env->NewByteArray(sizeBlock);
                env->SetByteArrayRegion(dataBlockMemory, 0, sizeBlock, (jbyte*)dataBlock);
                jobject _dataMemory = dataExtraTypeObjectKernelArguments[position][positionArray * 2];
                env->CallVoidMethod(_dataMemory, clearHashMap);
                env->CallObjectMethod(_dataMemory, putDataHashMap, dataKey, dataBlockMemory);
                jobject memory = env->AllocObject(Memory);
                env->SetIntField(memory, currentMemory, (jint)positionMemorys[positionArray]);
                env->SetIntField(memory, sizeBlockMemory, sizeBlock);
                env->SetIntField(memory, flagsBlockMemory, dataExtraTypeIntKernelArguments[position][positionArray * 2]);
                env->SetIntField(memory, flagsMapMemory, dataExtraTypeIntKernelArguments[position][positionArray * 2 + 1]);
                env->SetObjectField(memory, dataMemory, _dataMemory);
                env->SetObjectField(memory, context, dataExtraTypeObjectKernelArguments[position][positionArray * 2 + 1]);
                env->SetObjectArrayElement(memorys, positionArray, memory);
                listDataMemory[positionMemorys[positionArray]] = (jbyte*)dataBlock;
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 2]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 2 + 1]);
            }
            env->SetObjectArrayElement(arguments, position, memorys);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 33) {
            jfieldID flags = env->GetFieldID(Image, "flags", "I");
            jfieldID flagMap = env->GetFieldID(Image, "flagMap", "I");
            jfieldID dataImage = env->GetFieldID(Image, "dataImage", "[B");
            jfieldID imageFormat = env->GetFieldID(Image, "imageFormat", "Lcom/draico/asvappra/opencl/image/ImageFormat;");
            jfieldID imageDescriptor = env->GetFieldID(Image, "imageDescriptor", "Lcom/draico/asvappra/opencl/image/ImageDescriptor;");
            jfieldID buffer = env->GetFieldID(Image, "buffer", "Lcom/draico/asvappra/opencl/memory/buffer/Buffer;");
            jfieldID context = env->GetFieldID(Image, "context", "Lcom/draico/asvappra/opencl/Context;");
            jsize sizeArray = sizeArraysKernelArguments[position];
            jobjectArray images = env->NewObjectArray(sizeArray, Image, NULL);
            jint *positionImages = (jint*)dataKernelArguments[position];
            cl_mem *listImages = (cl_mem*)malloc(sizeof(cl_mem) * sizeArray);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], listImages, sizeof(cl_mem) * sizeArray);
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                jobject image = env->AllocObject(Image);
                env->SetIntField(image, currentImage, (jint)positionImages[positionArray]);
                env->SetIntField(image, flags, dataExtraTypeIntKernelArguments[position][positionArray * 2]);
                env->SetIntField(image, flagMap, dataExtraTypeIntKernelArguments[position][positionArray * 2 + 1]);
                env->SetObjectField(image, dataImage, dataExtraTypeObjectKernelArguments[position][positionArray * 5]);
                env->SetObjectField(image, imageFormat, dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 1]);
                env->SetObjectField(image, imageDescriptor, dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 2]);
                env->SetObjectField(image, buffer, dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 3]);
                env->SetObjectField(image, context, dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 4]);
                env->SetObjectArrayElement(images, positionArray, image);
                *listImage[positionImages[positionArray]] = listImages[positionArray];
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 5]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 1]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 2]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 3]);
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray * 5 + 4]);
            }
            env->SetObjectArrayElement(arguments, position, images);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 34) {
            jfieldID packetSize = env->GetFieldID(Pipe, "packetSize", "I");
            jfieldID numberPackets = env->GetFieldID(Pipe, "numberPackets", "I");
            jfieldID context = env->GetFieldID(Pipe, "context", "Lcom/draico/asvappra/opencl/Context;");
            jsize sizeArray = sizeArraysKernelArguments[position];
            jobjectArray pipes = env->NewObjectArray(sizeArray, Pipe, NULL);
            jint *positionPipes = (jint*)dataKernelArguments[position];
            cl_mem *_listPipes = (cl_mem*)malloc(sizeof(cl_mem) * sizeArray);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], _listPipes, sizeof(cl_mem) * sizeArray);
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                jobject pipe = env->AllocObject(Pipe);
                env->SetIntField(pipe, currentPipe, (jint)positionPipes[positionArray]);
                env->SetIntField(pipe, packetSize, dataExtraTypeIntKernelArguments[position][positionArray * 2]);
                env->SetIntField(pipe, numberPackets, dataExtraTypeIntKernelArguments[position][positionArray * 2 +1]);
                env->SetObjectField(pipe, context, dataExtraTypeObjectKernelArguments[position][positionArray]);
                env->SetObjectArrayElement(pipes, positionArray, pipe);
                *listPipes[positionPipes[positionArray]] = _listPipes[positionArray];
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray]);
            }
            env->SetObjectArrayElement(arguments, position, pipes);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        } else if (typeDataKernelArguments[position] == 35) {
            jfieldID addressingMode = env->GetFieldID(Sample, "addressingMode", "I");
            jfieldID filterMode = env->GetFieldID(Sample, "filterMode", "I");
            jfieldID isNormalizedCoords = env->GetFieldID(Sample, "isNormalizedCoords", "Z");
            jfieldID context = env->GetFieldID(Sample, "context", "Lcom/draico/asvappra/opencl/Context;");
            jsize sizeArray = sizeArraysKernelArguments[position];
            jobjectArray samples = env->NewObjectArray(sizeArray, Sample, NULL);
            jint *positionSamples = (jint*)dataKernelArguments[position];
            cl_sampler *listSamples = (cl_sampler*)malloc(sizeof(cl_sampler) * sizeArray);
            readBuffer(_currentCommandQueue, dataBufferKernelArguments[position], listSamples, sizeof(cl_sampler) * sizeArray);
            for (jint positionArray = 0; positionArray < sizeArray; positionArray++) {
                jobject sample = env->AllocObject(Sample);
                env->SetIntField(sample, currentSample, (jint)positionSamples[positionArray]);
                env->SetIntField(sample, addressingMode, dataExtraTypeIntKernelArguments[position][positionArray * 2]);
                env->SetIntField(sample, filterMode, dataExtraTypeIntKernelArguments[position][positionArray * 2 + 1]);
                env->SetBooleanField(sample, isNormalizedCoords, (jboolean)dataExtraTypeBoolKernelArguments[position][positionArray]);
                env->SetObjectField(sample, context, dataExtraTypeObjectKernelArguments[position][positionArray]);
                env->SetObjectArrayElement(samples, positionArray, sample);
                *listSamplers[positionSamples[positionArray]] = listSamples[positionArray];
                env->DeleteGlobalRef(dataExtraTypeObjectKernelArguments[position][positionArray]);
            }
            env->SetObjectArrayElement(arguments, position, samples);
            dataExtraTypeIntKernelArguments[position] = NULL;
            dataExtraTypeBoolKernelArguments[position] = NULL;
            dataExtraTypeObjectKernelArguments[position] = NULL;
        }
    }
    return arguments;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getArgumentAddressQualifier(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 103);
        strcpy(message, "You cannot get the address of qualifier from the argument list that you have set in the kernel, because the ");
        strcat(message, "kernel you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 161);
        strcpy(message, "You cannot get the address of qualifier from the list of arguments that you have set in the kernel, because ");
        strcat(message, "you have not yet adjusted any arguments to the kernel");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getNumberArguments = env->GetMethodID(Kernel, "getNumberArguments", "()I");
    jint numberArguments = env->CallIntMethod(kernel, getNumberArguments);
    jclass String = env->FindClass("java/lang/String");
    jclass Integer = env->FindClass("java/lang/Integer");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("Kernel argument address qualifier list:\n");
    jstring argument = env->NewStringUTF("argument");
    jstring data;
    jstring numberArg;
    void **Result;
    for (jint position = 0; position < numberArguments; position++) {
        Result = GetKernelArgInfo(_currentKernel, position, CL_KERNEL_ARG_ADDRESS_QUALIFIER);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            switch(dataIntKernel) {
                case CL_KERNEL_ARG_ADDRESS_GLOBAL: data = env->NewStringUTF("Global"); break;
                case CL_KERNEL_ARG_ADDRESS_LOCAL: data = env->NewStringUTF("Local"); break;
                case CL_KERNEL_ARG_ADDRESS_CONSTANT: data = env->NewStringUTF("Constant"); break;
                case CL_KERNEL_ARG_ADDRESS_PRIVATE: data = env->NewStringUTF("Private"); break;
            }
            numberArg = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, position);
            toString = (jstring)env->CallObjectMethod(toString, concat, argument);
            toString = (jstring)env->CallObjectMethod(toString, concat, numberArg);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(": "));
            toString = (jstring)env->CallObjectMethod(toString, concat, data);
            if (position < (numberArguments - 1)) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("\n"));
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
    return toString;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getArgumentAccessQualifier(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 140);
        strcpy(message, "You cannot get the list of qualifiers of the access type of the arguments you set in the kernel, because ");
        strcat(message, "the kernel you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 100);
        strcpy(message, "You cannot get the list of qualifiers of the access type of the arguments that you set in the kernel, ");
        strcat(message, "because you have not yet adjusted any arguments to the kernel");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getNumberArguments = env->GetMethodID(Kernel, "getNumberArguments", "()I");
    jint numberArguments = env->CallIntMethod(kernel, getNumberArguments);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("List of access qualifiers for kernel arguments:\n");
    jstring argument = env->NewStringUTF("argument");
    jstring data;
    jstring numberArgument;
    void **Result;
    for (jint position = 0; position < numberArguments; position++) {
        Result = GetKernelArgInfo(_currentKernel, position, CL_KERNEL_ARG_ACCESS_QUALIFIER);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            switch(dataIntKernel) {
                case CL_KERNEL_ARG_ACCESS_READ_ONLY: data = env->NewStringUTF("read only"); break;
                case CL_KERNEL_ARG_ACCESS_WRITE_ONLY: data = env->NewStringUTF("write only"); break;
                case CL_KERNEL_ARG_ACCESS_READ_WRITE: data = env->NewStringUTF("read and write"); break;
                case CL_KERNEL_ARG_ACCESS_NONE: data = env->NewStringUTF(" none"); break;
            }
            numberArgument = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, position);
            toString = (jstring)env->CallObjectMethod(toString, concat, argument);
            toString = (jstring)env->CallObjectMethod(toString, concat, numberArgument);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(": "));
            toString = (jstring)env->CallObjectMethod(toString, concat, data);
            if (position < (numberArguments - 1)) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("\n"));
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
    return toString;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getArgumentTypeName(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot get the list of the data types of the arguments that you set in the kernel you are using because ");
        strcat(message, "it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 162);
        strcpy(message, "You cannot get the list of the data types of the arguments that you set in the kernel you are using, ");
        strcat(message, "because you have not yet adjusted any arguments to the kernel");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getNumberArguments = env->GetMethodID(Kernel, "getNumberArguments", "()I");
    jint numberArguments = env->CallIntMethod(kernel, getNumberArguments);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("List of data types of kernel arguments:\n");
    jstring argument = env->NewStringUTF("argument");
    jstring numberArgument;
    jstring data;
    void **Result;
    for (jint position = 0; position < numberArguments; position++) {
        Result = GetKernelArgInfo(_currentKernel, position, CL_KERNEL_ARG_TYPE_NAME);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            numberArgument = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, position);
            data = env->NewStringUTF(dataKernel);
            toString = (jstring)env->CallObjectMethod(toString, concat, argument);
            toString = (jstring)env->CallObjectMethod(toString, concat, numberArgument);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(": "));
            toString = (jstring)env->CallObjectMethod(toString, concat, data);
            if (position < (numberArguments -1)) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("\n"));
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
    return toString;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getArgumentTypeQualifier(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 86);
        strcpy(message, "You cannot get the list of qualifier types from kernel arguments because it is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 122);
        strcpy(message, "You cannot get the list of qualifier types from kernel arguments because you have not yet adjusted arguments ");
        strcat(message, "to the kernel");
        showMessageError(env, message);
        return NULL;
    }
    jmethodID getNumberArguments = env->GetMethodID(Kernel, "getNumberArguments", "()I");
    jint numberArguments = env->CallIntMethod(kernel, getNumberArguments);
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jstring toString = env->NewStringUTF("List of qualifier types of kernel arguments:\n");
    jstring argument = env->NewStringUTF("argument");
    jstring numberArgument;
    jstring data;
    void **Result;
    for (jint position = 0; position < numberArguments; position++) {
        Result = GetKernelArgInfo(_currentKernel, position, CL_KERNEL_ARG_TYPE_QUALIFIER);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            switch(dataBitfieldKernel) {
                case CL_KERNEL_ARG_TYPE_CONST: data = env->NewStringUTF("const"); break;
                case CL_KERNEL_ARG_TYPE_RESTRICT: data = env->NewStringUTF("restrict"); break;
                case CL_KERNEL_ARG_TYPE_VOLATILE: data = env->NewStringUTF("volatile"); break;
                case CL_KERNEL_ARG_TYPE_PIPE: data = env->NewStringUTF("pipe"); break;
                case CL_KERNEL_ARG_TYPE_NONE: data = env->NewStringUTF("none"); break;
            }
            numberArgument = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, position);
            toString = (jstring)env->CallObjectMethod(toString, concat, argument);
            toString = (jstring)env->CallObjectMethod(toString, concat, numberArgument);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(": "));
            toString = (jstring)env->CallObjectMethod(toString, concat, data);
            if (position < (numberArguments - 1)) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("\n"));
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
    return toString;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_getName(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 92);
        strcpy(message, "You cannot get the list of kernel argument names because the kernel you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    jfieldID isSetArguments = env->GetFieldID(Kernel, "isSetArguments", "Z");
    if (!env->GetBooleanField(kernel, isSetArguments)) {
        char *message = (char*)malloc(sizeof(char) * 121);
        strcpy(message, "You cannot get the kernel argument names list because you have not yet adjusted any arguments to the kernel ");
        strcat(message, "you are using");
        showMessageError(env, message);
        return NULL;
    }
    jclass Integer = env->FindClass("java/lang/Integer");
    jclass String = env->FindClass("java/lang/String");
    jmethodID concat = env->GetMethodID(String, "concat", "(Ljava/lang/String;)Ljava/lang/String;");
    jmethodID toStringInteger = env->GetStaticMethodID(Integer, "toString", "(I)Ljava/lang/String;");
    jmethodID getNumberArguments = env->GetMethodID(Kernel, "getNumberArguments", "()I");
    jint numberArguments = env->CallIntMethod(kernel, getNumberArguments);
    jstring toString = env->NewStringUTF("List of kernel argument names:\n");
    jstring argument = env->NewStringUTF("argument");
    jstring numberArgument;
    void **Result;
    for (jint position = 0; position < numberArguments; position++) {
        Result = GetKernelArgInfo(_currentKernel, position, CL_KERNEL_ARG_NAME);
        if (*(jint*)Result[1] == CL_SUCCESS) {
            numberArgument = (jstring)env->CallStaticObjectMethod(Integer, toStringInteger, position);
            toString = (jstring)env->CallObjectMethod(toString, concat, argument);
            toString = (jstring)env->CallObjectMethod(toString, concat, numberArgument);
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(": "));
            toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF(dataKernel));
            if (position < (numberArguments - 1)) toString = (jstring)env->CallObjectMethod(toString, concat, env->NewStringUTF("\n"));
        } else {
            showMessageError(env, (char*)Result[0]);
            return NULL;
        }
    }
    return toString;
}
JNICALL jstring Java_com_draico_asvappra_opencl_Kernel_toString(JNIEnv *env, jobject kernel) {
    jclass Kernel = env->GetObjectClass(kernel);
    jfieldID currentKernel = env->GetFieldID(Kernel, "currentKernel", "I");
    jint _currentKernel = env->GetIntField(kernel, currentKernel);
    if (_currentKernel == -1) {
        char *message = (char*)malloc(sizeof(char) * 83);
        strcpy(message, "You cannot convert the kernel to string because the kernel you are using is invalid");
        showMessageError(env, message);
        return NULL;
    }
    return kernelToString(env, kernel);
}
};